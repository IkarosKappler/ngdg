{"version":3,"sources":["webpack://earcut-typescript/./src/cjs/earcut.js","webpack://earcut-typescript/webpack/bootstrap","webpack://earcut-typescript/./src/cjs/entry.js"],"names":["Node","linkedList","filterPoints","earcutLinked","isEar","isEarHashed","cureLocalIntersections","splitEarcut","eliminateHoles","compareX","eliminateHole","findHoleBridge","sectorContainsSector","indexCurve","sortLinked","zOrder","getLeftmost","pointInTriangle","isValidDiagonal","area","equals","intersects","onSegment","sign","intersectsPolygon","locallyInside","middleInside","splitPolygon","insertNode","removeNode","signedArea","exports","i","x","y","this","prev","next","z","prevZ","nextZ","steiner","data","start","end","dim","clockwise","last","p","again","ear","triangles","minX","minY","invSize","pass","stop","push","a","b","c","minTX","minTY","maxTX","maxTY","minZ","maxZ","n","holeIndices","outerNode","list","queue","len","length","sort","hole","bridge","bridgeReverse","filteredBridge","m","hx","hy","qx","tan","mx","my","tanMin","Infinity","Math","abs","q","e","tail","numMerges","pSize","qSize","inSize","leftmost","ax","ay","bx","by","cx","cy","px","py","r","p1","p2","q1","q2","o1","o2","o3","o4","max","min","num","inside","a2","b2","an","bp","sum","j","maxX","maxY","hasHoles","outerLen","__webpack_module_cache__","globalThis","earcut","__webpack_require__","moduleId","module","__webpack_modules__"],"mappings":"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","file":"earcut.min.js","sourcesContent":["\"use strict\";\n// Original algorithm by https://github.com/mapbox/earcut\n//\n// Ported to TypeScript by Ikaros Kappler\n// @date 2020-12-08\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.earcut = void 0;\n;\nexports.earcut = (function () {\n    /**\n     * Nodes of a linked list, each node representing a vertex of a ring (a polygon).\n     */\n    var Node = /** @class */ (function () {\n        function Node(i, x, y) {\n            // vertex index in coordinates array\n            this.i = i;\n            // vertex coordinates\n            this.x = x;\n            this.y = y;\n            // previous and next vertex nodes in a polygon ring\n            this.prev = null;\n            this.next = null;\n            // z-order curve value\n            this.z = null;\n            // previous and next nodes in z-order\n            this.prevZ = null;\n            this.nextZ = null;\n            // indicates whether this is a steiner point\n            this.steiner = false;\n        }\n        return Node;\n    }());\n    ;\n    var earcut = function (data, holeIndices, dim) {\n        if (dim === void 0) { dim = 2; }\n        dim = dim || 2;\n        var hasHoles = holeIndices && holeIndices.length > 0;\n        var outerLen = hasHoles ? holeIndices[0] * dim : data.length;\n        var outerNode = linkedList(data, 0, outerLen, dim, true);\n        var triangles = []; // [t0a, t0b, t0c,  t1a, t2a, t3a, ... ]\n        if (!outerNode || outerNode.next === outerNode.prev)\n            return triangles;\n        var minX;\n        var minY;\n        var maxX;\n        var maxY;\n        var x;\n        var y;\n        var invSize;\n        if (hasHoles) {\n            outerNode = eliminateHoles(data, holeIndices, outerNode, dim);\n        }\n        // if the shape is not too simple, we'll use z-order curve hash later; calculate polygon bbox\n        // TODO: use Bounds class for calculation?\n        if (data.length > 80 * dim) {\n            minX = maxX = data[0];\n            minY = maxY = data[1];\n            for (var i = dim; i < outerLen; i += dim) {\n                x = data[i];\n                y = data[i + 1];\n                if (x < minX)\n                    minX = x;\n                if (y < minY)\n                    minY = y;\n                if (x > maxX)\n                    maxX = x;\n                if (y > maxY)\n                    maxY = y;\n            }\n            // minX, minY and invSize are later used to transform coords into integers for z-order calculation\n            invSize = Math.max(maxX - minX, maxY - minY);\n            invSize = invSize !== 0 ? 1 / invSize : 0;\n        }\n        earcutLinked(outerNode, triangles, dim, minX, minY, invSize);\n        return triangles;\n    };\n    // create a circular doubly linked list from polygon points in the specified winding order\n    var linkedList = function (data, start, end, dim, clockwise) {\n        var i;\n        var last;\n        if (clockwise === (signedArea(data, start, end, dim) > 0)) {\n            for (i = start; i < end; i += dim) {\n                last = insertNode(i, data[i], data[i + 1], last);\n            }\n        }\n        else {\n            for (i = end - dim; i >= start; i -= dim) {\n                last = insertNode(i, data[i], data[i + 1], last);\n            }\n        }\n        if (last && equals(last, last.next)) {\n            removeNode(last);\n            last = last.next;\n        }\n        return last;\n    };\n    // eliminate colinear or duplicate points\n    var filterPoints = function (start, end) {\n        if (!start)\n            return start;\n        if (!end)\n            end = start;\n        // Remember starting node\n        var p = start;\n        var again = false;\n        do {\n            // TODO: move into 'else' branch?\n            again = false;\n            if (!p.steiner && (equals(p, p.next) || area(p.prev, p, p.next) === 0)) {\n                removeNode(p);\n                p = end = p.prev;\n                if (p === p.next)\n                    break;\n                again = true;\n            }\n            else {\n                p = p.next;\n            }\n        } while (again || p !== end);\n        return end;\n    };\n    // main ear slicing loop which triangulates a polygon (given as a linked list)\n    var earcutLinked = function (ear, triangles, dim, minX, minY, invSize, pass) {\n        if (!ear)\n            return;\n        // interlink polygon nodes in z-order\n        if (!pass && invSize) {\n            indexCurve(ear, minX, minY, invSize);\n        }\n        var stop = ear;\n        var prev;\n        var next;\n        // iterate through ears, slicing them one by one\n        while (ear.prev !== ear.next) {\n            prev = ear.prev;\n            next = ear.next;\n            if (invSize ? isEarHashed(ear, minX, minY, invSize) : isEar(ear)) {\n                // cut off the triangle\n                triangles.push(prev.i / dim);\n                triangles.push(ear.i / dim);\n                triangles.push(next.i / dim);\n                removeNode(ear);\n                // skipping the next vertex leads to less sliver triangles\n                ear = next.next;\n                stop = next.next;\n                continue;\n            }\n            ear = next;\n            // if we looped through the whole remaining polygon and can't find any more ears\n            if (ear === stop) {\n                // try filtering points and slicing again\n                if (!pass) {\n                    earcutLinked(filterPoints(ear), triangles, dim, minX, minY, invSize, 1);\n                    // if this didn't work, try curing all small self-intersections locally\n                }\n                else if (pass === 1) {\n                    ear = cureLocalIntersections(filterPoints(ear), triangles, dim);\n                    earcutLinked(ear, triangles, dim, minX, minY, invSize, 2);\n                    // as a last resort, try splitting the remaining polygon into two\n                }\n                else if (pass === 2) {\n                    splitEarcut(ear, triangles, dim, minX, minY, invSize);\n                }\n                break;\n            }\n        }\n    }; // END earcutLinked\n    // check whether a polygon node forms a valid ear with adjacent nodes\n    var isEar = function (ear) {\n        var a = ear.prev;\n        var b = ear;\n        var c = ear.next;\n        if (area(a, b, c) >= 0)\n            return false; // reflex, can't be an ear\n        // now make sure we don't have other points inside the potential ear\n        var p = ear.next.next;\n        while (p !== ear.prev) {\n            if (pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, p.x, p.y) &&\n                area(p.prev, p, p.next) >= 0)\n                return false;\n            p = p.next;\n        }\n        return true;\n    };\n    var isEarHashed = function (ear, minX, minY, invSize) {\n        var a = ear.prev;\n        var b = ear;\n        var c = ear.next;\n        if (area(a, b, c) >= 0)\n            return false; // reflex, can't be an ear\n        // triangle bbox; min & max are calculated like this for speed\n        // TODO: use Triangle.bounds\n        var minTX = a.x < b.x ? (a.x < c.x ? a.x : c.x) : (b.x < c.x ? b.x : c.x), minTY = a.y < b.y ? (a.y < c.y ? a.y : c.y) : (b.y < c.y ? b.y : c.y), maxTX = a.x > b.x ? (a.x > c.x ? a.x : c.x) : (b.x > c.x ? b.x : c.x), maxTY = a.y > b.y ? (a.y > c.y ? a.y : c.y) : (b.y > c.y ? b.y : c.y);\n        // z-order range for the current triangle bbox;\n        var minZ = zOrder(minTX, minTY, minX, minY, invSize), maxZ = zOrder(maxTX, maxTY, minX, minY, invSize);\n        var p = ear.prevZ, n = ear.nextZ;\n        // look for points inside the triangle in both directions\n        while (p && p.z >= minZ && n && n.z <= maxZ) {\n            if (p !== ear.prev && p !== ear.next &&\n                // TODO: use Triangle.utils.pointIsInTriangle\n                pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, p.x, p.y) &&\n                area(p.prev, p, p.next) >= 0)\n                return false;\n            p = p.prevZ;\n            if (n !== ear.prev && n !== ear.next &&\n                // TODO: use Triangle.utils.pointIsInTriangle\n                pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, n.x, n.y) &&\n                area(n.prev, n, n.next) >= 0)\n                return false;\n            n = n.nextZ;\n        }\n        // look for remaining points in decreasing z-order\n        while (p && p.z >= minZ) {\n            if (p !== ear.prev && p !== ear.next &&\n                // TODO: use Triangle.utils.pointIsInTriangle\n                pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, p.x, p.y) &&\n                area(p.prev, p, p.next) >= 0)\n                return false;\n            p = p.prevZ;\n        }\n        // look for remaining points in increasing z-order\n        while (n && n.z <= maxZ) {\n            if (n !== ear.prev && n !== ear.next &&\n                // TODO: use Triangle.utils.pointIsInTriangle\n                pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, n.x, n.y) &&\n                area(n.prev, n, n.next) >= 0)\n                return false;\n            n = n.nextZ;\n        }\n        return true;\n    };\n    // go through all polygon nodes and cure small local self-intersections\n    var cureLocalIntersections = function (start, triangles, dim) {\n        var p = start;\n        do {\n            var a = p.prev;\n            var b = p.next.next;\n            if (!equals(a, b) && intersects(a, p, p.next, b) && locallyInside(a, b) && locallyInside(b, a)) {\n                triangles.push(a.i / dim);\n                triangles.push(p.i / dim);\n                triangles.push(b.i / dim);\n                // remove two nodes involved\n                removeNode(p);\n                removeNode(p.next);\n                p = start = b;\n            }\n            p = p.next;\n        } while (p !== start);\n        return filterPoints(p);\n    };\n    // try splitting polygon into two and triangulate them independently\n    var splitEarcut = function (start, triangles, dim, minX, minY, invSize) {\n        // look for a valid diagonal that divides the polygon into two\n        var a = start;\n        do {\n            var b = a.next.next;\n            while (b !== a.prev) {\n                if (a.i !== b.i && isValidDiagonal(a, b)) {\n                    // split the polygon in two by the diagonal\n                    var c = splitPolygon(a, b);\n                    // filter colinear points around the cuts\n                    a = filterPoints(a, a.next);\n                    c = filterPoints(c, c.next);\n                    // run earcut on each half\n                    earcutLinked(a, triangles, dim, minX, minY, invSize);\n                    earcutLinked(c, triangles, dim, minX, minY, invSize);\n                    return;\n                }\n                b = b.next;\n            }\n            a = a.next;\n        } while (a !== start);\n    };\n    // link every hole into the outer loop, producing a single-ring polygon without holes\n    var eliminateHoles = function (data, holeIndices, outerNode, dim) {\n        var queue = [];\n        var i;\n        var len = holeIndices.length;\n        var start;\n        var end;\n        var list;\n        for (i = 0; i < len; i++) {\n            start = holeIndices[i] * dim;\n            end = i < len - 1 ? holeIndices[i + 1] * dim : data.length;\n            list = linkedList(data, start, end, dim, false);\n            if (list === list.next)\n                list.steiner = true;\n            queue.push(getLeftmost(list));\n        }\n        queue.sort(compareX);\n        // process holes from left to right\n        for (i = 0; i < queue.length; i++) {\n            eliminateHole(queue[i], outerNode);\n            outerNode = filterPoints(outerNode, outerNode.next);\n        }\n        return outerNode;\n    };\n    var compareX = function (a, b) {\n        return a.x - b.x;\n    };\n    // find a bridge between vertices that connects hole with an outer ring and and link it\n    var eliminateHole = function (hole, outerNode) {\n        var bridge = findHoleBridge(hole, outerNode);\n        if (!bridge) {\n            return outerNode;\n        }\n        var bridgeReverse = splitPolygon(bridge, hole);\n        // filter collinear points around the cuts\n        var filteredBridge = filterPoints(bridge, bridge.next);\n        filterPoints(bridgeReverse, bridgeReverse.next);\n        // Check if input node was removed by the filtering\n        return outerNode === bridge ? filteredBridge : outerNode;\n        // }\n    };\n    // David Eberly's algorithm for finding a bridge between hole and outer polygon\n    var findHoleBridge = function (hole, outerNode) {\n        var p = outerNode;\n        var hx = hole.x;\n        var hy = hole.y;\n        var qx = -Infinity;\n        var m;\n        // find a segment intersected by a ray from the hole's leftmost point to the left;\n        // segment's endpoint with lesser x will be potential connection point\n        do {\n            if (hy <= p.y && hy >= p.next.y && p.next.y !== p.y) {\n                var x = p.x + (hy - p.y) * (p.next.x - p.x) / (p.next.y - p.y);\n                if (x <= hx && x > qx) {\n                    qx = x;\n                    if (x === hx) {\n                        if (hy === p.y)\n                            return p;\n                        if (hy === p.next.y)\n                            return p.next;\n                    }\n                    m = p.x < p.next.x ? p : p.next;\n                }\n            }\n            p = p.next;\n        } while (p !== outerNode);\n        if (!m) {\n            return null;\n        }\n        if (hx === qx) {\n            return m; // hole touches outer segment; pick leftmost endpoint\n        }\n        // look for points inside the triangle of hole point, segment intersection and endpoint;\n        // if there are no points found, we have a valid connection;\n        // otherwise choose the point of the minimum angle with the ray as connection point\n        var stop = m;\n        var mx = m.x;\n        var my = m.y;\n        var tanMin = Infinity;\n        var tan;\n        p = m;\n        do {\n            if (hx >= p.x && p.x >= mx && hx !== p.x &&\n                pointInTriangle(hy < my ? hx : qx, hy, mx, my, hy < my ? qx : hx, hy, p.x, p.y)) {\n                tan = Math.abs(hy - p.y) / (hx - p.x); // tangential\n                if (locallyInside(p, hole) &&\n                    (tan < tanMin || (tan === tanMin && (p.x > m.x || (p.x === m.x && sectorContainsSector(m, p)))))) {\n                    m = p;\n                    tanMin = tan;\n                }\n            }\n            p = p.next;\n        } while (p !== stop);\n        return m;\n    };\n    // whether sector in vertex m contains sector in vertex p in the same coordinates\n    var sectorContainsSector = function (m, p) {\n        return area(m.prev, m, p.prev) < 0 && area(p.next, m, m.next) < 0;\n    };\n    // interlink polygon nodes in z-order\n    var indexCurve = function (start, minX, minY, invSize) {\n        var p = start;\n        do {\n            if (p.z === null)\n                p.z = zOrder(p.x, p.y, minX, minY, invSize);\n            p.prevZ = p.prev;\n            p.nextZ = p.next;\n            p = p.next;\n        } while (p !== start);\n        p.prevZ.nextZ = null;\n        p.prevZ = null;\n        sortLinked(p);\n    };\n    // Simon Tatham's linked list merge sort algorithm\n    // http://www.chiark.greenend.org.uk/~sgtatham/algorithms/listsort.html\n    var sortLinked = function (list) {\n        var i;\n        var p;\n        var q;\n        var e;\n        var tail;\n        var numMerges;\n        var pSize;\n        var qSize;\n        var inSize = 1;\n        do {\n            p = list;\n            list = null;\n            tail = null;\n            numMerges = 0;\n            while (p) {\n                numMerges++;\n                q = p;\n                pSize = 0;\n                for (i = 0; i < inSize; i++) {\n                    pSize++;\n                    q = q.nextZ;\n                    if (!q)\n                        break;\n                }\n                qSize = inSize;\n                while (pSize > 0 || (qSize > 0 && q)) {\n                    if (pSize !== 0 && (qSize === 0 || !q || p.z <= q.z)) {\n                        e = p;\n                        p = p.nextZ;\n                        pSize--;\n                    }\n                    else {\n                        e = q;\n                        q = q.nextZ;\n                        qSize--;\n                    }\n                    if (tail)\n                        tail.nextZ = e;\n                    else\n                        list = e;\n                    e.prevZ = tail;\n                    tail = e;\n                }\n                p = q;\n            }\n            tail.nextZ = null;\n            inSize *= 2;\n        } while (numMerges > 1);\n        return list;\n    };\n    // z-order of a point given coords and inverse of the longer side of data bbox\n    var zOrder = function (x, y, minX, minY, invSize) {\n        // coords are transformed into non-negative 15-bit integer range\n        x = 32767 * (x - minX) * invSize;\n        y = 32767 * (y - minY) * invSize;\n        x = (x | (x << 8)) & 0x00FF00FF;\n        x = (x | (x << 4)) & 0x0F0F0F0F;\n        x = (x | (x << 2)) & 0x33333333;\n        x = (x | (x << 1)) & 0x55555555;\n        y = (y | (y << 8)) & 0x00FF00FF;\n        y = (y | (y << 4)) & 0x0F0F0F0F;\n        y = (y | (y << 2)) & 0x33333333;\n        y = (y | (y << 1)) & 0x55555555;\n        return x | (y << 1);\n    };\n    // find the leftmost node of a polygon ring\n    var getLeftmost = function (start) {\n        var p = start;\n        var leftmost = start;\n        do {\n            if (p.x < leftmost.x || (p.x === leftmost.x && p.y < leftmost.y)) {\n                leftmost = p;\n            }\n            p = p.next;\n        } while (p !== start);\n        return leftmost;\n    };\n    // check if a point lies within a convex triangle\n    // TODO: use Triangle.containsPoint\n    var pointInTriangle = function (ax, ay, bx, by, cx, cy, px, py) {\n        return (cx - px) * (ay - py) - (ax - px) * (cy - py) >= 0 &&\n            (ax - px) * (by - py) - (bx - px) * (ay - py) >= 0 &&\n            (bx - px) * (cy - py) - (cx - px) * (by - py) >= 0;\n    };\n    // check if a diagonal between two polygon nodes is valid (lies in polygon interior)\n    var isValidDiagonal = function (a, b) {\n        return a.next.i !== b.i && a.prev.i !== b.i && !intersectsPolygon(a, b) && // dones't intersect other edges\n            (locallyInside(a, b) && locallyInside(b, a) && middleInside(a, b) && // locally visible\n                (area(a.prev, a, b.prev) != 0 || area(a, b.prev, b)) != 0 || // does not create opposite-facing sectors\n                equals(a, b) && area(a.prev, a, a.next) > 0 && area(b.prev, b, b.next) > 0); // special zero-length case\n    };\n    // signed area of a triangle\n    var area = function (p, q, r) {\n        return (q.y - p.y) * (r.x - q.x) - (q.x - p.x) * (r.y - q.y);\n    };\n    // check if two points are equal\n    // TODO: as member function of vertex\n    var equals = function (p1, p2) {\n        return p1.x === p2.x && p1.y === p2.y;\n    };\n    // check if two segments intersect\n    // TODO: use Line.intersects\n    var intersects = function (p1, q1, p2, q2) {\n        var o1 = sign(area(p1, q1, p2));\n        var o2 = sign(area(p1, q1, q2));\n        var o3 = sign(area(p2, q2, p1));\n        var o4 = sign(area(p2, q2, q1));\n        if (o1 !== o2 && o3 !== o4)\n            return true; // general case\n        if (o1 === 0 && onSegment(p1, p2, q1))\n            return true; // p1, q1 and p2 are collinear and p2 lies on p1q1\n        if (o2 === 0 && onSegment(p1, q2, q1))\n            return true; // p1, q1 and q2 are collinear and q2 lies on p1q1\n        if (o3 === 0 && onSegment(p2, p1, q2))\n            return true; // p2, q2 and p1 are collinear and p1 lies on p2q2\n        if (o4 === 0 && onSegment(p2, q1, q2))\n            return true; // p2, q2 and q1 are collinear and q1 lies on p2q2\n        return false;\n    };\n    // for collinear points p, q, r, check if point q lies on segment pr\n    var onSegment = function (p, q, r) {\n        return q.x <= Math.max(p.x, r.x) && q.x >= Math.min(p.x, r.x) && q.y <= Math.max(p.y, r.y) && q.y >= Math.min(p.y, r.y);\n    };\n    var sign = function (num) {\n        return num > 0 ? 1 : num < 0 ? -1 : 0;\n    };\n    // check if a polygon diagonal intersects any polygon segments\n    var intersectsPolygon = function (a, b) {\n        var p = a;\n        do {\n            if (p.i !== a.i && p.next.i !== a.i && p.i !== b.i && p.next.i !== b.i && intersects(p, p.next, a, b)) {\n                return true;\n            }\n            p = p.next;\n        } while (p !== a);\n        return false;\n    };\n    // check if a polygon diagonal is locally inside the polygon\n    var locallyInside = function (a, b) {\n        return area(a.prev, a, a.next) < 0 ?\n            area(a, b, a.next) >= 0 && area(a, a.prev, b) >= 0 :\n            area(a, b, a.prev) < 0 || area(a, a.next, b) < 0;\n    };\n    // check if the middle point of a polygon diagonal is inside the polygon\n    var middleInside = function (a, b) {\n        var p = a;\n        var inside = false;\n        var px = (a.x + b.x) / 2;\n        var py = (a.y + b.y) / 2;\n        // TODO: call Polygon.contains here?\n        do {\n            if (((p.y > py) !== (p.next.y > py)) && p.next.y !== p.y &&\n                (px < (p.next.x - p.x) * (py - p.y) / (p.next.y - p.y) + p.x))\n                inside = !inside;\n            p = p.next;\n        } while (p !== a);\n        return inside;\n    };\n    // link two polygon vertices with a bridge; if the vertices belong to the same ring, it splits polygon into two;\n    // if one belongs to the outer ring and another to a hole, it merges it into a single ring\n    var splitPolygon = function (a, b) {\n        var a2 = new Node(a.i, a.x, a.y);\n        var b2 = new Node(b.i, b.x, b.y);\n        var an = a.next;\n        var bp = b.prev;\n        a.next = b;\n        b.prev = a;\n        a2.next = an;\n        an.prev = a2;\n        b2.next = a2;\n        a2.prev = b2;\n        bp.next = b2;\n        b2.prev = bp;\n        return b2;\n    };\n    // create a node and optionally link it with previous one (in a circular doubly linked list)\n    var insertNode = function (i, x, y, last) {\n        var p = new Node(i, x, y);\n        if (!last) {\n            p.prev = p;\n            p.next = p;\n        }\n        else {\n            p.next = last.next;\n            p.prev = last;\n            last.next.prev = p;\n            last.next = p;\n        }\n        return p;\n    };\n    var removeNode = function (p) {\n        p.next.prev = p.prev;\n        p.prev.next = p.next;\n        if (p.prevZ)\n            p.prevZ.nextZ = p.nextZ;\n        if (p.nextZ)\n            p.nextZ.prevZ = p.prevZ;\n    };\n    var signedArea = function (data, start, end, dim) {\n        var sum = 0;\n        for (var i = start, j = end - dim; i < end; i += dim) {\n            sum += (data[j] - data[i]) * (data[i + 1] + data[j + 1]);\n            j = i;\n        }\n        return sum;\n    };\n    return earcut;\n})();\n//# sourceMappingURL=earcut.js.map","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tif(__webpack_module_cache__[moduleId]) {\n\t\treturn __webpack_module_cache__[moduleId].exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","\"use strict\";\n/* Imports and exports for webpack */\n\n// Expose all triangulation functions to the global scope, as an object called `earcut`.\nglobalThis.earcut = require(\"./earcut.js\").earcut;\n"],"sourceRoot":""}