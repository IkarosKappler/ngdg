{"version":3,"sources":["webpack://greiner-hormann/./src/js/clip.js","webpack://greiner-hormann/./src/js/index.js","webpack://greiner-hormann/./src/js/intersection.js","webpack://greiner-hormann/./src/js/polygon.js","webpack://greiner-hormann/./src/js/vertex.js","webpack://greiner-hormann/webpack/bootstrap","webpack://greiner-hormann/./src/js/entry.js"],"names":["Object","defineProperty","exports","value","polygon_1","default","polygonA","polygonB","eA","eB","source","clip","diff","intersection","union","clip_1","Intersection","s1","s2","c1","c2","this","x","y","toSource","toClip","d","valid","prototype","vertex_1","intersection_1","Polygon","p","arrayVertices","first","vertices","_lastUnprocessed","_arrayVertices","Array","isArray","i","len","length","addVertex","vertex","next","prev","insertVertex","start","end","curr","equals","_distance","getNext","v","c","_isIntersection","getFirstIntersect","_firstIntersect","_visited","hasUnprocessed","getPoints","points","push","sourceForwards","clipForwards","sourceInClip","clipInSource","sourceVertex","clipVertex","isUnion","isIntersection","sourceIntersection","createIntersection","clipIntersection","_corresponding","isInside","_isEntry","list","current","clipped","visit","Vertex","arguments","distance","poly","b","oddNodes","__webpack_module_cache__","globalThis","greinerHormann","__webpack_require__","moduleId","module","__webpack_modules__"],"mappings":"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","file":"greiner-hormann.min.js","sourcesContent":["\"use strict\";\n/**\n * TypeScript port by Ikaros Kappler.\n *\n * Original file https://github.com/w8r/GreinerHormann/blob/master/src/clip.js\n *\n * @date 2020-11-30\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar polygon_1 = require(\"./polygon\");\n/**\n * Clip driver. Not that the type `Array<Array<number>>` in this case matches `IArrayVertex`.\n * @param  {Array.<Array.<Number>>} polygonA\n * @param  {Array.<Array.<Number>>} polygonB\n * @param  {Boolean}                sourceForwards\n * @param  {Boolean}                clipForwards\n * @return {Array.<Array.<Number>>}\n */\nexports.default = (function (polygonA, polygonB, eA, eB) {\n    var source = new polygon_1.default(polygonA);\n    var clip = new polygon_1.default(polygonB);\n    // We rely that, when Array Vertices are put in, then Array Vertices come out (not Object Vertices)\n    return source.clip(clip, eA, eB);\n});\n//# sourceMappingURL=clip.js.map","\"use strict\";\n/**\n * TypeScript port by Ikaros Kappler.\n *\n * Original file https://github.com/w8r/GreinerHormann/blob/master/src/clip.leaflet.js\n *\n * @date 2020-11-30\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.clip = exports.diff = exports.intersection = exports.union = void 0;\nvar clip_1 = require(\"./clip\");\n/**\n * @param  {Array.<Array.<Number>|Array.<Object>} polygonA\n * @param  {Array.<Array.<Number>|Array.<Object>} polygonB\n * @return {Array.<Array.<Number>>|Array.<Array.<Object>|Null}\n */\nvar union = function (polygonA, polygonB) {\n    return clip_1.default(polygonA, polygonB, false, false);\n};\nexports.union = union;\n/**\n * @param  {Array.<Array.<Number>|Array.<Object>} polygonA\n * @param  {Array.<Array.<Number>|Array.<Object>} polygonB\n * @return {Array.<Array.<Number>>|Array.<Array.<Object>>|Null}\n */\nvar intersection = function (polygonA, polygonB) {\n    return clip_1.default(polygonA, polygonB, true, true);\n};\nexports.intersection = intersection;\n/**\n * @param  {Array.<Array.<Number>|Array.<Object>} polygonA\n * @param  {Array.<Array.<Number>|Array.<Object>} polygonB\n * @return {Array.<Array.<Number>>|Array.<Array.<Object>>|Null}\n */\nvar diff = function (polygonA, polygonB) {\n    return clip_1.default(polygonA, polygonB, false, true);\n};\nexports.diff = diff;\nexports.clip = clip_1.default;\n//# sourceMappingURL=index.js.map","\"use strict\";\n/**\n * TypeScript port by Ikaros Kappler.\n *\n * Original file https://github.com/w8r/GreinerHormann/blob/master/src/intersection.js\n *\n * @date 2020-11-30\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/**\n * Defines an edge intersection.\n */\nvar Intersection = /** @class */ (function () {\n    /**\n     * @constructor\n     * @param {Vertex} s1 - Source edge vertex 1.\n     * @param {Vertex} s2 - Source edge vertex 2.\n     * @param {Vertex} c1 - Clip edge vertex 1.\n     * @param {Vertex} c2 - Clip edge vertex 2.\n     */\n    function Intersection(s1, s2, c1, c2) {\n        this.x = 0.0;\n        this.y = 0.0;\n        this.toSource = 0.0;\n        this.toClip = 0.0;\n        var d = (c2.y - c1.y) * (s2.x - s1.x) - (c2.x - c1.x) * (s2.y - s1.y);\n        if (d === 0)\n            return;\n        this.toSource = ((c2.x - c1.x) * (s1.y - c1.y) - (c2.y - c1.y) * (s1.x - c1.x)) / d;\n        this.toClip = ((s2.x - s1.x) * (s1.y - c1.y) - (s2.y - s1.y) * (s1.x - c1.x)) / d;\n        if (this.valid()) {\n            this.x = s1.x + this.toSource * (s2.x - s1.x);\n            this.y = s1.y + this.toSource * (s2.y - s1.y);\n        }\n    }\n    /**\n     * @return {Boolean}\n     */\n    Intersection.prototype.valid = function () {\n        return (0 < this.toSource && this.toSource < 1) && (0 < this.toClip && this.toClip < 1);\n    };\n    return Intersection;\n}());\nexports.default = Intersection;\n//# sourceMappingURL=intersection.js.map","\"use strict\";\n/**\n * TypeScript port by Ikaros Kappler.\n *\n * Original file https://github.com/w8r/GreinerHormann/blob/master/src/polygon.js\n *\n * @date 2020-11-30\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar vertex_1 = require(\"./vertex\");\nvar intersection_1 = require(\"./intersection\");\n/**\n * Polygon representation\n */\nvar Polygon = /** @class */ (function () {\n    /**\n     * Construct a new polygon.\n     *\n     * @constructor\n     * @param {Array.<Array.<Number>>} p\n     * @param {Boolean=}               arrayVertices\n     */\n    function Polygon(p, arrayVertices) {\n        this.first = null;\n        this.vertices = 0;\n        this._lastUnprocessed = null;\n        this._arrayVertices = (typeof arrayVertices === \"undefined\") ?\n            Array.isArray(p[0]) :\n            arrayVertices;\n        for (var i = 0, len = p.length; i < len; i++) {\n            this.addVertex(new vertex_1.default(p[i]));\n        }\n    }\n    ; // END constrcutor\n    /**\n     * Add a vertex object to the polygon\n     * (vertex is added at the 'end' of the list')\n     *\n     * @param vertex\n     */\n    Polygon.prototype.addVertex = function (vertex) {\n        if (this.first === null) {\n            this.first = vertex;\n            this.first.next = vertex;\n            this.first.prev = vertex;\n        }\n        else {\n            var next = this.first;\n            var prev = next.prev;\n            next.prev = vertex;\n            vertex.next = next;\n            vertex.prev = prev;\n            prev.next = vertex;\n        }\n        this.vertices++;\n    };\n    /**\n     * Inserts a vertex inbetween start and end\n     *\n     * @param {Vertex} vertex\n     * @param {Vertex} start\n     * @param {Vertex} end\n     */\n    Polygon.prototype.insertVertex = function (vertex, start, end) {\n        var prev, curr = start;\n        while (!curr.equals(end) && curr._distance < vertex._distance) {\n            curr = curr.next;\n        }\n        vertex.next = curr;\n        prev = curr.prev;\n        vertex.prev = prev;\n        prev.next = vertex;\n        curr.prev = vertex;\n        this.vertices++;\n    };\n    /**\n     * Get next non-intersection point\n     * @param  {Vertex} v\n     * @return {Vertex}\n     */\n    Polygon.prototype.getNext = function (v) {\n        var c = v;\n        while (c._isIntersection)\n            c = c.next;\n        return c;\n    };\n    /**\n     * Unvisited intersection\n     * @return {Vertex}\n     */\n    Polygon.prototype.getFirstIntersect = function () {\n        var v = this._firstIntersect || this.first;\n        do {\n            if (v._isIntersection && !v._visited)\n                break;\n            v = v.next;\n        } while (!v.equals(this.first));\n        this._firstIntersect = v;\n        return v;\n    };\n    /**\n     * Does the polygon have unvisited vertices\n     * @return {Boolean} [description]\n     */\n    Polygon.prototype.hasUnprocessed = function () {\n        var v = this._lastUnprocessed || this.first;\n        do {\n            if (v._isIntersection && !v._visited) {\n                this._lastUnprocessed = v;\n                return true;\n            }\n            v = v.next;\n        } while (!v.equals(this.first));\n        this._lastUnprocessed = null;\n        return false;\n    };\n    /**\n     * The output depends on what you put in, arrays or objects\n     * @return {Array.<Array<Number>|Array.<Object>}\n     */\n    // TODO: what type?\n    Polygon.prototype.getPoints = function () {\n        var points = [];\n        var v = this.first;\n        if (this._arrayVertices) {\n            do {\n                points.push([v.x, v.y]);\n                v = v.next;\n            } while (v !== this.first);\n        }\n        else {\n            do {\n                points.push({\n                    x: v.x,\n                    y: v.y\n                });\n                v = v.next;\n            } while (v !== this.first);\n        }\n        return points;\n    };\n    /**\n     * Clip polygon against another one.\n     * Result depends on algorithm direction:\n     *\n     * Intersection: forwards forwards\n     * Union:        backwars backwards\n     * Diff:         backwards forwards\n     *\n     * @param {Polygon} clip\n     * @param {Boolean} sourceForwards\n     * @param {Boolean} clipForwards\n     */\n    Polygon.prototype.clip = function (clip, sourceForwards, clipForwards) {\n        var sourceVertex = this.first;\n        var clipVertex = clip.first;\n        var sourceInClip;\n        var clipInSource;\n        var isUnion = !sourceForwards && !clipForwards;\n        var isIntersection = sourceForwards && clipForwards;\n        var isDiff = !isUnion && !isIntersection;\n        // calculate and mark intersections\n        do {\n            if (!sourceVertex._isIntersection) {\n                do {\n                    if (!clipVertex._isIntersection) {\n                        var i = new intersection_1.default(sourceVertex, this.getNext(sourceVertex.next), clipVertex, clip.getNext(clipVertex.next));\n                        if (i.valid()) {\n                            var sourceIntersection = vertex_1.default.createIntersection(i.x, i.y, i.toSource);\n                            var clipIntersection = vertex_1.default.createIntersection(i.x, i.y, i.toClip);\n                            sourceIntersection._corresponding = clipIntersection;\n                            clipIntersection._corresponding = sourceIntersection;\n                            this.insertVertex(sourceIntersection, sourceVertex, this.getNext(sourceVertex.next));\n                            clip.insertVertex(clipIntersection, clipVertex, clip.getNext(clipVertex.next));\n                        }\n                    }\n                    clipVertex = clipVertex.next;\n                } while (!clipVertex.equals(clip.first));\n            }\n            sourceVertex = sourceVertex.next;\n        } while (!sourceVertex.equals(this.first));\n        // phase two - identify entry/exit points\n        sourceVertex = this.first;\n        clipVertex = clip.first;\n        sourceInClip = sourceVertex.isInside(clip);\n        clipInSource = clipVertex.isInside(this);\n        // Hint: XOR does not really exists on boolean values and is not type safe in TypeScript\n        sourceForwards = (sourceForwards && !sourceInClip) || (!sourceForwards && sourceInClip);\n        clipForwards = (clipForwards && !clipInSource) || (!clipForwards && clipInSource);\n        do {\n            if (sourceVertex._isIntersection) {\n                sourceVertex._isEntry = sourceForwards;\n                sourceForwards = !sourceForwards;\n            }\n            sourceVertex = sourceVertex.next;\n        } while (!sourceVertex.equals(this.first));\n        do {\n            if (clipVertex._isIntersection) {\n                clipVertex._isEntry = clipForwards;\n                clipForwards = !clipForwards;\n            }\n            clipVertex = clipVertex.next;\n        } while (!clipVertex.equals(clip.first));\n        // phase three - construct a list of clipped polygons\n        var list = [];\n        while (this.hasUnprocessed()) {\n            var current = this.getFirstIntersect();\n            // keep format\n            var clipped = new Polygon([], this._arrayVertices);\n            clipped.addVertex(new vertex_1.default(current.x, current.y));\n            do {\n                current.visit();\n                if (current._isEntry) {\n                    do {\n                        current = current.next;\n                        clipped.addVertex(new vertex_1.default(current.x, current.y));\n                    } while (!current._isIntersection);\n                }\n                else {\n                    do {\n                        current = current.prev;\n                        clipped.addVertex(new vertex_1.default(current.x, current.y));\n                    } while (!current._isIntersection);\n                }\n                current = current._corresponding;\n            } while (!current._visited);\n            list.push(clipped.getPoints());\n        }\n        if (list.length === 0) {\n            if (isUnion) {\n                if (sourceInClip)\n                    list.push(clip.getPoints());\n                else if (clipInSource)\n                    list.push(this.getPoints());\n                else\n                    list.push(this.getPoints(), clip.getPoints());\n            }\n            else if (isIntersection) { // intersection\n                if (sourceInClip)\n                    list.push(this.getPoints());\n                else if (clipInSource)\n                    list.push(clip.getPoints());\n            }\n            else { // diff\n                if (sourceInClip)\n                    list.push(clip.getPoints(), this.getPoints());\n                else if (clipInSource)\n                    list.push(this.getPoints(), clip.getPoints());\n                else\n                    list.push(this.getPoints());\n            }\n            if (list.length === 0)\n                list = null;\n        }\n        return list;\n    };\n    return Polygon;\n}());\nexports.default = Polygon;\n//# sourceMappingURL=polygon.js.map","\"use strict\";\n/**\n * TypeScript port by Ikaros Kappler.\n *\n * Original file https://github.com/w8r/GreinerHormann/blob/master/src/vertex.js\n *\n * @date 2020-11-30\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/**\n * Vertex representation.\n */\nvar Vertex = /** @class */ (function () {\n    /**\n     * Construct a new vertex.\n     *\n     * @constructor\n     * @param {Number|Array.<Number>} x\n     * @param {Number=}               y\n     */\n    function Vertex(x, y) {\n        var numX;\n        var numY;\n        if (arguments.length === 1) {\n            // Coords\n            if (Array.isArray(x)) {\n                this.y = x[1];\n                this.x = x[0];\n            }\n            else if (typeof x !== \"number\" && typeof x.x === \"number\" && typeof x.y === \"number\") {\n                this.y = x.y;\n                this.x = x.x;\n            }\n            else {\n                // Not a valid case: only one numeric parameter. Throw exception?\n            }\n        }\n        else if (typeof x === \"number\" && typeof y === \"number\") {\n            this.x = x;\n            this.y = y;\n        }\n        else {\n            throw \"Illegal vertex constrctor call: (\" + typeof x + \", \" + typeof y + \").\";\n        }\n        this.next = null;\n        this.prev = null;\n        this._corresponding = null;\n        this._distance = 0.0;\n        this._isEntry = true;\n        this._isIntersection = false;\n        this._visited = false;\n    }\n    ; // END constructor\n    /**\n     * Creates intersection vertex\n     * @param  {Number} x\n     * @param  {Number} y\n     * @param  {Number} distance\n     * @return {Vertex}\n     */\n    Vertex.createIntersection = function (x, y, distance) {\n        var vertex = new Vertex(x, y);\n        vertex._distance = distance;\n        vertex._isIntersection = true;\n        vertex._isEntry = false;\n        return vertex;\n    };\n    ;\n    /**\n     * Mark as visited\n     */\n    Vertex.prototype.visit = function () {\n        this._visited = true;\n        if (this._corresponding !== null && !this._corresponding._visited) {\n            this._corresponding.visit();\n        }\n    };\n    ;\n    /**\n     * Convenience\n     * @param  {Vertex}  v\n     * @return {Boolean}\n     */\n    Vertex.prototype.equals = function (v) {\n        return this.x === v.x && this.y === v.y;\n    };\n    ;\n    /**\n     * Check if vertex is inside a polygon by odd-even rule:\n     * If the number of intersections of a ray out of the point and polygon\n     * segments is odd - the point is inside.\n     * @param {Polygon} poly\n     * @return {Boolean}\n     */\n    Vertex.prototype.isInside = function (poly) {\n        var oddNodes = false;\n        var b;\n        var vertex = poly.first;\n        var next = vertex.next;\n        var x = this.x;\n        var y = this.y;\n        do {\n            if ((vertex.y < y && next.y >= y ||\n                next.y < y && vertex.y >= y) &&\n                (vertex.x <= x || next.x <= x)) {\n                // Hint: XOR does not really exist on boolean.\n                b = (vertex.x + (y - vertex.y) /\n                    (next.y - vertex.y) * (next.x - vertex.x) < x);\n                oddNodes = (!oddNodes && b) || (oddNodes && !b);\n            }\n            vertex = vertex.next;\n            next = vertex.next || poly.first;\n        } while (!vertex.equals(poly.first));\n        return oddNodes;\n    };\n    ;\n    return Vertex;\n}()); // END class\nexports.default = Vertex;\n//# sourceMappingURL=vertex.js.map","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tif(__webpack_module_cache__[moduleId]) {\n\t\treturn __webpack_module_cache__[moduleId].exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","\"use strict\";\n/* Imports and exports for webpack */\n\n// Expose all clipping functions to the global scope, as an object called `greinerHormann`.\nglobalThis.greinerHormann = require(\"./index.js\");\n"],"sourceRoot":""}