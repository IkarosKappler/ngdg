{"version":3,"file":"three-geometry-hellfix-main.js","mappings":";;;;;;;;;;AAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA6C,EAAE,aAAa,EAAC;AAC7D,sBAAsB;AACtB,sBAAsB;AACtB,kCAAkC,2CAA2C;AAC7E,qCAAqC,8CAA8C;AACnF,8BAA8B,uCAAuC;AACrE,8BAA8B,uCAAuC;AACrE,+BAA+B,wCAAwC;AACvE,2BAA2B,oCAAoC;AAC/D,6BAA6B,sCAAsC;AACnE,qCAAqC,8CAA8C;AACnF,gCAAgC,kDAAkD;AAClF,wEAAwE,iFAAiF;AACzJ,4BAA4B,mCAAmC;AAC/D,iEAAiE;AACjE;AACA;;;;;;;;;;;ACxBa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA6C,EAAE,aAAa,EAAC;AAC7D,sBAAsB;AACtB,uBAAuB,mBAAO,CAAC,qDAAkB;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,kBAAkB;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,wBAAwB;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,wBAAwB;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,kBAAkB;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,wBAAwB;AACpD;AACA;AACA;AACA,4BAA4B,wBAAwB;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD,sBAAsB;AACtB;;;;;;;;;;;AC7La;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA6C,EAAE,aAAa,EAAC;AAC7D,aAAa;AACb,uBAAuB,mBAAO,CAAC,qDAAkB;AACjD;AACA;AACA,wCAAwC;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wGAAwG;AACxG;AACA,uEAAuE;AACvE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0DAA0D,QAAQ;AAClE;AACA;AACA,yDAAyD,QAAQ;AACjE;AACA;AACA;AACA;AACA;AACA,CAAC;AACD,aAAa;AACb;;;;;;;;;;;AChEa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA6C,EAAE,aAAa,EAAC;AAC7D,cAAc;AACd,uBAAuB,mBAAO,CAAC,qDAAkB;AACjD,uBAAuB,mBAAO,CAAC,qDAAkB;AACjD,cAAc,mBAAO,CAAC,mCAAS;AAC/B;AACA;AACA;AACA;AACA,eAAe,eAAe;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mDAAmD,QAAQ;AAC3D;AACA;AACA;AACA,gDAAgD,QAAQ;AACxD;AACA;AACA,4DAA4D,QAAQ;AACpE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,oBAAoB;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,mBAAmB;AAC/C;AACA;AACA;AACA,wDAAwD,QAAQ;AAChE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,iBAAiB;AACjD;AACA;AACA;AACA;AACA,gCAAgC,oBAAoB;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gDAAgD,QAAQ;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC;AACvC;AACA,mDAAmD,QAAQ;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oDAAoD,QAAQ;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oDAAoD,QAAQ;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA,mDAAmD,QAAQ;AAC3D;AACA;AACA,gDAAgD,QAAQ;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gDAAgD,QAAQ;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gDAAgD,QAAQ;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4DAA4D,QAAQ;AACpE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uDAAuD,QAAQ;AAC/D;AACA;AACA,2CAA2C;AAC3C;AACA;AACA;AACA;AACA,wDAAwD,QAAQ;AAChE;AACA,0CAA0C;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oDAAoD,QAAQ;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gDAAgD,QAAQ;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+CAA+C,QAAQ;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6CAA6C,QAAQ;AACrD;AACA;AACA;AACA,4CAA4C,QAAQ;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2DAA2D,QAAQ;AACnE;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0DAA0D,QAAQ;AAClE;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4DAA4D,QAAQ;AACpE;AACA;AACA;AACA;AACA,wDAAwD,QAAQ;AAChE;AACA,kDAAkD,QAAQ;AAC1D;AACA;AACA,qDAAqD;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0CAA0C;AAC1C,8BAA8B;AAC9B;AACA;AACA,mDAAmD,QAAQ;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gDAAgD,QAAQ;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,OAAO;AACnC;AACA;AACA;AACA;AACA;AACA;AACA,qDAAqD,QAAQ;AAC7D;AACA;AACA,4DAA4D,QAAQ;AACpE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2CAA2C,OAAO;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,YAAY;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,YAAY;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,0BAA0B;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,uBAAuB;AAC/C;AACA;AACA,mCAAmC;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+CAA+C;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+CAA+C;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C,QAAQ;AACtD;AACA;AACA;AACA;AACA,4CAA4C,QAAQ;AACpD;AACA;AACA;AACA;AACA,2CAA2C,QAAQ;AACnD;AACA;AACA;AACA,0DAA0D,QAAQ;AAClE;AACA;AACA;AACA;AACA,uDAAuD,QAAQ;AAC/D;AACA,iDAAiD,QAAQ;AACzD;AACA;AACA;AACA,qDAAqD;AACrD;AACA;AACA;AACA;AACA,kDAAkD,QAAQ;AAC1D,kCAAkC;AAClC;AACA;AACA;AACA;AACA,sEAAsE,QAAQ;AAC9E;AACA;AACA;AACA;AACA;AACA;AACA,qEAAqE,QAAQ;AAC7E;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kDAAkD,QAAQ;AAC1D;AACA;AACA;AACA;AACA,2EAA2E,QAAQ;AACnF;AACA;AACA,6CAA6C;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yEAAyE,QAAQ;AACjF;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iDAAiD,QAAQ;AACzD;AACA;AACA;AACA;AACA,iDAAiD,QAAQ;AACzD;AACA;AACA;AACA;AACA,mDAAmD,QAAQ;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qDAAqD,OAAO;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,kBAAkB;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD,cAAc;AACd;;;;;;;;;;;ACv9Ba;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,4BAA4B,GAAG,cAAc,GAAG,aAAa,GAAG,sBAAsB;AACtF,uBAAuB,mBAAO,CAAC,qDAAkB;AACjD,kDAAiD,EAAE,qCAAqC,2CAA2C,EAAC;AACpI,cAAc,mBAAO,CAAC,mCAAS;AAC/B,yCAAwC,EAAE,qCAAqC,yBAAyB,EAAC;AACzG,eAAe,mBAAO,CAAC,qCAAU;AACjC,0CAAyC,EAAE,qCAAqC,2BAA2B,EAAC;AAC5G,kBAAkB,mBAAO,CAAC,2CAAa;AACvC,wDAAuD,EAAE,qCAAqC,4CAA4C,EAAC;AAC3I;;;;;;;;;;;ACXa;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,4BAA4B;AAC5B,uBAAuB,mBAAO,CAAC,qDAAkB;AACjD,uBAAuB,mBAAO,CAAC,qDAAkB;AACjD,cAAc,mBAAO,CAAC,mCAAS;AAC/B,eAAe,mBAAO,CAAC,qCAAU;AACjC,4BAA4B;AAC5B;AACA;AACA;AACA;AACA;AACA;;;;;;UCbA;UACA;;UAEA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;;UAEA;UACA;;UAEA;UACA;UACA;;;;;;;;;ACtBA;;AAEA,mDAAmD,wEAAkC","sources":["webpack://three-geometry-hellfix/./src/cjs/DefaultFactory.js","webpack://three-geometry-hellfix/./src/cjs/DirectGeometry.js","webpack://three-geometry-hellfix/./src/cjs/Face3.js","webpack://three-geometry-hellfix/./src/cjs/Gmetry.js","webpack://three-geometry-hellfix/./src/cjs/index.js","webpack://three-geometry-hellfix/./src/cjs/mylibrary.js","webpack://three-geometry-hellfix/webpack/bootstrap","webpack://three-geometry-hellfix/./src/cjs/entry.js"],"sourcesContent":["\"use strict\";\n/**\n * The default factory to connect to your three library.\n *\n * @author  Ikaros Kappler\n * @date    2022-02-20\n * @version 1.0.0\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.DefaultFactory = void 0;\nexports.DefaultFactory = {\n    newVector2: function (x, y) { return new window[\"THREE\"].Vector2(x, y); },\n    newVector3: function (x, y, z) { return new window[\"THREE\"].Vector3(x, y, z); },\n    newMatrix3: function () { return new window[\"THREE\"].Matrix3(); },\n    newMatrix4: function () { return new window[\"THREE\"].Matrix4(); },\n    newObject3D: function () { return new window[\"THREE\"].Object3D(); },\n    newBox3: function () { return new window[\"THREE\"].Box3(); },\n    newSphere: function () { return new window[\"THREE\"].Sphere(); },\n    newBufferGeometry: function () { return new window[\"THREE\"].BufferGeometry(); },\n    generateUUID: function () { return window[\"THREE\"].MathUtils.generateUUID(); },\n    newFloat32BufferAttribute: function (array, itemSize, normalized) { return new window[\"THREE\"].Float32BufferAttribute(array, itemSize, normalized); },\n    newColor: function () { return new window[\"THREE\"].Color; },\n    newBufferAttribute: function (array, itemSize, normalized) { return new window[\"THREE\"].BufferAttribute(array, itemSize, normalized); }\n};\n//# sourceMappingURL=DefaultFactory.js.map","\"use strict\";\n/**\n * THE ORIGINAL SOURCE COOE IS HERE:\n *    https://github.com/mrdoob/three.js/blob/dev/examples/jsm/deprecated/Geometry.js\n *\n * This is a backport of the old (deprecated) THREE.DirectGeometry class.\n *\n * It got deprecated in version r125 and was announced to be completely dropped in future versions.\n *\n * As it was a very useful class I wanted to preserve it for some of my projects which depend on it.\n *\n * And here this is a Typescript port, too. Enjoy!\n *    - Ikaros Kappler\n *\n * @date 2022-02-11\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.DirectGeometry = void 0;\nvar DefaultFactory_1 = require(\"./DefaultFactory\");\nvar DirectGeometry = /** @class */ (function () {\n    function DirectGeometry(factory) {\n        this.vertices = [];\n        this.normals = [];\n        this.colors = [];\n        this.uvs = [];\n        this.uvs2 = [];\n        this.groups = [];\n        this.morphTargets = {};\n        this.skinWeights = [];\n        this.skinIndices = [];\n        // this.lineDistances = [];\n        this.boundingBox = null;\n        this.boundingSphere = null;\n        // update flags\n        this.verticesNeedUpdate = false;\n        this.normalsNeedUpdate = false;\n        this.colorsNeedUpdate = false;\n        this.uvsNeedUpdate = false;\n        this.groupsNeedUpdate = false;\n        // this.isGeometry = true;\n        this.factory = factory || DefaultFactory_1.DefaultFactory;\n    }\n    DirectGeometry.prototype.computeGroups = function (geometry) {\n        var groups = [];\n        var group;\n        var i;\n        var materialIndex = undefined;\n        var faces = geometry.faces;\n        for (i = 0; i < faces.length; i++) {\n            var face = faces[i];\n            // materials\n            if (face.materialIndex !== materialIndex) {\n                materialIndex = face.materialIndex;\n                if (group !== undefined) {\n                    group.count = i * 3 - group.start;\n                    groups.push(group);\n                }\n                group = {\n                    start: i * 3,\n                    materialIndex: materialIndex\n                };\n            }\n        }\n        if (group !== undefined) {\n            group.count = i * 3 - group.start;\n            groups.push(group);\n        }\n        this.groups = groups;\n    };\n    DirectGeometry.prototype.fromGeometry = function (geometry) {\n        var faces = geometry.faces;\n        var vertices = geometry.vertices;\n        var faceVertexUvs = geometry.faceVertexUvs;\n        var hasFaceVertexUv = faceVertexUvs[0] && faceVertexUvs[0].length > 0;\n        var hasFaceVertexUv2 = faceVertexUvs[1] && faceVertexUvs[1].length > 0;\n        // morphs\n        var morphTargets = geometry.morphTargets;\n        var morphTargetsLength = morphTargets.length;\n        var morphTargetsPosition;\n        if (morphTargetsLength > 0) {\n            morphTargetsPosition = [];\n            for (var i = 0; i < morphTargetsLength; i++) {\n                morphTargetsPosition[i] = {\n                    name: morphTargets[i].name,\n                    data: []\n                };\n            }\n            // TODO: here seems to be something wrong with the types\n            this.morphTargets.position = morphTargetsPosition;\n        }\n        var morphNormals = geometry.morphNormals;\n        var morphNormalsLength = morphNormals.length;\n        var morphTargetsNormal;\n        if (morphNormalsLength > 0) {\n            morphTargetsNormal = [];\n            for (var i = 0; i < morphNormalsLength; i++) {\n                morphTargetsNormal[i] = {\n                    name: morphNormals[i].name,\n                    data: []\n                };\n            }\n            this.morphTargets.normal = morphTargetsNormal;\n        }\n        // skins\n        var skinIndices = geometry.skinIndices;\n        var skinWeights = geometry.skinWeights;\n        var hasSkinIndices = skinIndices.length === vertices.length;\n        var hasSkinWeights = skinWeights.length === vertices.length;\n        //\n        if (vertices.length > 0 && faces.length === 0) {\n            console.error(\"THREE.DirectGeometry: Faceless geometries are not supported.\");\n        }\n        for (var i = 0; i < faces.length; i++) {\n            var face = faces[i];\n            this.vertices.push(vertices[face.a], vertices[face.b], vertices[face.c]);\n            var vertexNormals = face.vertexNormals;\n            if (vertexNormals.length === 3) {\n                this.normals.push(vertexNormals[0], vertexNormals[1], vertexNormals[2]);\n            }\n            else {\n                var normal = face.normal;\n                this.normals.push(normal, normal, normal);\n            }\n            var vertexColors = face.vertexColors;\n            if (vertexColors.length === 3) {\n                this.colors.push(vertexColors[0], vertexColors[1], vertexColors[2]);\n            }\n            else {\n                var color = face.color;\n                this.colors.push(color, color, color);\n            }\n            if (hasFaceVertexUv === true) {\n                var vertexUvs = faceVertexUvs[0][i];\n                if (vertexUvs !== undefined) {\n                    this.uvs.push(vertexUvs[0], vertexUvs[1], vertexUvs[2]);\n                }\n                else {\n                    console.warn(\"THREE.DirectGeometry.fromGeometry(): Undefined vertexUv \", i);\n                    // TODO: verify\n                    // this.uvs.push( new Vector2(), new Vector2(), new Vector2() );\n                    this.uvs.push(this.factory.newVector2(), this.factory.newVector2(), this.factory.newVector2());\n                }\n            }\n            if (hasFaceVertexUv2 === true) {\n                var vertexUvs = faceVertexUvs[1][i];\n                if (vertexUvs !== undefined) {\n                    this.uvs2.push(vertexUvs[0], vertexUvs[1], vertexUvs[2]);\n                }\n                else {\n                    console.warn(\"THREE.DirectGeometry.fromGeometry(): Undefined vertexUv2 \", i);\n                    // TODO: verify\n                    // this.uvs2.push( new Vector2(), new Vector2(), new Vector2() );\n                    this.uvs2.push(this.factory.newVector2(), this.factory.newVector2(), this.factory.newVector2());\n                }\n            }\n            // morphs\n            for (var j = 0; j < morphTargetsLength; j++) {\n                var morphTarget = morphTargets[j].vertices;\n                morphTargetsPosition[j].data.push(morphTarget[face.a], morphTarget[face.b], morphTarget[face.c]);\n            }\n            for (var j = 0; j < morphNormalsLength; j++) {\n                var morphNormal = morphNormals[j].vertexNormals[i];\n                morphTargetsNormal[j].data.push(morphNormal.a, morphNormal.b, morphNormal.c);\n            }\n            // skins\n            if (hasSkinIndices) {\n                this.skinIndices.push(skinIndices[face.a], skinIndices[face.b], skinIndices[face.c]);\n            }\n            if (hasSkinWeights) {\n                this.skinWeights.push(skinWeights[face.a], skinWeights[face.b], skinWeights[face.c]);\n            }\n        }\n        this.computeGroups(geometry);\n        this.verticesNeedUpdate = geometry.verticesNeedUpdate;\n        this.normalsNeedUpdate = geometry.normalsNeedUpdate;\n        this.colorsNeedUpdate = geometry.colorsNeedUpdate;\n        this.uvsNeedUpdate = geometry.uvsNeedUpdate;\n        this.groupsNeedUpdate = geometry.groupsNeedUpdate;\n        if (geometry.boundingSphere !== null) {\n            this.boundingSphere = geometry.boundingSphere.clone();\n        }\n        if (geometry.boundingBox !== null) {\n            this.boundingBox = geometry.boundingBox.clone();\n        }\n        return this;\n    };\n    return DirectGeometry;\n}());\nexports.DirectGeometry = DirectGeometry;\n//# sourceMappingURL=DirectGeometry.js.map","\"use strict\";\n/**\n * THE ORIGINAL SOURCE COOE IS HERE:\n *    https://github.com/mrdoob/three.js/blob/dev/examples/jsm/deprecated/Geometry.js\n *\n * This is a backport of the old (deprecated) THREE.Face3 class.\n *\n * It got deprecated in version r125 and was announced to be completely dropped in future versions.\n *\n * As it was a very useful class I wanted to preserve it for some of my projects which depend on it.\n *\n * And here this is a Typescript port, too. Enjoy!\n *    - Ikaros Kappler\n *\n * @date 2022-02-11\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Face3 = void 0;\nvar DefaultFactory_1 = require(\"./DefaultFactory\");\nvar Face3 = /** @class */ (function () {\n    function Face3(a, b, c, normal, color, materialIndex, factory) {\n        if (materialIndex === void 0) { materialIndex = 0; }\n        var fact = factory || DefaultFactory_1.DefaultFactory;\n        this.a = a;\n        this.b = b;\n        this.c = c;\n        // this.normal = ( normal && normal.isVector3 ) ? normal : new THREE.Vector3();\n        // this.vertexNormals = Array.isArray( normal ) ? normal : [];\n        // TODO: verify correctness\n        // this.normal = ( normal && (normal instanceof Vector3 && normal.isVector3) ) ? normal : new Vector3();\n        // TODO: use DefaultFactory here\n        // this.normal = ( normal && (normal instanceof Vector3 && normal.isVector3) ) ? normal : new (window[\"THREE\"]).Vector3();\n        this.normal = normal && normal.isVector3 ? normal : fact.newVector3();\n        this.vertexNormals = Array.isArray(normal) ? normal : [];\n        // this.color = ( color && color.isColor ) ? color : new THREE.Color();\n        // this.color = ( color && ( color instanceof Color && color.isColor)  ) ? color : new Color(); // TODO: verify correctness\n        // TODO: use DefaultFactory here\n        this.color = color && color.isColor ? color : fact.newColor(); // TODO: verify correctness\n        this.vertexColors = Array.isArray(color) ? color : [];\n        this.materialIndex = materialIndex;\n    }\n    Face3.prototype.clone = function () {\n        // TODO: check if new expression is correct\n        // return new this.constructor().copy( this );\n        return new Face3(this.a, this.b, this.c, this.normal.clone(), this.color.clone(), this.materialIndex).copy(this);\n    };\n    Face3.prototype.copy = function (source) {\n        this.a = source.a;\n        this.b = source.b;\n        this.c = source.c;\n        this.normal.copy(source.normal);\n        this.color.copy(source.color);\n        this.materialIndex = source.materialIndex;\n        for (var i = 0, il = source.vertexNormals.length; i < il; i++) {\n            this.vertexNormals[i] = source.vertexNormals[i].clone();\n        }\n        for (var i = 0, il = source.vertexColors.length; i < il; i++) {\n            this.vertexColors[i] = source.vertexColors[i].clone();\n        }\n        return this;\n    };\n    return Face3;\n}());\nexports.Face3 = Face3;\n//# sourceMappingURL=Face3.js.map","\"use strict\";\n/**\n * THE ORIGINAL SOURCE COOE IS HERE:\n *    https://github.com/mrdoob/three.js/blob/dev/examples/jsm/deprecated/Geometry.js\n *\n * This is a backport of the old (deprecated) THREE.Face3 class.\n *\n * It got deprecated in version r125 and was announced to be completely dropped in future versions.\n *\n * As it was a very useful class I wanted to preserve it for some of my projects which depend on it.\n *\n * And here this is a Typescript port, too. Enjoy!\n *    - Ikaros Kappler\n *\n * @date 2022-02-11\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Gmetry = void 0;\nvar DefaultFactory_1 = require(\"./DefaultFactory\");\nvar DirectGeometry_1 = require(\"./DirectGeometry\");\nvar Face3_1 = require(\"./Face3\");\nvar Gmetry = /** @class */ (function () {\n    /**\n     * Construct a new Gmetry.\n     *\n     * @param {ThreeFactory?} factory - Specify a custom factory if you do not want to use the DefaultFactory.\n     */\n    function Gmetry(factory) {\n        this.name = \"\";\n        this.type = \"Geometry\";\n        this.vertices = [];\n        this.colors = [];\n        this.faces = [];\n        this.faceVertexUvs = [[]];\n        this.morphTargets = [];\n        this.morphNormals = [];\n        this.skinWeights = [];\n        this.skinIndices = [];\n        this.lineDistances = [];\n        this.boundingBox = null;\n        this.boundingSphere = null;\n        // update flags\n        this.elementsNeedUpdate = false;\n        this.verticesNeedUpdate = false;\n        this.uvsNeedUpdate = false;\n        this.normalsNeedUpdate = false;\n        this.colorsNeedUpdate = false;\n        this.lineDistancesNeedUpdate = false;\n        this.groupsNeedUpdate = false;\n        this.isGeometry = true;\n        this.factory = factory || DefaultFactory_1.DefaultFactory;\n        this.uuid = this.factory.generateUUID();\n        this._m1 = this.factory.newMatrix4();\n        this._obj = this.factory.newObject3D();\n        this._offset = this.factory.newVector3();\n    }\n    Gmetry.prototype.applyMatrix4 = function (matrix) {\n        var normalMatrix = this.factory.newMatrix3().getNormalMatrix(matrix);\n        for (var i = 0, il = this.vertices.length; i < il; i++) {\n            var vertex = this.vertices[i];\n            vertex.applyMatrix4(matrix);\n        }\n        for (var i = 0, il = this.faces.length; i < il; i++) {\n            var face = this.faces[i];\n            face.normal.applyMatrix3(normalMatrix).normalize();\n            for (var j = 0, jl = face.vertexNormals.length; j < jl; j++) {\n                face.vertexNormals[j].applyMatrix3(normalMatrix).normalize();\n            }\n        }\n        if (this.boundingBox !== null) {\n            this.computeBoundingBox();\n        }\n        if (this.boundingSphere !== null) {\n            this.computeBoundingSphere();\n        }\n        this.verticesNeedUpdate = true;\n        this.normalsNeedUpdate = true;\n        return this;\n    };\n    Gmetry.prototype.rotateX = function (angle) {\n        // rotate geometry around world x-axis\n        this._m1.makeRotationX(angle);\n        this.applyMatrix4(this._m1);\n        return this;\n    };\n    Gmetry.prototype.rotateY = function (angle) {\n        // rotate geometry around world y-axis\n        this._m1.makeRotationY(angle);\n        this.applyMatrix4(this._m1);\n        return this;\n    };\n    Gmetry.prototype.rotateZ = function (angle) {\n        // rotate geometry around world z-axis\n        this._m1.makeRotationZ(angle);\n        this.applyMatrix4(this._m1);\n        return this;\n    };\n    Gmetry.prototype.translate = function (x, y, z) {\n        // translate geometry\n        this._m1.makeTranslation(x, y, z);\n        this.applyMatrix4(this._m1);\n        return this;\n    };\n    Gmetry.prototype.scale = function (x, y, z) {\n        // scale geometry\n        this._m1.makeScale(x, y, z);\n        this.applyMatrix4(this._m1);\n        return this;\n    };\n    Gmetry.prototype.lookAt = function (vector) {\n        this._obj.lookAt(vector);\n        this._obj.updateMatrix();\n        this.applyMatrix4(this._obj.matrix);\n        return this;\n    };\n    Gmetry.prototype.fromBufferGeometry = function (geometry) {\n        var scope = this;\n        var index = geometry.index !== null ? geometry.index : undefined;\n        var attributes = geometry.attributes;\n        if (attributes.position === undefined) {\n            console.error(\"THREE.Geometry.fromBufferGeometry(): Position attribute required for conversion.\");\n            return this;\n        }\n        var position = attributes.position;\n        var normal = attributes.normal;\n        var color = attributes.color;\n        var uv = attributes.uv;\n        var uv2 = attributes.uv2;\n        if (uv2 !== undefined)\n            this.faceVertexUvs[1] = [];\n        for (var i = 0; i < position.count; i++) {\n            scope.vertices.push(this.factory.newVector3().fromBufferAttribute(position, i));\n            if (color !== undefined) {\n                scope.colors.push(this.factory.newColor().fromBufferAttribute(color, i));\n            }\n        }\n        var factory = this.factory;\n        // TODO: put to helper functions\n        var addFace = function (a, b, c, materialIndex) {\n            var vertexColors = color === undefined ? [] : [scope.colors[a].clone(), scope.colors[b].clone(), scope.colors[c].clone()];\n            var vertexNormals = normal === undefined\n                ? []\n                : [\n                    factory.newVector3().fromBufferAttribute(normal, a),\n                    factory.newVector3().fromBufferAttribute(normal, b),\n                    factory.newVector3().fromBufferAttribute(normal, c)\n                ];\n            var face = new Face3_1.Face3(a, b, c, vertexNormals, vertexColors, materialIndex);\n            scope.faces.push(face);\n            if (uv !== undefined) {\n                scope.faceVertexUvs[0].push([\n                    factory.newVector2().fromBufferAttribute(uv, a),\n                    factory.newVector2().fromBufferAttribute(uv, b),\n                    factory.newVector2().fromBufferAttribute(uv, c)\n                ]);\n            }\n            if (uv2 !== undefined) {\n                scope.faceVertexUvs[1].push([\n                    factory.newVector2().fromBufferAttribute(uv2, a),\n                    factory.newVector2().fromBufferAttribute(uv2, b),\n                    factory.newVector2().fromBufferAttribute(uv2, c)\n                ]);\n            }\n        };\n        var groups = geometry.groups;\n        if (groups.length > 0) {\n            for (var i = 0; i < groups.length; i++) {\n                var group = groups[i];\n                var start = group.start;\n                var count = group.count;\n                for (var j = start, jl = start + count; j < jl; j += 3) {\n                    if (index !== undefined) {\n                        addFace(index.getX(j), index.getX(j + 1), index.getX(j + 2), group.materialIndex);\n                    }\n                    else {\n                        addFace(j, j + 1, j + 2, group.materialIndex);\n                    }\n                }\n            }\n        }\n        else {\n            if (index !== undefined) {\n                for (var i = 0; i < index.count; i += 3) {\n                    addFace(index.getX(i), index.getX(i + 1), index.getX(i + 2));\n                }\n            }\n            else {\n                for (var i = 0; i < position.count; i += 3) {\n                    addFace(i, i + 1, i + 2);\n                }\n            }\n        }\n        this.computeFaceNormals();\n        if (geometry.boundingBox !== null) {\n            this.boundingBox = geometry.boundingBox.clone();\n        }\n        if (geometry.boundingSphere !== null) {\n            this.boundingSphere = geometry.boundingSphere.clone();\n        }\n        return this;\n    };\n    Gmetry.prototype.center = function () {\n        this.computeBoundingBox();\n        this.boundingBox.getCenter(this._offset).negate();\n        this.translate(this._offset.x, this._offset.y, this._offset.z);\n        return this;\n    };\n    Gmetry.prototype.normalize = function () {\n        this.computeBoundingSphere();\n        var center = this.boundingSphere.center;\n        var radius = this.boundingSphere.radius;\n        var s = radius === 0 ? 1 : 1.0 / radius;\n        var matrix = this.factory.newMatrix4();\n        matrix.set(s, 0, 0, -s * center.x, 0, s, 0, -s * center.y, 0, 0, s, -s * center.z, 0, 0, 0, 1);\n        this.applyMatrix4(matrix);\n        return this;\n    };\n    Gmetry.prototype.computeFaceNormals = function () {\n        var cb = this.factory.newVector3(), ab = this.factory.newVector3();\n        for (var f = 0, fl = this.faces.length; f < fl; f++) {\n            var face = this.faces[f];\n            var vA = this.vertices[face.a];\n            var vB = this.vertices[face.b];\n            var vC = this.vertices[face.c];\n            cb.subVectors(vC, vB);\n            ab.subVectors(vA, vB);\n            cb.cross(ab);\n            cb.normalize();\n            face.normal.copy(cb);\n        }\n    };\n    Gmetry.prototype.computeVertexNormals = function (areaWeighted) {\n        if (areaWeighted === void 0) { areaWeighted = true; }\n        var vertices = new Array(this.vertices.length);\n        for (var v = 0, vl = this.vertices.length; v < vl; v++) {\n            // TODO: verify\n            // vertices[ v ] = new Vector3();\n            vertices[v] = this.factory.newVector3();\n        }\n        if (areaWeighted) {\n            // vertex normals weighted by triangle areas\n            // http://www.iquilezles.org/www/articles/normals/normals.htm\n            // TODO: verify\n            // const cb = new Vector3(), ab = new Vector3();\n            var cb = this.factory.newVector3(), ab = this.factory.newVector3();\n            for (var f = 0, fl = this.faces.length; f < fl; f++) {\n                var face = this.faces[f];\n                var vA = this.vertices[face.a];\n                var vB = this.vertices[face.b];\n                var vC = this.vertices[face.c];\n                cb.subVectors(vC, vB);\n                ab.subVectors(vA, vB);\n                cb.cross(ab);\n                vertices[face.a].add(cb);\n                vertices[face.b].add(cb);\n                vertices[face.c].add(cb);\n            }\n        }\n        else {\n            this.computeFaceNormals();\n            for (var f = 0, fl = this.faces.length; f < fl; f++) {\n                var face = this.faces[f];\n                vertices[face.a].add(face.normal);\n                vertices[face.b].add(face.normal);\n                vertices[face.c].add(face.normal);\n            }\n        }\n        for (var v = 0, vl = this.vertices.length; v < vl; v++) {\n            vertices[v].normalize();\n        }\n        for (var f = 0, fl = this.faces.length; f < fl; f++) {\n            var face = this.faces[f];\n            var vertexNormals = face.vertexNormals;\n            if (vertexNormals.length === 3) {\n                vertexNormals[0].copy(vertices[face.a]);\n                vertexNormals[1].copy(vertices[face.b]);\n                vertexNormals[2].copy(vertices[face.c]);\n            }\n            else {\n                vertexNormals[0] = vertices[face.a].clone();\n                vertexNormals[1] = vertices[face.b].clone();\n                vertexNormals[2] = vertices[face.c].clone();\n            }\n        }\n        if (this.faces.length > 0) {\n            this.normalsNeedUpdate = true;\n        }\n    };\n    Gmetry.prototype.computeFlatVertexNormals = function () {\n        this.computeFaceNormals();\n        for (var f = 0, fl = this.faces.length; f < fl; f++) {\n            var face = this.faces[f];\n            var vertexNormals = face.vertexNormals;\n            if (vertexNormals.length === 3) {\n                vertexNormals[0].copy(face.normal);\n                vertexNormals[1].copy(face.normal);\n                vertexNormals[2].copy(face.normal);\n            }\n            else {\n                vertexNormals[0] = face.normal.clone();\n                vertexNormals[1] = face.normal.clone();\n                vertexNormals[2] = face.normal.clone();\n            }\n        }\n        if (this.faces.length > 0) {\n            this.normalsNeedUpdate = true;\n        }\n    };\n    Gmetry.prototype.computeMorphNormals = function () {\n        // save original normals\n        // - create temp variables on first access\n        //   otherwise just copy (for faster repeated calls)\n        for (var f = 0, fl = this.faces.length; f < fl; f++) {\n            var face = this.faces[f];\n            if (!face.__originalFaceNormal) {\n                face.__originalFaceNormal = face.normal.clone();\n            }\n            else {\n                face.__originalFaceNormal.copy(face.normal);\n            }\n            if (!face.__originalVertexNormals)\n                face.__originalVertexNormals = [];\n            for (var i = 0, il = face.vertexNormals.length; i < il; i++) {\n                if (!face.__originalVertexNormals[i]) {\n                    face.__originalVertexNormals[i] = face.vertexNormals[i].clone();\n                }\n                else {\n                    face.__originalVertexNormals[i].copy(face.vertexNormals[i]);\n                }\n            }\n        }\n        // use temp geometry to compute face and vertex normals for each morph\n        var tmpGeo = new Gmetry(this.factory);\n        tmpGeo.faces = this.faces;\n        for (var i = 0, il = this.morphTargets.length; i < il; i++) {\n            // create on first access\n            if (!this.morphNormals[i]) {\n                this.morphNormals[i] = {}; // TODO: check\n                this.morphNormals[i].faceNormals = [];\n                this.morphNormals[i].vertexNormals = [];\n                var dstNormalsFace = this.morphNormals[i].faceNormals;\n                var dstNormalsVertex = this.morphNormals[i].vertexNormals;\n                for (var f = 0, fl = this.faces.length; f < fl; f++) {\n                    var faceNormal = this.factory.newVector3();\n                    var vertexNormals = { a: this.factory.newVector3(), b: this.factory.newVector3(), c: this.factory.newVector3() };\n                    dstNormalsFace.push(faceNormal);\n                    dstNormalsVertex.push(vertexNormals);\n                }\n            }\n            var morphNormals = this.morphNormals[i];\n            // set vertices to morph target\n            tmpGeo.vertices = this.morphTargets[i].vertices;\n            // compute morph normals\n            tmpGeo.computeFaceNormals();\n            tmpGeo.computeVertexNormals();\n            // store morph normals\n            for (var f = 0, fl = this.faces.length; f < fl; f++) {\n                var face = this.faces[f];\n                var faceNormal = morphNormals.faceNormals[f];\n                var vertexNormals = morphNormals.vertexNormals[f];\n                faceNormal.copy(face.normal);\n                vertexNormals.a.copy(face.vertexNormals[0]);\n                vertexNormals.b.copy(face.vertexNormals[1]);\n                vertexNormals.c.copy(face.vertexNormals[2]);\n            }\n        }\n        // restore original normals\n        for (var f = 0, fl = this.faces.length; f < fl; f++) {\n            var face = this.faces[f];\n            face.normal = face.__originalFaceNormal;\n            face.vertexNormals = face.__originalVertexNormals;\n        }\n    };\n    Gmetry.prototype.computeBoundingBox = function () {\n        if (this.boundingBox === null) {\n            this.boundingBox = this.factory.newBox3();\n        }\n        this.boundingBox.setFromPoints(this.vertices);\n    };\n    Gmetry.prototype.computeBoundingSphere = function () {\n        if (this.boundingSphere === null) {\n            this.boundingSphere = this.factory.newSphere();\n        }\n        this.boundingSphere.setFromPoints(this.vertices);\n    };\n    Gmetry.prototype.merge = function (geometry, matrix, materialIndexOffset) {\n        if (materialIndexOffset === void 0) { materialIndexOffset = 0; }\n        if (!(geometry && geometry.isGeometry)) {\n            console.error(\"THREE.Geometry.merge(): geometry not an instance of THREE.Geometry.\", geometry);\n            return;\n        }\n        var normalMatrix;\n        var vertexOffset = this.vertices.length, vertices1 = this.vertices, vertices2 = geometry.vertices, faces1 = this.faces, faces2 = geometry.faces, colors1 = this.colors, colors2 = geometry.colors;\n        if (matrix !== undefined) {\n            normalMatrix = this.factory.newMatrix3().getNormalMatrix(matrix);\n        }\n        // vertices\n        for (var i = 0, il = vertices2.length; i < il; i++) {\n            var vertex = vertices2[i];\n            var vertexCopy = vertex.clone();\n            if (matrix !== undefined) {\n                vertexCopy.applyMatrix4(matrix);\n            }\n            vertices1.push(vertexCopy);\n        }\n        // colors\n        for (var i = 0, il = colors2.length; i < il; i++) {\n            colors1.push(colors2[i].clone());\n        }\n        // faces\n        for (var i = 0, il = faces2.length; i < il; i++) {\n            var face = faces2[i];\n            var normal = void 0;\n            var color = void 0;\n            var faceVertexNormals = face.vertexNormals, faceVertexColors = face.vertexColors;\n            var faceCopy = new Face3_1.Face3(face.a + vertexOffset, face.b + vertexOffset, face.c + vertexOffset);\n            faceCopy.normal.copy(face.normal);\n            if (normalMatrix !== undefined) {\n                faceCopy.normal.applyMatrix3(normalMatrix).normalize();\n            }\n            for (var j = 0, jl = faceVertexNormals.length; j < jl; j++) {\n                normal = faceVertexNormals[j].clone();\n                if (normalMatrix !== undefined) {\n                    normal.applyMatrix3(normalMatrix).normalize();\n                }\n                faceCopy.vertexNormals.push(normal);\n            }\n            faceCopy.color.copy(face.color);\n            for (var j = 0, jl = faceVertexColors.length; j < jl; j++) {\n                color = faceVertexColors[j];\n                faceCopy.vertexColors.push(color.clone());\n            }\n            faceCopy.materialIndex = face.materialIndex + materialIndexOffset;\n            faces1.push(faceCopy);\n        }\n        // uvs\n        for (var i = 0, il = geometry.faceVertexUvs.length; i < il; i++) {\n            var faceVertexUvs2 = geometry.faceVertexUvs[i];\n            if (this.faceVertexUvs[i] === undefined) {\n                this.faceVertexUvs[i] = [];\n            }\n            for (var j = 0, jl = faceVertexUvs2.length; j < jl; j++) {\n                var uvs2 = faceVertexUvs2[j], uvsCopy = [];\n                for (var k = 0, kl = uvs2.length; k < kl; k++) {\n                    uvsCopy.push(uvs2[k].clone());\n                }\n                this.faceVertexUvs[i].push(uvsCopy); // TODO: check\n            }\n        }\n    };\n    // TODO: the new version of Mesh operates on BufferGeometry\n    Gmetry.prototype.mergeMesh = function (mesh) {\n        if (!(mesh && mesh.isMesh)) {\n            console.error(\"THREE.Geometry.mergeMesh(): mesh not an instance of THREE.Mesh.\", mesh);\n            return;\n        }\n        if (mesh.matrixAutoUpdate) {\n            mesh.updateMatrix();\n        }\n        this.merge(mesh.geometry, mesh.matrix);\n    };\n    /*\n     * Checks for duplicate vertices with hashmap.\n     * Duplicated vertices are removed\n     * and faces' vertices are updated.\n     */\n    Gmetry.prototype.mergeVertices = function (precisionPoints) {\n        if (precisionPoints === void 0) { precisionPoints = 4; }\n        var verticesMap = {}; // Hashmap for looking up vertices by position coordinates (and making sure they are unique)\n        var unique = [], changes = [];\n        var precision = Math.pow(10, precisionPoints);\n        for (var i = 0, il = this.vertices.length; i < il; i++) {\n            var v = this.vertices[i];\n            var key = Math.round(v.x * precision) + \"_\" + Math.round(v.y * precision) + \"_\" + Math.round(v.z * precision);\n            if (verticesMap[key] === undefined) {\n                verticesMap[key] = i;\n                unique.push(this.vertices[i]);\n                changes[i] = unique.length - 1;\n            }\n            else {\n                //console.log('Duplicate vertex found. ', i, ' could be using ', verticesMap[key]);\n                changes[i] = changes[verticesMap[key]];\n            }\n        }\n        // if faces are completely degenerate after merging vertices, we\n        // have to remove them from the geometry.\n        var faceIndicesToRemove = [];\n        for (var i = 0, il = this.faces.length; i < il; i++) {\n            var face = this.faces[i];\n            face.a = changes[face.a];\n            face.b = changes[face.b];\n            face.c = changes[face.c];\n            var indices = [face.a, face.b, face.c];\n            // if any duplicate vertices are found in a Face3\n            // we have to remove the face as nothing can be saved\n            for (var n = 0; n < 3; n++) {\n                if (indices[n] === indices[(n + 1) % 3]) {\n                    faceIndicesToRemove.push(i);\n                    break;\n                }\n            }\n        }\n        for (var i = faceIndicesToRemove.length - 1; i >= 0; i--) {\n            var idx = faceIndicesToRemove[i];\n            this.faces.splice(idx, 1);\n            for (var j = 0, jl = this.faceVertexUvs.length; j < jl; j++) {\n                this.faceVertexUvs[j].splice(idx, 1);\n            }\n        }\n        // Use unique set of vertices\n        var diff = this.vertices.length - unique.length;\n        this.vertices = unique;\n        return diff;\n    };\n    Gmetry.prototype.setFromPoints = function (points) {\n        this.vertices = [];\n        for (var i = 0, l = points.length; i < l; i++) {\n            var point = points[i];\n            // TODO: verify\n            // this.vertices.push( new Vector3( point.x, point.y, point.z || 0 ) );\n            //   this.vertices.push(this.factory.newVector3(point.x, point.y, point.z || 0));\n            this.vertices.push(this.factory.newVector3(point.x, point.y, point.z || 0));\n        }\n        return this;\n    };\n    Gmetry.prototype.sortFacesByMaterialIndex = function () {\n        var faces = this.faces;\n        var length = faces.length;\n        // tag faces\n        for (var i = 0; i < length; i++) {\n            faces[i]._id = i;\n        }\n        // sort faces\n        function materialIndexSort(a, b) {\n            return a.materialIndex - b.materialIndex;\n        }\n        faces.sort(materialIndexSort);\n        // sort uvs\n        var uvs1 = this.faceVertexUvs[0];\n        var uvs2 = this.faceVertexUvs[1];\n        var newUvs1, newUvs2;\n        if (uvs1 && uvs1.length === length) {\n            newUvs1 = [];\n        }\n        if (uvs2 && uvs2.length === length) {\n            newUvs2 = [];\n        }\n        for (var i = 0; i < length; i++) {\n            var id = faces[i]._id;\n            if (newUvs1)\n                newUvs1.push(uvs1[id]);\n            if (newUvs2)\n                newUvs2.push(uvs2[id]);\n        }\n        if (newUvs1) {\n            this.faceVertexUvs[0] = newUvs1;\n        }\n        if (newUvs2) {\n            this.faceVertexUvs[1] = newUvs2;\n        }\n    };\n    Gmetry.prototype.toJSON = function () {\n        var data = {\n            metadata: {\n                version: 4.5,\n                type: \"Geometry\",\n                generator: \"Geometry.toJSON\"\n            },\n            // TODO: check\n            uuid: null,\n            type: null,\n            name: null,\n            data: null\n        };\n        // standard Geometry serialization\n        data.uuid = this.uuid;\n        data.type = this.type;\n        if (this.name !== \"\")\n            data.name = this.name;\n        if (this.parameters !== undefined) {\n            var parameters = this.parameters;\n            for (var key in parameters) {\n                if (parameters[key] !== undefined)\n                    data[key] = parameters[key];\n            }\n            return data;\n        }\n        var vertices = [];\n        for (var i = 0; i < this.vertices.length; i++) {\n            var vertex = this.vertices[i];\n            vertices.push(vertex.x, vertex.y, vertex.z);\n        }\n        var faces = [];\n        var normals = [];\n        var normalsHash = {};\n        var colors = [];\n        var colorsHash = {};\n        var uvs = [];\n        var uvsHash = {};\n        for (var i = 0; i < this.faces.length; i++) {\n            var face = this.faces[i];\n            var hasMaterial = true;\n            var hasFaceUv = false; // deprecated\n            var hasFaceVertexUv = this.faceVertexUvs[0][i] !== undefined;\n            var hasFaceNormal = face.normal.length() > 0;\n            var hasFaceVertexNormal = face.vertexNormals.length > 0;\n            var hasFaceColor = face.color.r !== 1 || face.color.g !== 1 || face.color.b !== 1;\n            var hasFaceVertexColor = face.vertexColors.length > 0;\n            var faceType = 0;\n            // TODO: move to helpers?\n            var setBit = function (value, position, enabled) {\n                return enabled ? value | (1 << position) : value & ~(1 << position);\n            };\n            // TODO: move to helpers?\n            var getNormalIndex = function (normal) {\n                var hash = normal.x.toString() + normal.y.toString() + normal.z.toString();\n                if (normalsHash[hash] !== undefined) {\n                    return normalsHash[hash];\n                }\n                normalsHash[hash] = normals.length / 3;\n                normals.push(normal.x, normal.y, normal.z);\n                return normalsHash[hash];\n            };\n            // TODO: move to helpers?\n            var getColorIndex = function (color) {\n                var hash = color.r.toString() + color.g.toString() + color.b.toString();\n                if (colorsHash[hash] !== undefined) {\n                    return colorsHash[hash];\n                }\n                colorsHash[hash] = colors.length;\n                colors.push(color.getHex());\n                return colorsHash[hash];\n            };\n            // TODO: move to helpers?\n            var getUvIndex = function (uv) {\n                var hash = uv.x.toString() + uv.y.toString();\n                if (uvsHash[hash] !== undefined) {\n                    return uvsHash[hash];\n                }\n                uvsHash[hash] = uvs.length / 2;\n                uvs.push(uv.x, uv.y);\n                return uvsHash[hash];\n            };\n            faceType = setBit(faceType, 0, 0); // isQuad\n            faceType = setBit(faceType, 1, hasMaterial);\n            faceType = setBit(faceType, 2, hasFaceUv);\n            faceType = setBit(faceType, 3, hasFaceVertexUv);\n            faceType = setBit(faceType, 4, hasFaceNormal);\n            faceType = setBit(faceType, 5, hasFaceVertexNormal);\n            faceType = setBit(faceType, 6, hasFaceColor);\n            faceType = setBit(faceType, 7, hasFaceVertexColor);\n            faces.push(faceType);\n            faces.push(face.a, face.b, face.c);\n            faces.push(face.materialIndex);\n            if (hasFaceVertexUv) {\n                var faceVertexUvs = this.faceVertexUvs[0][i];\n                faces.push(getUvIndex(faceVertexUvs[0]), getUvIndex(faceVertexUvs[1]), getUvIndex(faceVertexUvs[2]));\n            }\n            if (hasFaceNormal) {\n                faces.push(getNormalIndex(face.normal));\n            }\n            if (hasFaceVertexNormal) {\n                var vertexNormals = face.vertexNormals;\n                faces.push(getNormalIndex(vertexNormals[0]), getNormalIndex(vertexNormals[1]), getNormalIndex(vertexNormals[2]));\n            }\n            if (hasFaceColor) {\n                faces.push(getColorIndex(face.color));\n            }\n            if (hasFaceVertexColor) {\n                var vertexColors = face.vertexColors;\n                faces.push(getColorIndex(vertexColors[0]), getColorIndex(vertexColors[1]), getColorIndex(vertexColors[2]));\n            }\n        }\n        // // TODO: move to helpers?\n        // const setBit = (value: number, position: number, enabled: boolean | number) => {\n        //   return enabled ? value | (1 << position) : value & ~(1 << position);\n        // };\n        // // TODO: move to helpers?\n        // const getNormalIndex = (normal: Vector3) => {\n        //   const hash = normal.x.toString() + normal.y.toString() + normal.z.toString();\n        //   if (normalsHash[hash] !== undefined) {\n        //     return normalsHash[hash];\n        //   }\n        //   normalsHash[hash] = normals.length / 3;\n        //   normals.push(normal.x, normal.y, normal.z);\n        //   return normalsHash[hash];\n        // };\n        // // TODO: move to helpers?\n        // const getColorIndex = (color: Color) => {\n        //   const hash = color.r.toString() + color.g.toString() + color.b.toString();\n        //   if (colorsHash[hash] !== undefined) {\n        //     return colorsHash[hash];\n        //   }\n        //   colorsHash[hash] = colors.length;\n        //   colors.push(color.getHex());\n        //   return colorsHash[hash];\n        // };\n        // // TODO: move to helpers?\n        // const getUvIndex = (uv: Vector2) => {\n        //   const hash = uv.x.toString() + uv.y.toString();\n        //   if (uvsHash[hash] !== undefined) {\n        //     return uvsHash[hash];\n        //   }\n        //   uvsHash[hash] = uvs.length / 2;\n        //   uvs.push(uv.x, uv.y);\n        //   return uvsHash[hash];\n        // };\n        data.data = {};\n        data.data.vertices = vertices;\n        data.data.normals = normals;\n        if (colors.length > 0) {\n            data.data.colors = colors;\n        }\n        if (uvs.length > 0) {\n            data.data.uvs = [uvs]; // temporal backward compatibility\n        }\n        data.data.faces = faces;\n        return data;\n    };\n    Gmetry.prototype.clone = function () {\n        /*\n             // Handle primitives\n    \n             const parameters = this.parameters;\n    \n             if ( parameters !== undefined ) {\n    \n             const values = [];\n    \n             for ( const key in parameters ) {\n    \n             values.push( parameters[ key ] );\n    \n             }\n    \n             const geometry = Object.create( this.constructor.prototype );\n             this.constructor.apply( geometry, values );\n             return geometry;\n    \n             }\n    \n             return new this.constructor().copy( this );\n             */\n        // return new Geometry().copy( this ); // BEFORE\n        return new Gmetry(this.factory).copy(this);\n    };\n    Gmetry.prototype.copy = function (source) {\n        // reset\n        this.vertices = [];\n        this.colors = [];\n        this.faces = [];\n        this.faceVertexUvs = [[]];\n        this.morphTargets = [];\n        this.morphNormals = [];\n        this.skinWeights = [];\n        this.skinIndices = [];\n        this.lineDistances = [];\n        this.boundingBox = null;\n        this.boundingSphere = null;\n        // name\n        this.name = source.name;\n        // vertices\n        var vertices = source.vertices;\n        for (var i = 0, il = vertices.length; i < il; i++) {\n            this.vertices.push(vertices[i].clone());\n        }\n        // colors\n        var colors = source.colors;\n        for (var i = 0, il = colors.length; i < il; i++) {\n            this.colors.push(colors[i].clone());\n        }\n        // faces\n        var faces = source.faces;\n        for (var i = 0, il = faces.length; i < il; i++) {\n            this.faces.push(faces[i].clone());\n        }\n        // face vertex uvs\n        for (var i = 0, il = source.faceVertexUvs.length; i < il; i++) {\n            var faceVertexUvs = source.faceVertexUvs[i];\n            if (this.faceVertexUvs[i] === undefined) {\n                this.faceVertexUvs[i] = [];\n            }\n            for (var j = 0, jl = faceVertexUvs.length; j < jl; j++) {\n                var uvs = faceVertexUvs[j], uvsCopy = [];\n                for (var k = 0, kl = uvs.length; k < kl; k++) {\n                    var uv = uvs[k];\n                    uvsCopy.push(uv.clone());\n                }\n                this.faceVertexUvs[i].push(uvsCopy); // TODO: check\n            }\n        }\n        // morph targets\n        var morphTargets = source.morphTargets;\n        for (var i = 0, il = morphTargets.length; i < il; i++) {\n            var morphTarget = {}; // // TODO: check\n            morphTarget.name = morphTargets[i].name;\n            // vertices\n            if (morphTargets[i].vertices !== undefined) {\n                morphTarget.vertices = [];\n                for (var j = 0, jl = morphTargets[i].vertices.length; j < jl; j++) {\n                    morphTarget.vertices.push(morphTargets[i].vertices[j].clone());\n                }\n            }\n            // normals\n            if (morphTargets[i].normals !== undefined) {\n                morphTarget.normals = [];\n                for (var j = 0, jl = morphTargets[i].normals.length; j < jl; j++) {\n                    morphTarget.normals.push(morphTargets[i].normals[j].clone());\n                }\n            }\n            this.morphTargets.push(morphTarget);\n        }\n        // morph normals\n        var morphNormals = source.morphNormals;\n        for (var i = 0, il = morphNormals.length; i < il; i++) {\n            var morphNormal = {};\n            // vertex normals\n            if (morphNormals[i].vertexNormals !== undefined) {\n                morphNormal.vertexNormals = [];\n                for (var j = 0, jl = morphNormals[i].vertexNormals.length; j < jl; j++) {\n                    var srcVertexNormal = morphNormals[i].vertexNormals[j];\n                    // TODO: add type\n                    var destVertexNormal = { a: null, b: null, c: null };\n                    destVertexNormal.a = srcVertexNormal.a.clone();\n                    destVertexNormal.b = srcVertexNormal.b.clone();\n                    destVertexNormal.c = srcVertexNormal.c.clone();\n                    morphNormal.vertexNormals.push(destVertexNormal);\n                }\n            }\n            // face normals\n            if (morphNormals[i].faceNormals !== undefined) {\n                morphNormal.faceNormals = [];\n                for (var j = 0, jl = morphNormals[i].faceNormals.length; j < jl; j++) {\n                    morphNormal.faceNormals.push(morphNormals[i].faceNormals[j].clone());\n                }\n            }\n            this.morphNormals.push(morphNormal);\n        }\n        // skin weights\n        var skinWeights = source.skinWeights;\n        for (var i = 0, il = skinWeights.length; i < il; i++) {\n            this.skinWeights.push(skinWeights[i].clone());\n        }\n        // skin indices\n        var skinIndices = source.skinIndices;\n        for (var i = 0, il = skinIndices.length; i < il; i++) {\n            this.skinIndices.push(skinIndices[i].clone());\n        }\n        // line distances\n        var lineDistances = source.lineDistances;\n        for (var i = 0, il = lineDistances.length; i < il; i++) {\n            this.lineDistances.push(lineDistances[i]);\n        }\n        // bounding box\n        var boundingBox = source.boundingBox;\n        if (boundingBox !== null) {\n            this.boundingBox = boundingBox.clone();\n        }\n        // bounding sphere\n        var boundingSphere = source.boundingSphere;\n        if (boundingSphere !== null) {\n            this.boundingSphere = boundingSphere.clone();\n        }\n        // update flags\n        this.elementsNeedUpdate = source.elementsNeedUpdate;\n        this.verticesNeedUpdate = source.verticesNeedUpdate;\n        this.uvsNeedUpdate = source.uvsNeedUpdate;\n        this.normalsNeedUpdate = source.normalsNeedUpdate;\n        this.colorsNeedUpdate = source.colorsNeedUpdate;\n        this.lineDistancesNeedUpdate = source.lineDistancesNeedUpdate;\n        this.groupsNeedUpdate = source.groupsNeedUpdate;\n        return this;\n    };\n    Gmetry.prototype.toBufferGeometry = function () {\n        var geometry = new DirectGeometry_1.DirectGeometry(this.factory).fromGeometry(this);\n        // TODO: verify\n        // const buffergeometry = new BufferGeometry();\n        var buffergeometry = this.factory.newBufferGeometry();\n        var positions = new Float32Array(geometry.vertices.length * 3);\n        // TODO: verfify\n        // buffergeometry.setAttribute( 'position', new BufferAttribute( positions, 3 ).copyVector3sArray( geometry.vertices ) );\n        buffergeometry.setAttribute(\"position\", this.factory.newBufferAttribute(positions, 3).copyVector3sArray(geometry.vertices));\n        if (geometry.normals.length > 0) {\n            var normals = new Float32Array(geometry.normals.length * 3);\n            // TODO: verfify\n            // buffergeometry.setAttribute( 'normal', new BufferAttribute( normals, 3 ).copyVector3sArray( geometry.normals ) );\n            buffergeometry.setAttribute(\"normal\", this.factory.newBufferAttribute(normals, 3).copyVector3sArray(geometry.normals));\n        }\n        if (geometry.colors.length > 0) {\n            var colors = new Float32Array(geometry.colors.length * 3);\n            // TODO: verfify\n            // buffergeometry.setAttribute( 'color', new BufferAttribute( colors, 3 ).copyColorsArray( geometry.colors ) );\n            buffergeometry.setAttribute(\"color\", this.factory.newBufferAttribute(colors, 3).copyColorsArray(geometry.colors));\n        }\n        if (geometry.uvs.length > 0) {\n            var uvs = new Float32Array(geometry.uvs.length * 2);\n            // TODO: verfify\n            // buffergeometry.setAttribute( 'uv', new BufferAttribute( uvs, 2 ).copyVector2sArray( geometry.uvs ) );\n            buffergeometry.setAttribute(\"uv\", this.factory.newBufferAttribute(uvs, 2).copyVector2sArray(geometry.uvs));\n        }\n        if (geometry.uvs2.length > 0) {\n            var uvs2 = new Float32Array(geometry.uvs2.length * 2);\n            // TODO: verfify\n            // buffergeometry.setAttribute( 'uv2', new BufferAttribute( uvs2, 2 ).copyVector2sArray( geometry.uvs2 ) );\n            buffergeometry.setAttribute(\"uv2\", this.factory.newBufferAttribute(uvs2, 2).copyVector2sArray(geometry.uvs2));\n        }\n        // groups\n        buffergeometry.groups = geometry.groups;\n        // morphs\n        for (var name_1 in geometry.morphTargets) {\n            var array = [];\n            var morphTargets = geometry.morphTargets[name_1];\n            for (var i = 0, l = morphTargets.length; i < l; i++) {\n                var morphTarget = morphTargets[i];\n                // TODO: verify\n                // const attribute = new Float32BufferAttribute( morphTarget.data.length * 3, 3 );\n                var attribute = this.factory.newFloat32BufferAttribute(morphTarget.data.length * 3, 3);\n                attribute.name = morphTarget.name;\n                array.push(attribute.copyVector3sArray(morphTarget.data));\n            }\n            buffergeometry.morphAttributes[name_1] = array;\n        }\n        // skinning\n        if (geometry.skinIndices.length > 0) {\n            var skinIndices = this.factory.newFloat32BufferAttribute(geometry.skinIndices.length * 4, 4);\n            buffergeometry.setAttribute(\"skinIndex\", skinIndices.copyVector4sArray(geometry.skinIndices));\n        }\n        if (geometry.skinWeights.length > 0) {\n            var skinWeights = this.factory.newFloat32BufferAttribute(geometry.skinWeights.length * 4, 4);\n            buffergeometry.setAttribute(\"skinWeight\", skinWeights.copyVector4sArray(geometry.skinWeights));\n        }\n        //\n        if (geometry.boundingSphere !== null) {\n            buffergeometry.boundingSphere = geometry.boundingSphere.clone();\n        }\n        if (geometry.boundingBox !== null) {\n            buffergeometry.boundingBox = geometry.boundingBox.clone();\n        }\n        return buffergeometry;\n    };\n    Gmetry.prototype.computeTangents = function () {\n        console.error(\"THREE.Geometry: .computeTangents() has been removed.\");\n    };\n    Gmetry.prototype.computeLineDistances = function () {\n        console.error(\"THREE.Geometry: .computeLineDistances() has been removed. Use THREE.Line.computeLineDistances() instead.\");\n    };\n    Gmetry.prototype.applyMatrix = function (matrix) {\n        console.warn(\"THREE.Geometry: .applyMatrix() has been renamed to .applyMatrix4().\");\n        return this.applyMatrix4(matrix);\n    };\n    Gmetry.prototype.dispose = function () {\n        // This is not required when used outside of THREE.\n        // this.dispatchEvent( { type: 'dispose' } );\n    };\n    // TODO: can we specify and types for 'object' here?\n    Gmetry.createBufferGeometryFromObject = function (object, factory) {\n        var fact = factory || DefaultFactory_1.DefaultFactory;\n        var buffergeometry = fact.newBufferGeometry();\n        var geometry = object.geometry;\n        if (object.isPoints || object.isLine) {\n            var positions = fact.newFloat32BufferAttribute(geometry.vertices.length * 3, 3);\n            var colors = fact.newFloat32BufferAttribute(geometry.colors.length * 3, 3);\n            buffergeometry.setAttribute(\"position\", positions.copyVector3sArray(geometry.vertices));\n            buffergeometry.setAttribute(\"color\", colors.copyColorsArray(geometry.colors));\n            if (geometry.lineDistances && geometry.lineDistances.length === geometry.vertices.length) {\n                var lineDistances = fact.newFloat32BufferAttribute(geometry.lineDistances.length, 1);\n                buffergeometry.setAttribute(\"lineDistance\", lineDistances.copyArray(geometry.lineDistances));\n            }\n            if (geometry.boundingSphere !== null) {\n                buffergeometry.boundingSphere = geometry.boundingSphere.clone();\n            }\n            if (geometry.boundingBox !== null) {\n                buffergeometry.boundingBox = geometry.boundingBox.clone();\n            }\n        }\n        else if (object.isMesh) {\n            buffergeometry = geometry.toBufferGeometry();\n        }\n        return buffergeometry;\n    };\n    return Gmetry;\n}());\nexports.Gmetry = Gmetry;\n//# sourceMappingURL=Gmetry.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.ThreeGeometryHellfix = exports.Gmetry = exports.Face3 = exports.DirectGeometry = void 0;\nvar DirectGeometry_1 = require(\"./DirectGeometry\");\nObject.defineProperty(exports, \"DirectGeometry\", { enumerable: true, get: function () { return DirectGeometry_1.DirectGeometry; } });\nvar Face3_1 = require(\"./Face3\");\nObject.defineProperty(exports, \"Face3\", { enumerable: true, get: function () { return Face3_1.Face3; } });\nvar Gmetry_1 = require(\"./Gmetry\");\nObject.defineProperty(exports, \"Gmetry\", { enumerable: true, get: function () { return Gmetry_1.Gmetry; } });\nvar mylibrary_1 = require(\"./mylibrary\");\nObject.defineProperty(exports, \"ThreeGeometryHellfix\", { enumerable: true, get: function () { return mylibrary_1.ThreeGeometryHellfix; } });\n//# sourceMappingURL=index.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.ThreeGeometryHellfix = void 0;\nvar DefaultFactory_1 = require(\"./DefaultFactory\");\nvar DirectGeometry_1 = require(\"./DirectGeometry\");\nvar Face3_1 = require(\"./Face3\");\nvar Gmetry_1 = require(\"./Gmetry\");\nexports.ThreeGeometryHellfix = {\n    DirectGeometry: DirectGeometry_1.DirectGeometry,\n    Face3: Face3_1.Face3,\n    Gmetry: Gmetry_1.Gmetry,\n    DefaultFactory: DefaultFactory_1.DefaultFactory\n};\n//# sourceMappingURL=mylibrary.js.map","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// Expose all your components to the global scope here.\n\nglobalThis.ThreeGeometryHellfix = globalThis.TGH = require(\"./\").ThreeGeometryHellfix;\n"],"names":[],"sourceRoot":""}