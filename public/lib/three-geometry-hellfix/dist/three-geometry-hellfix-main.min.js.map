{"version":3,"file":"three-geometry-hellfix-main.min.js","mappings":"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","sources":["webpack://three-geometry-hellfix/./src/cjs/DefaultFactory.js","webpack://three-geometry-hellfix/./src/cjs/DirectGeometry.js","webpack://three-geometry-hellfix/./src/cjs/Face3.js","webpack://three-geometry-hellfix/./src/cjs/Gmetry.js","webpack://three-geometry-hellfix/./src/cjs/index.js","webpack://three-geometry-hellfix/./src/cjs/mylibrary.js","webpack://three-geometry-hellfix/webpack/bootstrap","webpack://three-geometry-hellfix/./src/cjs/entry.js"],"sourcesContent":["\"use strict\";\n/**\n * The default factory to connect to your three library.\n *\n * @author  Ikaros Kappler\n * @date    2022-02-20\n * @version 1.0.0\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.DefaultFactory = void 0;\nexports.DefaultFactory = {\n    newVector2: function (x, y) { return new window[\"THREE\"].Vector2(x, y); },\n    newVector3: function (x, y, z) { return new window[\"THREE\"].Vector3(x, y, z); },\n    newMatrix3: function () { return new window[\"THREE\"].Matrix3(); },\n    newMatrix4: function () { return new window[\"THREE\"].Matrix4(); },\n    newObject3D: function () { return new window[\"THREE\"].Object3D(); },\n    newBox3: function () { return new window[\"THREE\"].Box3(); },\n    newSphere: function () { return new window[\"THREE\"].Sphere(); },\n    newBufferGeometry: function () { return new window[\"THREE\"].BufferGeometry(); },\n    generateUUID: function () { return window[\"THREE\"].MathUtils.generateUUID(); },\n    newFloat32BufferAttribute: function (array, itemSize, normalized) { return new window[\"THREE\"].Float32BufferAttribute(array, itemSize, normalized); },\n    newColor: function () { return new window[\"THREE\"].Color; },\n    newBufferAttribute: function (array, itemSize, normalized) { return new window[\"THREE\"].BufferAttribute(array, itemSize, normalized); }\n};\n//# sourceMappingURL=DefaultFactory.js.map","\"use strict\";\n/**\n * THE ORIGINAL SOURCE COOE IS HERE:\n *    https://github.com/mrdoob/three.js/blob/dev/examples/jsm/deprecated/Geometry.js\n *\n * This is a backport of the old (deprecated) THREE.DirectGeometry class.\n *\n * It got deprecated in version r125 and was announced to be completely dropped in future versions.\n *\n * As it was a very useful class I wanted to preserve it for some of my projects which depend on it.\n *\n * And here this is a Typescript port, too. Enjoy!\n *    - Ikaros Kappler\n *\n * @date 2022-02-11\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.DirectGeometry = void 0;\nvar DefaultFactory_1 = require(\"./DefaultFactory\");\nvar DirectGeometry = /** @class */ (function () {\n    function DirectGeometry(factory) {\n        this.vertices = [];\n        this.normals = [];\n        this.colors = [];\n        this.uvs = [];\n        this.uvs2 = [];\n        this.groups = [];\n        this.morphTargets = {};\n        this.skinWeights = [];\n        this.skinIndices = [];\n        // this.lineDistances = [];\n        this.boundingBox = null;\n        this.boundingSphere = null;\n        // update flags\n        this.verticesNeedUpdate = false;\n        this.normalsNeedUpdate = false;\n        this.colorsNeedUpdate = false;\n        this.uvsNeedUpdate = false;\n        this.groupsNeedUpdate = false;\n        // this.isGeometry = true;\n        this.factory = factory || DefaultFactory_1.DefaultFactory;\n    }\n    DirectGeometry.prototype.computeGroups = function (geometry) {\n        var groups = [];\n        var group;\n        var i;\n        var materialIndex = undefined;\n        var faces = geometry.faces;\n        for (i = 0; i < faces.length; i++) {\n            var face = faces[i];\n            // materials\n            if (face.materialIndex !== materialIndex) {\n                materialIndex = face.materialIndex;\n                if (group !== undefined) {\n                    group.count = i * 3 - group.start;\n                    groups.push(group);\n                }\n                group = {\n                    start: i * 3,\n                    materialIndex: materialIndex\n                };\n            }\n        }\n        if (group !== undefined) {\n            group.count = i * 3 - group.start;\n            groups.push(group);\n        }\n        this.groups = groups;\n    };\n    DirectGeometry.prototype.fromGeometry = function (geometry) {\n        var faces = geometry.faces;\n        var vertices = geometry.vertices;\n        var faceVertexUvs = geometry.faceVertexUvs;\n        var hasFaceVertexUv = faceVertexUvs[0] && faceVertexUvs[0].length > 0;\n        var hasFaceVertexUv2 = faceVertexUvs[1] && faceVertexUvs[1].length > 0;\n        // morphs\n        var morphTargets = geometry.morphTargets;\n        var morphTargetsLength = morphTargets.length;\n        var morphTargetsPosition;\n        if (morphTargetsLength > 0) {\n            morphTargetsPosition = [];\n            for (var i = 0; i < morphTargetsLength; i++) {\n                morphTargetsPosition[i] = {\n                    name: morphTargets[i].name,\n                    data: []\n                };\n            }\n            // TODO: here seems to be something wrong with the types\n            this.morphTargets.position = morphTargetsPosition;\n        }\n        var morphNormals = geometry.morphNormals;\n        var morphNormalsLength = morphNormals.length;\n        var morphTargetsNormal;\n        if (morphNormalsLength > 0) {\n            morphTargetsNormal = [];\n            for (var i = 0; i < morphNormalsLength; i++) {\n                morphTargetsNormal[i] = {\n                    name: morphNormals[i].name,\n                    data: []\n                };\n            }\n            this.morphTargets.normal = morphTargetsNormal;\n        }\n        // skins\n        var skinIndices = geometry.skinIndices;\n        var skinWeights = geometry.skinWeights;\n        var hasSkinIndices = skinIndices.length === vertices.length;\n        var hasSkinWeights = skinWeights.length === vertices.length;\n        //\n        if (vertices.length > 0 && faces.length === 0) {\n            console.error(\"THREE.DirectGeometry: Faceless geometries are not supported.\");\n        }\n        for (var i = 0; i < faces.length; i++) {\n            var face = faces[i];\n            this.vertices.push(vertices[face.a], vertices[face.b], vertices[face.c]);\n            var vertexNormals = face.vertexNormals;\n            if (vertexNormals.length === 3) {\n                this.normals.push(vertexNormals[0], vertexNormals[1], vertexNormals[2]);\n            }\n            else {\n                var normal = face.normal;\n                this.normals.push(normal, normal, normal);\n            }\n            var vertexColors = face.vertexColors;\n            if (vertexColors.length === 3) {\n                this.colors.push(vertexColors[0], vertexColors[1], vertexColors[2]);\n            }\n            else {\n                var color = face.color;\n                this.colors.push(color, color, color);\n            }\n            if (hasFaceVertexUv === true) {\n                var vertexUvs = faceVertexUvs[0][i];\n                if (vertexUvs !== undefined) {\n                    this.uvs.push(vertexUvs[0], vertexUvs[1], vertexUvs[2]);\n                }\n                else {\n                    console.warn(\"THREE.DirectGeometry.fromGeometry(): Undefined vertexUv \", i);\n                    // TODO: verify\n                    // this.uvs.push( new Vector2(), new Vector2(), new Vector2() );\n                    this.uvs.push(this.factory.newVector2(), this.factory.newVector2(), this.factory.newVector2());\n                }\n            }\n            if (hasFaceVertexUv2 === true) {\n                var vertexUvs = faceVertexUvs[1][i];\n                if (vertexUvs !== undefined) {\n                    this.uvs2.push(vertexUvs[0], vertexUvs[1], vertexUvs[2]);\n                }\n                else {\n                    console.warn(\"THREE.DirectGeometry.fromGeometry(): Undefined vertexUv2 \", i);\n                    // TODO: verify\n                    // this.uvs2.push( new Vector2(), new Vector2(), new Vector2() );\n                    this.uvs2.push(this.factory.newVector2(), this.factory.newVector2(), this.factory.newVector2());\n                }\n            }\n            // morphs\n            for (var j = 0; j < morphTargetsLength; j++) {\n                var morphTarget = morphTargets[j].vertices;\n                morphTargetsPosition[j].data.push(morphTarget[face.a], morphTarget[face.b], morphTarget[face.c]);\n            }\n            for (var j = 0; j < morphNormalsLength; j++) {\n                var morphNormal = morphNormals[j].vertexNormals[i];\n                morphTargetsNormal[j].data.push(morphNormal.a, morphNormal.b, morphNormal.c);\n            }\n            // skins\n            if (hasSkinIndices) {\n                this.skinIndices.push(skinIndices[face.a], skinIndices[face.b], skinIndices[face.c]);\n            }\n            if (hasSkinWeights) {\n                this.skinWeights.push(skinWeights[face.a], skinWeights[face.b], skinWeights[face.c]);\n            }\n        }\n        this.computeGroups(geometry);\n        this.verticesNeedUpdate = geometry.verticesNeedUpdate;\n        this.normalsNeedUpdate = geometry.normalsNeedUpdate;\n        this.colorsNeedUpdate = geometry.colorsNeedUpdate;\n        this.uvsNeedUpdate = geometry.uvsNeedUpdate;\n        this.groupsNeedUpdate = geometry.groupsNeedUpdate;\n        if (geometry.boundingSphere !== null) {\n            this.boundingSphere = geometry.boundingSphere.clone();\n        }\n        if (geometry.boundingBox !== null) {\n            this.boundingBox = geometry.boundingBox.clone();\n        }\n        return this;\n    };\n    return DirectGeometry;\n}());\nexports.DirectGeometry = DirectGeometry;\n//# sourceMappingURL=DirectGeometry.js.map","\"use strict\";\n/**\n * THE ORIGINAL SOURCE COOE IS HERE:\n *    https://github.com/mrdoob/three.js/blob/dev/examples/jsm/deprecated/Geometry.js\n *\n * This is a backport of the old (deprecated) THREE.Face3 class.\n *\n * It got deprecated in version r125 and was announced to be completely dropped in future versions.\n *\n * As it was a very useful class I wanted to preserve it for some of my projects which depend on it.\n *\n * And here this is a Typescript port, too. Enjoy!\n *    - Ikaros Kappler\n *\n * @date 2022-02-11\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Face3 = void 0;\nvar DefaultFactory_1 = require(\"./DefaultFactory\");\nvar Face3 = /** @class */ (function () {\n    function Face3(a, b, c, normal, color, materialIndex, factory) {\n        if (materialIndex === void 0) { materialIndex = 0; }\n        var fact = factory || DefaultFactory_1.DefaultFactory;\n        this.a = a;\n        this.b = b;\n        this.c = c;\n        // this.normal = ( normal && normal.isVector3 ) ? normal : new THREE.Vector3();\n        // this.vertexNormals = Array.isArray( normal ) ? normal : [];\n        // TODO: verify correctness\n        // this.normal = ( normal && (normal instanceof Vector3 && normal.isVector3) ) ? normal : new Vector3();\n        // TODO: use DefaultFactory here\n        // this.normal = ( normal && (normal instanceof Vector3 && normal.isVector3) ) ? normal : new (window[\"THREE\"]).Vector3();\n        this.normal = normal && normal.isVector3 ? normal : fact.newVector3();\n        this.vertexNormals = Array.isArray(normal) ? normal : [];\n        // this.color = ( color && color.isColor ) ? color : new THREE.Color();\n        // this.color = ( color && ( color instanceof Color && color.isColor)  ) ? color : new Color(); // TODO: verify correctness\n        // TODO: use DefaultFactory here\n        this.color = color && color.isColor ? color : fact.newColor(); // TODO: verify correctness\n        this.vertexColors = Array.isArray(color) ? color : [];\n        this.materialIndex = materialIndex;\n    }\n    Face3.prototype.clone = function () {\n        // TODO: check if new expression is correct\n        // return new this.constructor().copy( this );\n        return new Face3(this.a, this.b, this.c, this.normal.clone(), this.color.clone(), this.materialIndex).copy(this);\n    };\n    Face3.prototype.copy = function (source) {\n        this.a = source.a;\n        this.b = source.b;\n        this.c = source.c;\n        this.normal.copy(source.normal);\n        this.color.copy(source.color);\n        this.materialIndex = source.materialIndex;\n        for (var i = 0, il = source.vertexNormals.length; i < il; i++) {\n            this.vertexNormals[i] = source.vertexNormals[i].clone();\n        }\n        for (var i = 0, il = source.vertexColors.length; i < il; i++) {\n            this.vertexColors[i] = source.vertexColors[i].clone();\n        }\n        return this;\n    };\n    return Face3;\n}());\nexports.Face3 = Face3;\n//# sourceMappingURL=Face3.js.map","\"use strict\";\n/**\n * THE ORIGINAL SOURCE COOE IS HERE:\n *    https://github.com/mrdoob/three.js/blob/dev/examples/jsm/deprecated/Geometry.js\n *\n * This is a backport of the old (deprecated) THREE.Face3 class.\n *\n * It got deprecated in version r125 and was announced to be completely dropped in future versions.\n *\n * As it was a very useful class I wanted to preserve it for some of my projects which depend on it.\n *\n * And here this is a Typescript port, too. Enjoy!\n *    - Ikaros Kappler\n *\n * @date 2022-02-11\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Gmetry = void 0;\nvar DefaultFactory_1 = require(\"./DefaultFactory\");\nvar DirectGeometry_1 = require(\"./DirectGeometry\");\nvar Face3_1 = require(\"./Face3\");\nvar Gmetry = /** @class */ (function () {\n    /**\n     * Construct a new Gmetry.\n     *\n     * @param {ThreeFactory?} factory - Specify a custom factory if you do not want to use the DefaultFactory.\n     */\n    function Gmetry(factory) {\n        this.name = \"\";\n        this.type = \"Geometry\";\n        this.vertices = [];\n        this.colors = [];\n        this.faces = [];\n        this.faceVertexUvs = [[]];\n        this.morphTargets = [];\n        this.morphNormals = [];\n        this.skinWeights = [];\n        this.skinIndices = [];\n        this.lineDistances = [];\n        this.boundingBox = null;\n        this.boundingSphere = null;\n        // update flags\n        this.elementsNeedUpdate = false;\n        this.verticesNeedUpdate = false;\n        this.uvsNeedUpdate = false;\n        this.normalsNeedUpdate = false;\n        this.colorsNeedUpdate = false;\n        this.lineDistancesNeedUpdate = false;\n        this.groupsNeedUpdate = false;\n        this.isGeometry = true;\n        this.factory = factory || DefaultFactory_1.DefaultFactory;\n        this.uuid = this.factory.generateUUID();\n        this._m1 = this.factory.newMatrix4();\n        this._obj = this.factory.newObject3D();\n        this._offset = this.factory.newVector3();\n    }\n    Gmetry.prototype.applyMatrix4 = function (matrix) {\n        var normalMatrix = this.factory.newMatrix3().getNormalMatrix(matrix);\n        for (var i = 0, il = this.vertices.length; i < il; i++) {\n            var vertex = this.vertices[i];\n            vertex.applyMatrix4(matrix);\n        }\n        for (var i = 0, il = this.faces.length; i < il; i++) {\n            var face = this.faces[i];\n            face.normal.applyMatrix3(normalMatrix).normalize();\n            for (var j = 0, jl = face.vertexNormals.length; j < jl; j++) {\n                face.vertexNormals[j].applyMatrix3(normalMatrix).normalize();\n            }\n        }\n        if (this.boundingBox !== null) {\n            this.computeBoundingBox();\n        }\n        if (this.boundingSphere !== null) {\n            this.computeBoundingSphere();\n        }\n        this.verticesNeedUpdate = true;\n        this.normalsNeedUpdate = true;\n        return this;\n    };\n    Gmetry.prototype.rotateX = function (angle) {\n        // rotate geometry around world x-axis\n        this._m1.makeRotationX(angle);\n        this.applyMatrix4(this._m1);\n        return this;\n    };\n    Gmetry.prototype.rotateY = function (angle) {\n        // rotate geometry around world y-axis\n        this._m1.makeRotationY(angle);\n        this.applyMatrix4(this._m1);\n        return this;\n    };\n    Gmetry.prototype.rotateZ = function (angle) {\n        // rotate geometry around world z-axis\n        this._m1.makeRotationZ(angle);\n        this.applyMatrix4(this._m1);\n        return this;\n    };\n    Gmetry.prototype.translate = function (x, y, z) {\n        // translate geometry\n        this._m1.makeTranslation(x, y, z);\n        this.applyMatrix4(this._m1);\n        return this;\n    };\n    Gmetry.prototype.scale = function (x, y, z) {\n        // scale geometry\n        this._m1.makeScale(x, y, z);\n        this.applyMatrix4(this._m1);\n        return this;\n    };\n    Gmetry.prototype.lookAt = function (vector) {\n        this._obj.lookAt(vector);\n        this._obj.updateMatrix();\n        this.applyMatrix4(this._obj.matrix);\n        return this;\n    };\n    Gmetry.prototype.fromBufferGeometry = function (geometry) {\n        var scope = this;\n        var index = geometry.index !== null ? geometry.index : undefined;\n        var attributes = geometry.attributes;\n        if (attributes.position === undefined) {\n            console.error(\"THREE.Geometry.fromBufferGeometry(): Position attribute required for conversion.\");\n            return this;\n        }\n        var position = attributes.position;\n        var normal = attributes.normal;\n        var color = attributes.color;\n        var uv = attributes.uv;\n        var uv2 = attributes.uv2;\n        if (uv2 !== undefined)\n            this.faceVertexUvs[1] = [];\n        for (var i = 0; i < position.count; i++) {\n            scope.vertices.push(this.factory.newVector3().fromBufferAttribute(position, i));\n            if (color !== undefined) {\n                scope.colors.push(this.factory.newColor().fromBufferAttribute(color, i));\n            }\n        }\n        var factory = this.factory;\n        // TODO: put to helper functions\n        var addFace = function (a, b, c, materialIndex) {\n            var vertexColors = color === undefined ? [] : [scope.colors[a].clone(), scope.colors[b].clone(), scope.colors[c].clone()];\n            var vertexNormals = normal === undefined\n                ? []\n                : [\n                    factory.newVector3().fromBufferAttribute(normal, a),\n                    factory.newVector3().fromBufferAttribute(normal, b),\n                    factory.newVector3().fromBufferAttribute(normal, c)\n                ];\n            var face = new Face3_1.Face3(a, b, c, vertexNormals, vertexColors, materialIndex);\n            scope.faces.push(face);\n            if (uv !== undefined) {\n                scope.faceVertexUvs[0].push([\n                    factory.newVector2().fromBufferAttribute(uv, a),\n                    factory.newVector2().fromBufferAttribute(uv, b),\n                    factory.newVector2().fromBufferAttribute(uv, c)\n                ]);\n            }\n            if (uv2 !== undefined) {\n                scope.faceVertexUvs[1].push([\n                    factory.newVector2().fromBufferAttribute(uv2, a),\n                    factory.newVector2().fromBufferAttribute(uv2, b),\n                    factory.newVector2().fromBufferAttribute(uv2, c)\n                ]);\n            }\n        };\n        var groups = geometry.groups;\n        if (groups.length > 0) {\n            for (var i = 0; i < groups.length; i++) {\n                var group = groups[i];\n                var start = group.start;\n                var count = group.count;\n                for (var j = start, jl = start + count; j < jl; j += 3) {\n                    if (index !== undefined) {\n                        addFace(index.getX(j), index.getX(j + 1), index.getX(j + 2), group.materialIndex);\n                    }\n                    else {\n                        addFace(j, j + 1, j + 2, group.materialIndex);\n                    }\n                }\n            }\n        }\n        else {\n            if (index !== undefined) {\n                for (var i = 0; i < index.count; i += 3) {\n                    addFace(index.getX(i), index.getX(i + 1), index.getX(i + 2));\n                }\n            }\n            else {\n                for (var i = 0; i < position.count; i += 3) {\n                    addFace(i, i + 1, i + 2);\n                }\n            }\n        }\n        this.computeFaceNormals();\n        if (geometry.boundingBox !== null) {\n            this.boundingBox = geometry.boundingBox.clone();\n        }\n        if (geometry.boundingSphere !== null) {\n            this.boundingSphere = geometry.boundingSphere.clone();\n        }\n        return this;\n    };\n    Gmetry.prototype.center = function () {\n        this.computeBoundingBox();\n        this.boundingBox.getCenter(this._offset).negate();\n        this.translate(this._offset.x, this._offset.y, this._offset.z);\n        return this;\n    };\n    Gmetry.prototype.normalize = function () {\n        this.computeBoundingSphere();\n        var center = this.boundingSphere.center;\n        var radius = this.boundingSphere.radius;\n        var s = radius === 0 ? 1 : 1.0 / radius;\n        var matrix = this.factory.newMatrix4();\n        matrix.set(s, 0, 0, -s * center.x, 0, s, 0, -s * center.y, 0, 0, s, -s * center.z, 0, 0, 0, 1);\n        this.applyMatrix4(matrix);\n        return this;\n    };\n    Gmetry.prototype.computeFaceNormals = function () {\n        var cb = this.factory.newVector3(), ab = this.factory.newVector3();\n        for (var f = 0, fl = this.faces.length; f < fl; f++) {\n            var face = this.faces[f];\n            var vA = this.vertices[face.a];\n            var vB = this.vertices[face.b];\n            var vC = this.vertices[face.c];\n            cb.subVectors(vC, vB);\n            ab.subVectors(vA, vB);\n            cb.cross(ab);\n            cb.normalize();\n            face.normal.copy(cb);\n        }\n    };\n    Gmetry.prototype.computeVertexNormals = function (areaWeighted) {\n        if (areaWeighted === void 0) { areaWeighted = true; }\n        var vertices = new Array(this.vertices.length);\n        for (var v = 0, vl = this.vertices.length; v < vl; v++) {\n            // TODO: verify\n            // vertices[ v ] = new Vector3();\n            vertices[v] = this.factory.newVector3();\n        }\n        if (areaWeighted) {\n            // vertex normals weighted by triangle areas\n            // http://www.iquilezles.org/www/articles/normals/normals.htm\n            // TODO: verify\n            // const cb = new Vector3(), ab = new Vector3();\n            var cb = this.factory.newVector3(), ab = this.factory.newVector3();\n            for (var f = 0, fl = this.faces.length; f < fl; f++) {\n                var face = this.faces[f];\n                var vA = this.vertices[face.a];\n                var vB = this.vertices[face.b];\n                var vC = this.vertices[face.c];\n                cb.subVectors(vC, vB);\n                ab.subVectors(vA, vB);\n                cb.cross(ab);\n                vertices[face.a].add(cb);\n                vertices[face.b].add(cb);\n                vertices[face.c].add(cb);\n            }\n        }\n        else {\n            this.computeFaceNormals();\n            for (var f = 0, fl = this.faces.length; f < fl; f++) {\n                var face = this.faces[f];\n                vertices[face.a].add(face.normal);\n                vertices[face.b].add(face.normal);\n                vertices[face.c].add(face.normal);\n            }\n        }\n        for (var v = 0, vl = this.vertices.length; v < vl; v++) {\n            vertices[v].normalize();\n        }\n        for (var f = 0, fl = this.faces.length; f < fl; f++) {\n            var face = this.faces[f];\n            var vertexNormals = face.vertexNormals;\n            if (vertexNormals.length === 3) {\n                vertexNormals[0].copy(vertices[face.a]);\n                vertexNormals[1].copy(vertices[face.b]);\n                vertexNormals[2].copy(vertices[face.c]);\n            }\n            else {\n                vertexNormals[0] = vertices[face.a].clone();\n                vertexNormals[1] = vertices[face.b].clone();\n                vertexNormals[2] = vertices[face.c].clone();\n            }\n        }\n        if (this.faces.length > 0) {\n            this.normalsNeedUpdate = true;\n        }\n    };\n    Gmetry.prototype.computeFlatVertexNormals = function () {\n        this.computeFaceNormals();\n        for (var f = 0, fl = this.faces.length; f < fl; f++) {\n            var face = this.faces[f];\n            var vertexNormals = face.vertexNormals;\n            if (vertexNormals.length === 3) {\n                vertexNormals[0].copy(face.normal);\n                vertexNormals[1].copy(face.normal);\n                vertexNormals[2].copy(face.normal);\n            }\n            else {\n                vertexNormals[0] = face.normal.clone();\n                vertexNormals[1] = face.normal.clone();\n                vertexNormals[2] = face.normal.clone();\n            }\n        }\n        if (this.faces.length > 0) {\n            this.normalsNeedUpdate = true;\n        }\n    };\n    Gmetry.prototype.computeMorphNormals = function () {\n        // save original normals\n        // - create temp variables on first access\n        //   otherwise just copy (for faster repeated calls)\n        for (var f = 0, fl = this.faces.length; f < fl; f++) {\n            var face = this.faces[f];\n            if (!face.__originalFaceNormal) {\n                face.__originalFaceNormal = face.normal.clone();\n            }\n            else {\n                face.__originalFaceNormal.copy(face.normal);\n            }\n            if (!face.__originalVertexNormals)\n                face.__originalVertexNormals = [];\n            for (var i = 0, il = face.vertexNormals.length; i < il; i++) {\n                if (!face.__originalVertexNormals[i]) {\n                    face.__originalVertexNormals[i] = face.vertexNormals[i].clone();\n                }\n                else {\n                    face.__originalVertexNormals[i].copy(face.vertexNormals[i]);\n                }\n            }\n        }\n        // use temp geometry to compute face and vertex normals for each morph\n        var tmpGeo = new Gmetry(this.factory);\n        tmpGeo.faces = this.faces;\n        for (var i = 0, il = this.morphTargets.length; i < il; i++) {\n            // create on first access\n            if (!this.morphNormals[i]) {\n                this.morphNormals[i] = {}; // TODO: check\n                this.morphNormals[i].faceNormals = [];\n                this.morphNormals[i].vertexNormals = [];\n                var dstNormalsFace = this.morphNormals[i].faceNormals;\n                var dstNormalsVertex = this.morphNormals[i].vertexNormals;\n                for (var f = 0, fl = this.faces.length; f < fl; f++) {\n                    var faceNormal = this.factory.newVector3();\n                    var vertexNormals = { a: this.factory.newVector3(), b: this.factory.newVector3(), c: this.factory.newVector3() };\n                    dstNormalsFace.push(faceNormal);\n                    dstNormalsVertex.push(vertexNormals);\n                }\n            }\n            var morphNormals = this.morphNormals[i];\n            // set vertices to morph target\n            tmpGeo.vertices = this.morphTargets[i].vertices;\n            // compute morph normals\n            tmpGeo.computeFaceNormals();\n            tmpGeo.computeVertexNormals();\n            // store morph normals\n            for (var f = 0, fl = this.faces.length; f < fl; f++) {\n                var face = this.faces[f];\n                var faceNormal = morphNormals.faceNormals[f];\n                var vertexNormals = morphNormals.vertexNormals[f];\n                faceNormal.copy(face.normal);\n                vertexNormals.a.copy(face.vertexNormals[0]);\n                vertexNormals.b.copy(face.vertexNormals[1]);\n                vertexNormals.c.copy(face.vertexNormals[2]);\n            }\n        }\n        // restore original normals\n        for (var f = 0, fl = this.faces.length; f < fl; f++) {\n            var face = this.faces[f];\n            face.normal = face.__originalFaceNormal;\n            face.vertexNormals = face.__originalVertexNormals;\n        }\n    };\n    Gmetry.prototype.computeBoundingBox = function () {\n        if (this.boundingBox === null) {\n            this.boundingBox = this.factory.newBox3();\n        }\n        this.boundingBox.setFromPoints(this.vertices);\n    };\n    Gmetry.prototype.computeBoundingSphere = function () {\n        if (this.boundingSphere === null) {\n            this.boundingSphere = this.factory.newSphere();\n        }\n        this.boundingSphere.setFromPoints(this.vertices);\n    };\n    Gmetry.prototype.merge = function (geometry, matrix, materialIndexOffset) {\n        if (materialIndexOffset === void 0) { materialIndexOffset = 0; }\n        if (!(geometry && geometry.isGeometry)) {\n            console.error(\"THREE.Geometry.merge(): geometry not an instance of THREE.Geometry.\", geometry);\n            return;\n        }\n        var normalMatrix;\n        var vertexOffset = this.vertices.length, vertices1 = this.vertices, vertices2 = geometry.vertices, faces1 = this.faces, faces2 = geometry.faces, colors1 = this.colors, colors2 = geometry.colors;\n        if (matrix !== undefined) {\n            normalMatrix = this.factory.newMatrix3().getNormalMatrix(matrix);\n        }\n        // vertices\n        for (var i = 0, il = vertices2.length; i < il; i++) {\n            var vertex = vertices2[i];\n            var vertexCopy = vertex.clone();\n            if (matrix !== undefined) {\n                vertexCopy.applyMatrix4(matrix);\n            }\n            vertices1.push(vertexCopy);\n        }\n        // colors\n        for (var i = 0, il = colors2.length; i < il; i++) {\n            colors1.push(colors2[i].clone());\n        }\n        // faces\n        for (var i = 0, il = faces2.length; i < il; i++) {\n            var face = faces2[i];\n            var normal = void 0;\n            var color = void 0;\n            var faceVertexNormals = face.vertexNormals, faceVertexColors = face.vertexColors;\n            var faceCopy = new Face3_1.Face3(face.a + vertexOffset, face.b + vertexOffset, face.c + vertexOffset);\n            faceCopy.normal.copy(face.normal);\n            if (normalMatrix !== undefined) {\n                faceCopy.normal.applyMatrix3(normalMatrix).normalize();\n            }\n            for (var j = 0, jl = faceVertexNormals.length; j < jl; j++) {\n                normal = faceVertexNormals[j].clone();\n                if (normalMatrix !== undefined) {\n                    normal.applyMatrix3(normalMatrix).normalize();\n                }\n                faceCopy.vertexNormals.push(normal);\n            }\n            faceCopy.color.copy(face.color);\n            for (var j = 0, jl = faceVertexColors.length; j < jl; j++) {\n                color = faceVertexColors[j];\n                faceCopy.vertexColors.push(color.clone());\n            }\n            faceCopy.materialIndex = face.materialIndex + materialIndexOffset;\n            faces1.push(faceCopy);\n        }\n        // uvs\n        for (var i = 0, il = geometry.faceVertexUvs.length; i < il; i++) {\n            var faceVertexUvs2 = geometry.faceVertexUvs[i];\n            if (this.faceVertexUvs[i] === undefined) {\n                this.faceVertexUvs[i] = [];\n            }\n            for (var j = 0, jl = faceVertexUvs2.length; j < jl; j++) {\n                var uvs2 = faceVertexUvs2[j], uvsCopy = [];\n                for (var k = 0, kl = uvs2.length; k < kl; k++) {\n                    uvsCopy.push(uvs2[k].clone());\n                }\n                this.faceVertexUvs[i].push(uvsCopy); // TODO: check\n            }\n        }\n    };\n    // TODO: the new version of Mesh operates on BufferGeometry\n    Gmetry.prototype.mergeMesh = function (mesh) {\n        if (!(mesh && mesh.isMesh)) {\n            console.error(\"THREE.Geometry.mergeMesh(): mesh not an instance of THREE.Mesh.\", mesh);\n            return;\n        }\n        if (mesh.matrixAutoUpdate) {\n            mesh.updateMatrix();\n        }\n        this.merge(mesh.geometry, mesh.matrix);\n    };\n    /*\n     * Checks for duplicate vertices with hashmap.\n     * Duplicated vertices are removed\n     * and faces' vertices are updated.\n     */\n    Gmetry.prototype.mergeVertices = function (precisionPoints) {\n        if (precisionPoints === void 0) { precisionPoints = 4; }\n        var verticesMap = {}; // Hashmap for looking up vertices by position coordinates (and making sure they are unique)\n        var unique = [], changes = [];\n        var precision = Math.pow(10, precisionPoints);\n        for (var i = 0, il = this.vertices.length; i < il; i++) {\n            var v = this.vertices[i];\n            var key = Math.round(v.x * precision) + \"_\" + Math.round(v.y * precision) + \"_\" + Math.round(v.z * precision);\n            if (verticesMap[key] === undefined) {\n                verticesMap[key] = i;\n                unique.push(this.vertices[i]);\n                changes[i] = unique.length - 1;\n            }\n            else {\n                //console.log('Duplicate vertex found. ', i, ' could be using ', verticesMap[key]);\n                changes[i] = changes[verticesMap[key]];\n            }\n        }\n        // if faces are completely degenerate after merging vertices, we\n        // have to remove them from the geometry.\n        var faceIndicesToRemove = [];\n        for (var i = 0, il = this.faces.length; i < il; i++) {\n            var face = this.faces[i];\n            face.a = changes[face.a];\n            face.b = changes[face.b];\n            face.c = changes[face.c];\n            var indices = [face.a, face.b, face.c];\n            // if any duplicate vertices are found in a Face3\n            // we have to remove the face as nothing can be saved\n            for (var n = 0; n < 3; n++) {\n                if (indices[n] === indices[(n + 1) % 3]) {\n                    faceIndicesToRemove.push(i);\n                    break;\n                }\n            }\n        }\n        for (var i = faceIndicesToRemove.length - 1; i >= 0; i--) {\n            var idx = faceIndicesToRemove[i];\n            this.faces.splice(idx, 1);\n            for (var j = 0, jl = this.faceVertexUvs.length; j < jl; j++) {\n                this.faceVertexUvs[j].splice(idx, 1);\n            }\n        }\n        // Use unique set of vertices\n        var diff = this.vertices.length - unique.length;\n        this.vertices = unique;\n        return diff;\n    };\n    Gmetry.prototype.setFromPoints = function (points) {\n        this.vertices = [];\n        for (var i = 0, l = points.length; i < l; i++) {\n            var point = points[i];\n            // TODO: verify\n            // this.vertices.push( new Vector3( point.x, point.y, point.z || 0 ) );\n            //   this.vertices.push(this.factory.newVector3(point.x, point.y, point.z || 0));\n            this.vertices.push(this.factory.newVector3(point.x, point.y, point.z || 0));\n        }\n        return this;\n    };\n    Gmetry.prototype.sortFacesByMaterialIndex = function () {\n        var faces = this.faces;\n        var length = faces.length;\n        // tag faces\n        for (var i = 0; i < length; i++) {\n            faces[i]._id = i;\n        }\n        // sort faces\n        function materialIndexSort(a, b) {\n            return a.materialIndex - b.materialIndex;\n        }\n        faces.sort(materialIndexSort);\n        // sort uvs\n        var uvs1 = this.faceVertexUvs[0];\n        var uvs2 = this.faceVertexUvs[1];\n        var newUvs1, newUvs2;\n        if (uvs1 && uvs1.length === length) {\n            newUvs1 = [];\n        }\n        if (uvs2 && uvs2.length === length) {\n            newUvs2 = [];\n        }\n        for (var i = 0; i < length; i++) {\n            var id = faces[i]._id;\n            if (newUvs1)\n                newUvs1.push(uvs1[id]);\n            if (newUvs2)\n                newUvs2.push(uvs2[id]);\n        }\n        if (newUvs1) {\n            this.faceVertexUvs[0] = newUvs1;\n        }\n        if (newUvs2) {\n            this.faceVertexUvs[1] = newUvs2;\n        }\n    };\n    Gmetry.prototype.toJSON = function () {\n        var data = {\n            metadata: {\n                version: 4.5,\n                type: \"Geometry\",\n                generator: \"Geometry.toJSON\"\n            },\n            // TODO: check\n            uuid: null,\n            type: null,\n            name: null,\n            data: null\n        };\n        // standard Geometry serialization\n        data.uuid = this.uuid;\n        data.type = this.type;\n        if (this.name !== \"\")\n            data.name = this.name;\n        if (this.parameters !== undefined) {\n            var parameters = this.parameters;\n            for (var key in parameters) {\n                if (parameters[key] !== undefined)\n                    data[key] = parameters[key];\n            }\n            return data;\n        }\n        var vertices = [];\n        for (var i = 0; i < this.vertices.length; i++) {\n            var vertex = this.vertices[i];\n            vertices.push(vertex.x, vertex.y, vertex.z);\n        }\n        var faces = [];\n        var normals = [];\n        var normalsHash = {};\n        var colors = [];\n        var colorsHash = {};\n        var uvs = [];\n        var uvsHash = {};\n        for (var i = 0; i < this.faces.length; i++) {\n            var face = this.faces[i];\n            var hasMaterial = true;\n            var hasFaceUv = false; // deprecated\n            var hasFaceVertexUv = this.faceVertexUvs[0][i] !== undefined;\n            var hasFaceNormal = face.normal.length() > 0;\n            var hasFaceVertexNormal = face.vertexNormals.length > 0;\n            var hasFaceColor = face.color.r !== 1 || face.color.g !== 1 || face.color.b !== 1;\n            var hasFaceVertexColor = face.vertexColors.length > 0;\n            var faceType = 0;\n            // TODO: move to helpers?\n            var setBit = function (value, position, enabled) {\n                return enabled ? value | (1 << position) : value & ~(1 << position);\n            };\n            // TODO: move to helpers?\n            var getNormalIndex = function (normal) {\n                var hash = normal.x.toString() + normal.y.toString() + normal.z.toString();\n                if (normalsHash[hash] !== undefined) {\n                    return normalsHash[hash];\n                }\n                normalsHash[hash] = normals.length / 3;\n                normals.push(normal.x, normal.y, normal.z);\n                return normalsHash[hash];\n            };\n            // TODO: move to helpers?\n            var getColorIndex = function (color) {\n                var hash = color.r.toString() + color.g.toString() + color.b.toString();\n                if (colorsHash[hash] !== undefined) {\n                    return colorsHash[hash];\n                }\n                colorsHash[hash] = colors.length;\n                colors.push(color.getHex());\n                return colorsHash[hash];\n            };\n            // TODO: move to helpers?\n            var getUvIndex = function (uv) {\n                var hash = uv.x.toString() + uv.y.toString();\n                if (uvsHash[hash] !== undefined) {\n                    return uvsHash[hash];\n                }\n                uvsHash[hash] = uvs.length / 2;\n                uvs.push(uv.x, uv.y);\n                return uvsHash[hash];\n            };\n            faceType = setBit(faceType, 0, 0); // isQuad\n            faceType = setBit(faceType, 1, hasMaterial);\n            faceType = setBit(faceType, 2, hasFaceUv);\n            faceType = setBit(faceType, 3, hasFaceVertexUv);\n            faceType = setBit(faceType, 4, hasFaceNormal);\n            faceType = setBit(faceType, 5, hasFaceVertexNormal);\n            faceType = setBit(faceType, 6, hasFaceColor);\n            faceType = setBit(faceType, 7, hasFaceVertexColor);\n            faces.push(faceType);\n            faces.push(face.a, face.b, face.c);\n            faces.push(face.materialIndex);\n            if (hasFaceVertexUv) {\n                var faceVertexUvs = this.faceVertexUvs[0][i];\n                faces.push(getUvIndex(faceVertexUvs[0]), getUvIndex(faceVertexUvs[1]), getUvIndex(faceVertexUvs[2]));\n            }\n            if (hasFaceNormal) {\n                faces.push(getNormalIndex(face.normal));\n            }\n            if (hasFaceVertexNormal) {\n                var vertexNormals = face.vertexNormals;\n                faces.push(getNormalIndex(vertexNormals[0]), getNormalIndex(vertexNormals[1]), getNormalIndex(vertexNormals[2]));\n            }\n            if (hasFaceColor) {\n                faces.push(getColorIndex(face.color));\n            }\n            if (hasFaceVertexColor) {\n                var vertexColors = face.vertexColors;\n                faces.push(getColorIndex(vertexColors[0]), getColorIndex(vertexColors[1]), getColorIndex(vertexColors[2]));\n            }\n        }\n        // // TODO: move to helpers?\n        // const setBit = (value: number, position: number, enabled: boolean | number) => {\n        //   return enabled ? value | (1 << position) : value & ~(1 << position);\n        // };\n        // // TODO: move to helpers?\n        // const getNormalIndex = (normal: Vector3) => {\n        //   const hash = normal.x.toString() + normal.y.toString() + normal.z.toString();\n        //   if (normalsHash[hash] !== undefined) {\n        //     return normalsHash[hash];\n        //   }\n        //   normalsHash[hash] = normals.length / 3;\n        //   normals.push(normal.x, normal.y, normal.z);\n        //   return normalsHash[hash];\n        // };\n        // // TODO: move to helpers?\n        // const getColorIndex = (color: Color) => {\n        //   const hash = color.r.toString() + color.g.toString() + color.b.toString();\n        //   if (colorsHash[hash] !== undefined) {\n        //     return colorsHash[hash];\n        //   }\n        //   colorsHash[hash] = colors.length;\n        //   colors.push(color.getHex());\n        //   return colorsHash[hash];\n        // };\n        // // TODO: move to helpers?\n        // const getUvIndex = (uv: Vector2) => {\n        //   const hash = uv.x.toString() + uv.y.toString();\n        //   if (uvsHash[hash] !== undefined) {\n        //     return uvsHash[hash];\n        //   }\n        //   uvsHash[hash] = uvs.length / 2;\n        //   uvs.push(uv.x, uv.y);\n        //   return uvsHash[hash];\n        // };\n        data.data = {};\n        data.data.vertices = vertices;\n        data.data.normals = normals;\n        if (colors.length > 0) {\n            data.data.colors = colors;\n        }\n        if (uvs.length > 0) {\n            data.data.uvs = [uvs]; // temporal backward compatibility\n        }\n        data.data.faces = faces;\n        return data;\n    };\n    Gmetry.prototype.clone = function () {\n        /*\n             // Handle primitives\n    \n             const parameters = this.parameters;\n    \n             if ( parameters !== undefined ) {\n    \n             const values = [];\n    \n             for ( const key in parameters ) {\n    \n             values.push( parameters[ key ] );\n    \n             }\n    \n             const geometry = Object.create( this.constructor.prototype );\n             this.constructor.apply( geometry, values );\n             return geometry;\n    \n             }\n    \n             return new this.constructor().copy( this );\n             */\n        // return new Geometry().copy( this ); // BEFORE\n        return new Gmetry(this.factory).copy(this);\n    };\n    Gmetry.prototype.copy = function (source) {\n        // reset\n        this.vertices = [];\n        this.colors = [];\n        this.faces = [];\n        this.faceVertexUvs = [[]];\n        this.morphTargets = [];\n        this.morphNormals = [];\n        this.skinWeights = [];\n        this.skinIndices = [];\n        this.lineDistances = [];\n        this.boundingBox = null;\n        this.boundingSphere = null;\n        // name\n        this.name = source.name;\n        // vertices\n        var vertices = source.vertices;\n        for (var i = 0, il = vertices.length; i < il; i++) {\n            this.vertices.push(vertices[i].clone());\n        }\n        // colors\n        var colors = source.colors;\n        for (var i = 0, il = colors.length; i < il; i++) {\n            this.colors.push(colors[i].clone());\n        }\n        // faces\n        var faces = source.faces;\n        for (var i = 0, il = faces.length; i < il; i++) {\n            this.faces.push(faces[i].clone());\n        }\n        // face vertex uvs\n        for (var i = 0, il = source.faceVertexUvs.length; i < il; i++) {\n            var faceVertexUvs = source.faceVertexUvs[i];\n            if (this.faceVertexUvs[i] === undefined) {\n                this.faceVertexUvs[i] = [];\n            }\n            for (var j = 0, jl = faceVertexUvs.length; j < jl; j++) {\n                var uvs = faceVertexUvs[j], uvsCopy = [];\n                for (var k = 0, kl = uvs.length; k < kl; k++) {\n                    var uv = uvs[k];\n                    uvsCopy.push(uv.clone());\n                }\n                this.faceVertexUvs[i].push(uvsCopy); // TODO: check\n            }\n        }\n        // morph targets\n        var morphTargets = source.morphTargets;\n        for (var i = 0, il = morphTargets.length; i < il; i++) {\n            var morphTarget = {}; // // TODO: check\n            morphTarget.name = morphTargets[i].name;\n            // vertices\n            if (morphTargets[i].vertices !== undefined) {\n                morphTarget.vertices = [];\n                for (var j = 0, jl = morphTargets[i].vertices.length; j < jl; j++) {\n                    morphTarget.vertices.push(morphTargets[i].vertices[j].clone());\n                }\n            }\n            // normals\n            if (morphTargets[i].normals !== undefined) {\n                morphTarget.normals = [];\n                for (var j = 0, jl = morphTargets[i].normals.length; j < jl; j++) {\n                    morphTarget.normals.push(morphTargets[i].normals[j].clone());\n                }\n            }\n            this.morphTargets.push(morphTarget);\n        }\n        // morph normals\n        var morphNormals = source.morphNormals;\n        for (var i = 0, il = morphNormals.length; i < il; i++) {\n            var morphNormal = {};\n            // vertex normals\n            if (morphNormals[i].vertexNormals !== undefined) {\n                morphNormal.vertexNormals = [];\n                for (var j = 0, jl = morphNormals[i].vertexNormals.length; j < jl; j++) {\n                    var srcVertexNormal = morphNormals[i].vertexNormals[j];\n                    // TODO: add type\n                    var destVertexNormal = { a: null, b: null, c: null };\n                    destVertexNormal.a = srcVertexNormal.a.clone();\n                    destVertexNormal.b = srcVertexNormal.b.clone();\n                    destVertexNormal.c = srcVertexNormal.c.clone();\n                    morphNormal.vertexNormals.push(destVertexNormal);\n                }\n            }\n            // face normals\n            if (morphNormals[i].faceNormals !== undefined) {\n                morphNormal.faceNormals = [];\n                for (var j = 0, jl = morphNormals[i].faceNormals.length; j < jl; j++) {\n                    morphNormal.faceNormals.push(morphNormals[i].faceNormals[j].clone());\n                }\n            }\n            this.morphNormals.push(morphNormal);\n        }\n        // skin weights\n        var skinWeights = source.skinWeights;\n        for (var i = 0, il = skinWeights.length; i < il; i++) {\n            this.skinWeights.push(skinWeights[i].clone());\n        }\n        // skin indices\n        var skinIndices = source.skinIndices;\n        for (var i = 0, il = skinIndices.length; i < il; i++) {\n            this.skinIndices.push(skinIndices[i].clone());\n        }\n        // line distances\n        var lineDistances = source.lineDistances;\n        for (var i = 0, il = lineDistances.length; i < il; i++) {\n            this.lineDistances.push(lineDistances[i]);\n        }\n        // bounding box\n        var boundingBox = source.boundingBox;\n        if (boundingBox !== null) {\n            this.boundingBox = boundingBox.clone();\n        }\n        // bounding sphere\n        var boundingSphere = source.boundingSphere;\n        if (boundingSphere !== null) {\n            this.boundingSphere = boundingSphere.clone();\n        }\n        // update flags\n        this.elementsNeedUpdate = source.elementsNeedUpdate;\n        this.verticesNeedUpdate = source.verticesNeedUpdate;\n        this.uvsNeedUpdate = source.uvsNeedUpdate;\n        this.normalsNeedUpdate = source.normalsNeedUpdate;\n        this.colorsNeedUpdate = source.colorsNeedUpdate;\n        this.lineDistancesNeedUpdate = source.lineDistancesNeedUpdate;\n        this.groupsNeedUpdate = source.groupsNeedUpdate;\n        return this;\n    };\n    Gmetry.prototype.toBufferGeometry = function () {\n        var geometry = new DirectGeometry_1.DirectGeometry(this.factory).fromGeometry(this);\n        // TODO: verify\n        // const buffergeometry = new BufferGeometry();\n        var buffergeometry = this.factory.newBufferGeometry();\n        var positions = new Float32Array(geometry.vertices.length * 3);\n        // TODO: verfify\n        // buffergeometry.setAttribute( 'position', new BufferAttribute( positions, 3 ).copyVector3sArray( geometry.vertices ) );\n        buffergeometry.setAttribute(\"position\", this.factory.newBufferAttribute(positions, 3).copyVector3sArray(geometry.vertices));\n        if (geometry.normals.length > 0) {\n            var normals = new Float32Array(geometry.normals.length * 3);\n            // TODO: verfify\n            // buffergeometry.setAttribute( 'normal', new BufferAttribute( normals, 3 ).copyVector3sArray( geometry.normals ) );\n            buffergeometry.setAttribute(\"normal\", this.factory.newBufferAttribute(normals, 3).copyVector3sArray(geometry.normals));\n        }\n        if (geometry.colors.length > 0) {\n            var colors = new Float32Array(geometry.colors.length * 3);\n            // TODO: verfify\n            // buffergeometry.setAttribute( 'color', new BufferAttribute( colors, 3 ).copyColorsArray( geometry.colors ) );\n            buffergeometry.setAttribute(\"color\", this.factory.newBufferAttribute(colors, 3).copyColorsArray(geometry.colors));\n        }\n        if (geometry.uvs.length > 0) {\n            var uvs = new Float32Array(geometry.uvs.length * 2);\n            // TODO: verfify\n            // buffergeometry.setAttribute( 'uv', new BufferAttribute( uvs, 2 ).copyVector2sArray( geometry.uvs ) );\n            buffergeometry.setAttribute(\"uv\", this.factory.newBufferAttribute(uvs, 2).copyVector2sArray(geometry.uvs));\n        }\n        if (geometry.uvs2.length > 0) {\n            var uvs2 = new Float32Array(geometry.uvs2.length * 2);\n            // TODO: verfify\n            // buffergeometry.setAttribute( 'uv2', new BufferAttribute( uvs2, 2 ).copyVector2sArray( geometry.uvs2 ) );\n            buffergeometry.setAttribute(\"uv2\", this.factory.newBufferAttribute(uvs2, 2).copyVector2sArray(geometry.uvs2));\n        }\n        // groups\n        buffergeometry.groups = geometry.groups;\n        // morphs\n        for (var name_1 in geometry.morphTargets) {\n            var array = [];\n            var morphTargets = geometry.morphTargets[name_1];\n            for (var i = 0, l = morphTargets.length; i < l; i++) {\n                var morphTarget = morphTargets[i];\n                // TODO: verify\n                // const attribute = new Float32BufferAttribute( morphTarget.data.length * 3, 3 );\n                var attribute = this.factory.newFloat32BufferAttribute(morphTarget.data.length * 3, 3);\n                attribute.name = morphTarget.name;\n                array.push(attribute.copyVector3sArray(morphTarget.data));\n            }\n            buffergeometry.morphAttributes[name_1] = array;\n        }\n        // skinning\n        if (geometry.skinIndices.length > 0) {\n            var skinIndices = this.factory.newFloat32BufferAttribute(geometry.skinIndices.length * 4, 4);\n            buffergeometry.setAttribute(\"skinIndex\", skinIndices.copyVector4sArray(geometry.skinIndices));\n        }\n        if (geometry.skinWeights.length > 0) {\n            var skinWeights = this.factory.newFloat32BufferAttribute(geometry.skinWeights.length * 4, 4);\n            buffergeometry.setAttribute(\"skinWeight\", skinWeights.copyVector4sArray(geometry.skinWeights));\n        }\n        //\n        if (geometry.boundingSphere !== null) {\n            buffergeometry.boundingSphere = geometry.boundingSphere.clone();\n        }\n        if (geometry.boundingBox !== null) {\n            buffergeometry.boundingBox = geometry.boundingBox.clone();\n        }\n        return buffergeometry;\n    };\n    Gmetry.prototype.computeTangents = function () {\n        console.error(\"THREE.Geometry: .computeTangents() has been removed.\");\n    };\n    Gmetry.prototype.computeLineDistances = function () {\n        console.error(\"THREE.Geometry: .computeLineDistances() has been removed. Use THREE.Line.computeLineDistances() instead.\");\n    };\n    Gmetry.prototype.applyMatrix = function (matrix) {\n        console.warn(\"THREE.Geometry: .applyMatrix() has been renamed to .applyMatrix4().\");\n        return this.applyMatrix4(matrix);\n    };\n    Gmetry.prototype.dispose = function () {\n        // This is not required when used outside of THREE.\n        // this.dispatchEvent( { type: 'dispose' } );\n    };\n    // TODO: can we specify and types for 'object' here?\n    Gmetry.createBufferGeometryFromObject = function (object, factory) {\n        var fact = factory || DefaultFactory_1.DefaultFactory;\n        var buffergeometry = fact.newBufferGeometry();\n        var geometry = object.geometry;\n        if (object.isPoints || object.isLine) {\n            var positions = fact.newFloat32BufferAttribute(geometry.vertices.length * 3, 3);\n            var colors = fact.newFloat32BufferAttribute(geometry.colors.length * 3, 3);\n            buffergeometry.setAttribute(\"position\", positions.copyVector3sArray(geometry.vertices));\n            buffergeometry.setAttribute(\"color\", colors.copyColorsArray(geometry.colors));\n            if (geometry.lineDistances && geometry.lineDistances.length === geometry.vertices.length) {\n                var lineDistances = fact.newFloat32BufferAttribute(geometry.lineDistances.length, 1);\n                buffergeometry.setAttribute(\"lineDistance\", lineDistances.copyArray(geometry.lineDistances));\n            }\n            if (geometry.boundingSphere !== null) {\n                buffergeometry.boundingSphere = geometry.boundingSphere.clone();\n            }\n            if (geometry.boundingBox !== null) {\n                buffergeometry.boundingBox = geometry.boundingBox.clone();\n            }\n        }\n        else if (object.isMesh) {\n            buffergeometry = geometry.toBufferGeometry();\n        }\n        return buffergeometry;\n    };\n    return Gmetry;\n}());\nexports.Gmetry = Gmetry;\n//# sourceMappingURL=Gmetry.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.ThreeGeometryHellfix = exports.Gmetry = exports.Face3 = exports.DirectGeometry = void 0;\nvar DirectGeometry_1 = require(\"./DirectGeometry\");\nObject.defineProperty(exports, \"DirectGeometry\", { enumerable: true, get: function () { return DirectGeometry_1.DirectGeometry; } });\nvar Face3_1 = require(\"./Face3\");\nObject.defineProperty(exports, \"Face3\", { enumerable: true, get: function () { return Face3_1.Face3; } });\nvar Gmetry_1 = require(\"./Gmetry\");\nObject.defineProperty(exports, \"Gmetry\", { enumerable: true, get: function () { return Gmetry_1.Gmetry; } });\nvar mylibrary_1 = require(\"./mylibrary\");\nObject.defineProperty(exports, \"ThreeGeometryHellfix\", { enumerable: true, get: function () { return mylibrary_1.ThreeGeometryHellfix; } });\n//# sourceMappingURL=index.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.ThreeGeometryHellfix = void 0;\nvar DefaultFactory_1 = require(\"./DefaultFactory\");\nvar DirectGeometry_1 = require(\"./DirectGeometry\");\nvar Face3_1 = require(\"./Face3\");\nvar Gmetry_1 = require(\"./Gmetry\");\nexports.ThreeGeometryHellfix = {\n    DirectGeometry: DirectGeometry_1.DirectGeometry,\n    Face3: Face3_1.Face3,\n    Gmetry: Gmetry_1.Gmetry,\n    DefaultFactory: DefaultFactory_1.DefaultFactory\n};\n//# sourceMappingURL=mylibrary.js.map","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// Expose all your components to the global scope here.\n\nglobalThis.ThreeGeometryHellfix = globalThis.TGH = require(\"./\").ThreeGeometryHellfix;\n"],"names":["Object","defineProperty","exports","value","DefaultFactory","newVector2","x","y","window","Vector2","newVector3","z","Vector3","newMatrix3","Matrix3","newMatrix4","Matrix4","newObject3D","Object3D","newBox3","Box3","newSphere","Sphere","newBufferGeometry","BufferGeometry","generateUUID","MathUtils","newFloat32BufferAttribute","array","itemSize","normalized","Float32BufferAttribute","newColor","Color","newBufferAttribute","BufferAttribute","DirectGeometry","DefaultFactory_1","factory","this","vertices","normals","colors","uvs","uvs2","groups","morphTargets","skinWeights","skinIndices","boundingBox","boundingSphere","verticesNeedUpdate","normalsNeedUpdate","colorsNeedUpdate","uvsNeedUpdate","groupsNeedUpdate","prototype","computeGroups","geometry","group","i","materialIndex","undefined","faces","length","face","count","start","push","fromGeometry","morphTargetsPosition","faceVertexUvs","hasFaceVertexUv","hasFaceVertexUv2","morphTargetsLength","name","data","position","morphTargetsNormal","morphNormals","morphNormalsLength","normal","hasSkinIndices","hasSkinWeights","console","error","a","b","c","vertexNormals","vertexUvs","vertexColors","color","warn","j","morphTarget","morphNormal","clone","Face3","fact","isVector3","Array","isArray","isColor","copy","source","il","Gmetry","DirectGeometry_1","Face3_1","type","lineDistances","elementsNeedUpdate","lineDistancesNeedUpdate","isGeometry","uuid","_m1","_obj","_offset","applyMatrix4","matrix","normalMatrix","getNormalMatrix","applyMatrix3","normalize","jl","computeBoundingBox","computeBoundingSphere","rotateX","angle","makeRotationX","rotateY","makeRotationY","rotateZ","makeRotationZ","translate","makeTranslation","scale","makeScale","lookAt","vector","updateMatrix","fromBufferGeometry","scope","index","attributes","uv","uv2","fromBufferAttribute","addFace","getX","computeFaceNormals","center","getCenter","negate","radius","s","set","cb","ab","f","fl","vA","vB","vC","subVectors","cross","computeVertexNormals","areaWeighted","v","vl","add","computeFlatVertexNormals","computeMorphNormals","__originalFaceNormal","__originalVertexNormals","tmpGeo","faceNormals","dstNormalsFace","dstNormalsVertex","faceNormal","setFromPoints","merge","materialIndexOffset","vertexOffset","vertices1","vertices2","faces1","faces2","colors1","colors2","vertexCopy","faceVertexNormals","faceVertexColors","faceCopy","faceVertexUvs2","uvsCopy","k","kl","mergeMesh","mesh","isMesh","matrixAutoUpdate","mergeVertices","precisionPoints","verticesMap","unique","changes","precision","Math","pow","key","round","faceIndicesToRemove","indices","n","idx","splice","diff","points","l","point","sortFacesByMaterialIndex","_id","sort","newUvs1","newUvs2","uvs1","id","toJSON","metadata","version","generator","parameters","vertex","normalsHash","colorsHash","uvsHash","hasFaceNormal","hasFaceVertexNormal","hasFaceColor","r","g","hasFaceVertexColor","faceType","setBit","enabled","getNormalIndex","hash","toString","getColorIndex","getHex","getUvIndex","srcVertexNormal","destVertexNormal","toBufferGeometry","buffergeometry","positions","Float32Array","setAttribute","copyVector3sArray","copyColorsArray","copyVector2sArray","name_1","attribute","morphAttributes","copyVector4sArray","computeTangents","computeLineDistances","applyMatrix","dispose","createBufferGeometryFromObject","object","isPoints","isLine","copyArray","Gmetry_1","mylibrary_1","enumerable","get","ThreeGeometryHellfix","__webpack_module_cache__","__webpack_require__","moduleId","cachedModule","module","__webpack_modules__","globalThis","TGH"],"sourceRoot":""}