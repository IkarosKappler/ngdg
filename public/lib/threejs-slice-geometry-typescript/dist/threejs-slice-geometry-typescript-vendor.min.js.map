{"version":3,"file":"threejs-slice-geometry-typescript-vendor.min.js","mappings":"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","sources":["webpack://threejs-slice-geometry-typescript/./node_modules/three-geometry-hellfix/src/esm/DefaultFactory.js","webpack://threejs-slice-geometry-typescript/./node_modules/three-geometry-hellfix/src/esm/DirectGeometry.js","webpack://threejs-slice-geometry-typescript/./node_modules/three-geometry-hellfix/src/esm/Face3.js","webpack://threejs-slice-geometry-typescript/./node_modules/three-geometry-hellfix/src/esm/Gmetry.js","webpack://threejs-slice-geometry-typescript/./node_modules/three-geometry-hellfix/src/esm/mylibrary.js"],"sourcesContent":["/**\n * The default factory to connect to your three library.\n *\n * @author  Ikaros Kappler\n * @date    2022-02-20\n * @version 1.0.0\n */\nexport const DefaultFactory = {\n    newVector2: (x, y) => { return new window[\"THREE\"].Vector2(x, y); },\n    newVector3: (x, y, z) => { return new window[\"THREE\"].Vector3(x, y, z); },\n    newMatrix3: () => { return new window[\"THREE\"].Matrix3(); },\n    newMatrix4: () => { return new window[\"THREE\"].Matrix4(); },\n    newObject3D: () => { return new window[\"THREE\"].Object3D(); },\n    newBox3: () => { return new window[\"THREE\"].Box3(); },\n    newSphere: () => { return new window[\"THREE\"].Sphere(); },\n    newBufferGeometry: () => { return new window[\"THREE\"].BufferGeometry(); },\n    generateUUID: () => { return window[\"THREE\"].MathUtils.generateUUID(); },\n    newFloat32BufferAttribute: (array, itemSize, normalized) => { return new window[\"THREE\"].Float32BufferAttribute(array, itemSize, normalized); },\n    newColor: () => { return new window[\"THREE\"].Color; },\n    newBufferAttribute: (array, itemSize, normalized) => { return new window[\"THREE\"].BufferAttribute(array, itemSize, normalized); }\n};\n//# sourceMappingURL=DefaultFactory.js.map","/**\n * THE ORIGINAL SOURCE COOE IS HERE:\n *    https://github.com/mrdoob/three.js/blob/dev/examples/jsm/deprecated/Geometry.js\n *\n * This is a backport of the old (deprecated) THREE.DirectGeometry class.\n *\n * It got deprecated in version r125 and was announced to be completely dropped in future versions.\n *\n * As it was a very useful class I wanted to preserve it for some of my projects which depend on it.\n *\n * And here this is a Typescript port, too. Enjoy!\n *    - Ikaros Kappler\n *\n * @date 2022-02-11\n */\nimport { DefaultFactory } from \"./DefaultFactory\";\nexport class DirectGeometry {\n    constructor(factory) {\n        this.vertices = [];\n        this.normals = [];\n        this.colors = [];\n        this.uvs = [];\n        this.uvs2 = [];\n        this.groups = [];\n        this.morphTargets = {};\n        this.skinWeights = [];\n        this.skinIndices = [];\n        // this.lineDistances = [];\n        this.boundingBox = null;\n        this.boundingSphere = null;\n        // update flags\n        this.verticesNeedUpdate = false;\n        this.normalsNeedUpdate = false;\n        this.colorsNeedUpdate = false;\n        this.uvsNeedUpdate = false;\n        this.groupsNeedUpdate = false;\n        // this.isGeometry = true;\n        this.factory = factory || DefaultFactory;\n    }\n    computeGroups(geometry) {\n        const groups = [];\n        let group;\n        let i;\n        let materialIndex = undefined;\n        const faces = geometry.faces;\n        for (i = 0; i < faces.length; i++) {\n            const face = faces[i];\n            // materials\n            if (face.materialIndex !== materialIndex) {\n                materialIndex = face.materialIndex;\n                if (group !== undefined) {\n                    group.count = i * 3 - group.start;\n                    groups.push(group);\n                }\n                group = {\n                    start: i * 3,\n                    materialIndex: materialIndex\n                };\n            }\n        }\n        if (group !== undefined) {\n            group.count = i * 3 - group.start;\n            groups.push(group);\n        }\n        this.groups = groups;\n    }\n    fromGeometry(geometry) {\n        const faces = geometry.faces;\n        const vertices = geometry.vertices;\n        const faceVertexUvs = geometry.faceVertexUvs;\n        const hasFaceVertexUv = faceVertexUvs[0] && faceVertexUvs[0].length > 0;\n        const hasFaceVertexUv2 = faceVertexUvs[1] && faceVertexUvs[1].length > 0;\n        // morphs\n        const morphTargets = geometry.morphTargets;\n        const morphTargetsLength = morphTargets.length;\n        let morphTargetsPosition;\n        if (morphTargetsLength > 0) {\n            morphTargetsPosition = [];\n            for (let i = 0; i < morphTargetsLength; i++) {\n                morphTargetsPosition[i] = {\n                    name: morphTargets[i].name,\n                    data: []\n                };\n            }\n            // TODO: here seems to be something wrong with the types\n            this.morphTargets.position = morphTargetsPosition;\n        }\n        const morphNormals = geometry.morphNormals;\n        const morphNormalsLength = morphNormals.length;\n        let morphTargetsNormal;\n        if (morphNormalsLength > 0) {\n            morphTargetsNormal = [];\n            for (let i = 0; i < morphNormalsLength; i++) {\n                morphTargetsNormal[i] = {\n                    name: morphNormals[i].name,\n                    data: []\n                };\n            }\n            this.morphTargets.normal = morphTargetsNormal;\n        }\n        // skins\n        const skinIndices = geometry.skinIndices;\n        const skinWeights = geometry.skinWeights;\n        const hasSkinIndices = skinIndices.length === vertices.length;\n        const hasSkinWeights = skinWeights.length === vertices.length;\n        //\n        if (vertices.length > 0 && faces.length === 0) {\n            console.error(\"THREE.DirectGeometry: Faceless geometries are not supported.\");\n        }\n        for (let i = 0; i < faces.length; i++) {\n            const face = faces[i];\n            this.vertices.push(vertices[face.a], vertices[face.b], vertices[face.c]);\n            const vertexNormals = face.vertexNormals;\n            if (vertexNormals.length === 3) {\n                this.normals.push(vertexNormals[0], vertexNormals[1], vertexNormals[2]);\n            }\n            else {\n                const normal = face.normal;\n                this.normals.push(normal, normal, normal);\n            }\n            const vertexColors = face.vertexColors;\n            if (vertexColors.length === 3) {\n                this.colors.push(vertexColors[0], vertexColors[1], vertexColors[2]);\n            }\n            else {\n                const color = face.color;\n                this.colors.push(color, color, color);\n            }\n            if (hasFaceVertexUv === true) {\n                const vertexUvs = faceVertexUvs[0][i];\n                if (vertexUvs !== undefined) {\n                    this.uvs.push(vertexUvs[0], vertexUvs[1], vertexUvs[2]);\n                }\n                else {\n                    console.warn(\"THREE.DirectGeometry.fromGeometry(): Undefined vertexUv \", i);\n                    // TODO: verify\n                    // this.uvs.push( new Vector2(), new Vector2(), new Vector2() );\n                    this.uvs.push(this.factory.newVector2(), this.factory.newVector2(), this.factory.newVector2());\n                }\n            }\n            if (hasFaceVertexUv2 === true) {\n                const vertexUvs = faceVertexUvs[1][i];\n                if (vertexUvs !== undefined) {\n                    this.uvs2.push(vertexUvs[0], vertexUvs[1], vertexUvs[2]);\n                }\n                else {\n                    console.warn(\"THREE.DirectGeometry.fromGeometry(): Undefined vertexUv2 \", i);\n                    // TODO: verify\n                    // this.uvs2.push( new Vector2(), new Vector2(), new Vector2() );\n                    this.uvs2.push(this.factory.newVector2(), this.factory.newVector2(), this.factory.newVector2());\n                }\n            }\n            // morphs\n            for (let j = 0; j < morphTargetsLength; j++) {\n                const morphTarget = morphTargets[j].vertices;\n                morphTargetsPosition[j].data.push(morphTarget[face.a], morphTarget[face.b], morphTarget[face.c]);\n            }\n            for (let j = 0; j < morphNormalsLength; j++) {\n                const morphNormal = morphNormals[j].vertexNormals[i];\n                morphTargetsNormal[j].data.push(morphNormal.a, morphNormal.b, morphNormal.c);\n            }\n            // skins\n            if (hasSkinIndices) {\n                this.skinIndices.push(skinIndices[face.a], skinIndices[face.b], skinIndices[face.c]);\n            }\n            if (hasSkinWeights) {\n                this.skinWeights.push(skinWeights[face.a], skinWeights[face.b], skinWeights[face.c]);\n            }\n        }\n        this.computeGroups(geometry);\n        this.verticesNeedUpdate = geometry.verticesNeedUpdate;\n        this.normalsNeedUpdate = geometry.normalsNeedUpdate;\n        this.colorsNeedUpdate = geometry.colorsNeedUpdate;\n        this.uvsNeedUpdate = geometry.uvsNeedUpdate;\n        this.groupsNeedUpdate = geometry.groupsNeedUpdate;\n        if (geometry.boundingSphere !== null) {\n            this.boundingSphere = geometry.boundingSphere.clone();\n        }\n        if (geometry.boundingBox !== null) {\n            this.boundingBox = geometry.boundingBox.clone();\n        }\n        return this;\n    }\n}\n//# sourceMappingURL=DirectGeometry.js.map","/**\n * THE ORIGINAL SOURCE COOE IS HERE:\n *    https://github.com/mrdoob/three.js/blob/dev/examples/jsm/deprecated/Geometry.js\n *\n * This is a backport of the old (deprecated) THREE.Face3 class.\n *\n * It got deprecated in version r125 and was announced to be completely dropped in future versions.\n *\n * As it was a very useful class I wanted to preserve it for some of my projects which depend on it.\n *\n * And here this is a Typescript port, too. Enjoy!\n *    - Ikaros Kappler\n *\n * @date 2022-02-11\n */\nimport { DefaultFactory } from \"./DefaultFactory\";\nexport class Face3 {\n    constructor(a, b, c, normal, color, materialIndex = 0, factory) {\n        var fact = factory || DefaultFactory;\n        this.a = a;\n        this.b = b;\n        this.c = c;\n        // this.normal = ( normal && normal.isVector3 ) ? normal : new THREE.Vector3();\n        // this.vertexNormals = Array.isArray( normal ) ? normal : [];\n        // TODO: verify correctness\n        // this.normal = ( normal && (normal instanceof Vector3 && normal.isVector3) ) ? normal : new Vector3();\n        // TODO: use DefaultFactory here\n        // this.normal = ( normal && (normal instanceof Vector3 && normal.isVector3) ) ? normal : new (window[\"THREE\"]).Vector3();\n        this.normal = normal && normal.isVector3 ? normal : fact.newVector3();\n        this.vertexNormals = Array.isArray(normal) ? normal : [];\n        // this.color = ( color && color.isColor ) ? color : new THREE.Color();\n        // this.color = ( color && ( color instanceof Color && color.isColor)  ) ? color : new Color(); // TODO: verify correctness\n        // TODO: use DefaultFactory here\n        this.color = color && color.isColor ? color : fact.newColor(); // TODO: verify correctness\n        this.vertexColors = Array.isArray(color) ? color : [];\n        this.materialIndex = materialIndex;\n    }\n    clone() {\n        // TODO: check if new expression is correct\n        // return new this.constructor().copy( this );\n        return new Face3(this.a, this.b, this.c, this.normal.clone(), this.color.clone(), this.materialIndex).copy(this);\n    }\n    copy(source) {\n        this.a = source.a;\n        this.b = source.b;\n        this.c = source.c;\n        this.normal.copy(source.normal);\n        this.color.copy(source.color);\n        this.materialIndex = source.materialIndex;\n        for (let i = 0, il = source.vertexNormals.length; i < il; i++) {\n            this.vertexNormals[i] = source.vertexNormals[i].clone();\n        }\n        for (let i = 0, il = source.vertexColors.length; i < il; i++) {\n            this.vertexColors[i] = source.vertexColors[i].clone();\n        }\n        return this;\n    }\n}\n//# sourceMappingURL=Face3.js.map","/**\n * THE ORIGINAL SOURCE COOE IS HERE:\n *    https://github.com/mrdoob/three.js/blob/dev/examples/jsm/deprecated/Geometry.js\n *\n * This is a backport of the old (deprecated) THREE.Face3 class.\n *\n * It got deprecated in version r125 and was announced to be completely dropped in future versions.\n *\n * As it was a very useful class I wanted to preserve it for some of my projects which depend on it.\n *\n * And here this is a Typescript port, too. Enjoy!\n *    - Ikaros Kappler\n *\n * @date 2022-02-11\n */\nimport { DefaultFactory } from \"./DefaultFactory\";\nimport { DirectGeometry } from \"./DirectGeometry\";\nimport { Face3 } from \"./Face3\";\nexport class Gmetry {\n    /**\n     * Construct a new Gmetry.\n     *\n     * @param {ThreeFactory?} factory - Specify a custom factory if you do not want to use the DefaultFactory.\n     */\n    constructor(factory) {\n        this.name = \"\";\n        this.type = \"Geometry\";\n        this.vertices = [];\n        this.colors = [];\n        this.faces = [];\n        this.faceVertexUvs = [[]];\n        this.morphTargets = [];\n        this.morphNormals = [];\n        this.skinWeights = [];\n        this.skinIndices = [];\n        this.lineDistances = [];\n        this.boundingBox = null;\n        this.boundingSphere = null;\n        // update flags\n        this.elementsNeedUpdate = false;\n        this.verticesNeedUpdate = false;\n        this.uvsNeedUpdate = false;\n        this.normalsNeedUpdate = false;\n        this.colorsNeedUpdate = false;\n        this.lineDistancesNeedUpdate = false;\n        this.groupsNeedUpdate = false;\n        this.isGeometry = true;\n        this.factory = factory || DefaultFactory;\n        this.uuid = this.factory.generateUUID();\n        this._m1 = this.factory.newMatrix4();\n        this._obj = this.factory.newObject3D();\n        this._offset = this.factory.newVector3();\n    }\n    applyMatrix4(matrix) {\n        const normalMatrix = this.factory.newMatrix3().getNormalMatrix(matrix);\n        for (let i = 0, il = this.vertices.length; i < il; i++) {\n            const vertex = this.vertices[i];\n            vertex.applyMatrix4(matrix);\n        }\n        for (let i = 0, il = this.faces.length; i < il; i++) {\n            const face = this.faces[i];\n            face.normal.applyMatrix3(normalMatrix).normalize();\n            for (let j = 0, jl = face.vertexNormals.length; j < jl; j++) {\n                face.vertexNormals[j].applyMatrix3(normalMatrix).normalize();\n            }\n        }\n        if (this.boundingBox !== null) {\n            this.computeBoundingBox();\n        }\n        if (this.boundingSphere !== null) {\n            this.computeBoundingSphere();\n        }\n        this.verticesNeedUpdate = true;\n        this.normalsNeedUpdate = true;\n        return this;\n    }\n    rotateX(angle) {\n        // rotate geometry around world x-axis\n        this._m1.makeRotationX(angle);\n        this.applyMatrix4(this._m1);\n        return this;\n    }\n    rotateY(angle) {\n        // rotate geometry around world y-axis\n        this._m1.makeRotationY(angle);\n        this.applyMatrix4(this._m1);\n        return this;\n    }\n    rotateZ(angle) {\n        // rotate geometry around world z-axis\n        this._m1.makeRotationZ(angle);\n        this.applyMatrix4(this._m1);\n        return this;\n    }\n    translate(x, y, z) {\n        // translate geometry\n        this._m1.makeTranslation(x, y, z);\n        this.applyMatrix4(this._m1);\n        return this;\n    }\n    scale(x, y, z) {\n        // scale geometry\n        this._m1.makeScale(x, y, z);\n        this.applyMatrix4(this._m1);\n        return this;\n    }\n    lookAt(vector) {\n        this._obj.lookAt(vector);\n        this._obj.updateMatrix();\n        this.applyMatrix4(this._obj.matrix);\n        return this;\n    }\n    fromBufferGeometry(geometry) {\n        const scope = this;\n        const index = geometry.index !== null ? geometry.index : undefined;\n        const attributes = geometry.attributes;\n        if (attributes.position === undefined) {\n            console.error(\"THREE.Geometry.fromBufferGeometry(): Position attribute required for conversion.\");\n            return this;\n        }\n        const position = attributes.position;\n        const normal = attributes.normal;\n        const color = attributes.color;\n        const uv = attributes.uv;\n        const uv2 = attributes.uv2;\n        if (uv2 !== undefined)\n            this.faceVertexUvs[1] = [];\n        for (let i = 0; i < position.count; i++) {\n            scope.vertices.push(this.factory.newVector3().fromBufferAttribute(position, i));\n            if (color !== undefined) {\n                scope.colors.push(this.factory.newColor().fromBufferAttribute(color, i));\n            }\n        }\n        const factory = this.factory;\n        // TODO: put to helper functions\n        const addFace = (a, b, c, materialIndex) => {\n            const vertexColors = color === undefined ? [] : [scope.colors[a].clone(), scope.colors[b].clone(), scope.colors[c].clone()];\n            const vertexNormals = normal === undefined\n                ? []\n                : [\n                    factory.newVector3().fromBufferAttribute(normal, a),\n                    factory.newVector3().fromBufferAttribute(normal, b),\n                    factory.newVector3().fromBufferAttribute(normal, c)\n                ];\n            const face = new Face3(a, b, c, vertexNormals, vertexColors, materialIndex);\n            scope.faces.push(face);\n            if (uv !== undefined) {\n                scope.faceVertexUvs[0].push([\n                    factory.newVector2().fromBufferAttribute(uv, a),\n                    factory.newVector2().fromBufferAttribute(uv, b),\n                    factory.newVector2().fromBufferAttribute(uv, c)\n                ]);\n            }\n            if (uv2 !== undefined) {\n                scope.faceVertexUvs[1].push([\n                    factory.newVector2().fromBufferAttribute(uv2, a),\n                    factory.newVector2().fromBufferAttribute(uv2, b),\n                    factory.newVector2().fromBufferAttribute(uv2, c)\n                ]);\n            }\n        };\n        const groups = geometry.groups;\n        if (groups.length > 0) {\n            for (let i = 0; i < groups.length; i++) {\n                const group = groups[i];\n                const start = group.start;\n                const count = group.count;\n                for (let j = start, jl = start + count; j < jl; j += 3) {\n                    if (index !== undefined) {\n                        addFace(index.getX(j), index.getX(j + 1), index.getX(j + 2), group.materialIndex);\n                    }\n                    else {\n                        addFace(j, j + 1, j + 2, group.materialIndex);\n                    }\n                }\n            }\n        }\n        else {\n            if (index !== undefined) {\n                for (let i = 0; i < index.count; i += 3) {\n                    addFace(index.getX(i), index.getX(i + 1), index.getX(i + 2));\n                }\n            }\n            else {\n                for (let i = 0; i < position.count; i += 3) {\n                    addFace(i, i + 1, i + 2);\n                }\n            }\n        }\n        this.computeFaceNormals();\n        if (geometry.boundingBox !== null) {\n            this.boundingBox = geometry.boundingBox.clone();\n        }\n        if (geometry.boundingSphere !== null) {\n            this.boundingSphere = geometry.boundingSphere.clone();\n        }\n        return this;\n    }\n    center() {\n        this.computeBoundingBox();\n        this.boundingBox.getCenter(this._offset).negate();\n        this.translate(this._offset.x, this._offset.y, this._offset.z);\n        return this;\n    }\n    normalize() {\n        this.computeBoundingSphere();\n        const center = this.boundingSphere.center;\n        const radius = this.boundingSphere.radius;\n        const s = radius === 0 ? 1 : 1.0 / radius;\n        const matrix = this.factory.newMatrix4();\n        matrix.set(s, 0, 0, -s * center.x, 0, s, 0, -s * center.y, 0, 0, s, -s * center.z, 0, 0, 0, 1);\n        this.applyMatrix4(matrix);\n        return this;\n    }\n    computeFaceNormals() {\n        const cb = this.factory.newVector3(), ab = this.factory.newVector3();\n        for (let f = 0, fl = this.faces.length; f < fl; f++) {\n            const face = this.faces[f];\n            const vA = this.vertices[face.a];\n            const vB = this.vertices[face.b];\n            const vC = this.vertices[face.c];\n            cb.subVectors(vC, vB);\n            ab.subVectors(vA, vB);\n            cb.cross(ab);\n            cb.normalize();\n            face.normal.copy(cb);\n        }\n    }\n    computeVertexNormals(areaWeighted = true) {\n        const vertices = new Array(this.vertices.length);\n        for (let v = 0, vl = this.vertices.length; v < vl; v++) {\n            // TODO: verify\n            // vertices[ v ] = new Vector3();\n            vertices[v] = this.factory.newVector3();\n        }\n        if (areaWeighted) {\n            // vertex normals weighted by triangle areas\n            // http://www.iquilezles.org/www/articles/normals/normals.htm\n            // TODO: verify\n            // const cb = new Vector3(), ab = new Vector3();\n            const cb = this.factory.newVector3(), ab = this.factory.newVector3();\n            for (let f = 0, fl = this.faces.length; f < fl; f++) {\n                const face = this.faces[f];\n                const vA = this.vertices[face.a];\n                const vB = this.vertices[face.b];\n                const vC = this.vertices[face.c];\n                cb.subVectors(vC, vB);\n                ab.subVectors(vA, vB);\n                cb.cross(ab);\n                vertices[face.a].add(cb);\n                vertices[face.b].add(cb);\n                vertices[face.c].add(cb);\n            }\n        }\n        else {\n            this.computeFaceNormals();\n            for (let f = 0, fl = this.faces.length; f < fl; f++) {\n                const face = this.faces[f];\n                vertices[face.a].add(face.normal);\n                vertices[face.b].add(face.normal);\n                vertices[face.c].add(face.normal);\n            }\n        }\n        for (let v = 0, vl = this.vertices.length; v < vl; v++) {\n            vertices[v].normalize();\n        }\n        for (let f = 0, fl = this.faces.length; f < fl; f++) {\n            const face = this.faces[f];\n            const vertexNormals = face.vertexNormals;\n            if (vertexNormals.length === 3) {\n                vertexNormals[0].copy(vertices[face.a]);\n                vertexNormals[1].copy(vertices[face.b]);\n                vertexNormals[2].copy(vertices[face.c]);\n            }\n            else {\n                vertexNormals[0] = vertices[face.a].clone();\n                vertexNormals[1] = vertices[face.b].clone();\n                vertexNormals[2] = vertices[face.c].clone();\n            }\n        }\n        if (this.faces.length > 0) {\n            this.normalsNeedUpdate = true;\n        }\n    }\n    computeFlatVertexNormals() {\n        this.computeFaceNormals();\n        for (let f = 0, fl = this.faces.length; f < fl; f++) {\n            const face = this.faces[f];\n            const vertexNormals = face.vertexNormals;\n            if (vertexNormals.length === 3) {\n                vertexNormals[0].copy(face.normal);\n                vertexNormals[1].copy(face.normal);\n                vertexNormals[2].copy(face.normal);\n            }\n            else {\n                vertexNormals[0] = face.normal.clone();\n                vertexNormals[1] = face.normal.clone();\n                vertexNormals[2] = face.normal.clone();\n            }\n        }\n        if (this.faces.length > 0) {\n            this.normalsNeedUpdate = true;\n        }\n    }\n    computeMorphNormals() {\n        // save original normals\n        // - create temp variables on first access\n        //   otherwise just copy (for faster repeated calls)\n        for (let f = 0, fl = this.faces.length; f < fl; f++) {\n            const face = this.faces[f];\n            if (!face.__originalFaceNormal) {\n                face.__originalFaceNormal = face.normal.clone();\n            }\n            else {\n                face.__originalFaceNormal.copy(face.normal);\n            }\n            if (!face.__originalVertexNormals)\n                face.__originalVertexNormals = [];\n            for (let i = 0, il = face.vertexNormals.length; i < il; i++) {\n                if (!face.__originalVertexNormals[i]) {\n                    face.__originalVertexNormals[i] = face.vertexNormals[i].clone();\n                }\n                else {\n                    face.__originalVertexNormals[i].copy(face.vertexNormals[i]);\n                }\n            }\n        }\n        // use temp geometry to compute face and vertex normals for each morph\n        const tmpGeo = new Gmetry(this.factory);\n        tmpGeo.faces = this.faces;\n        for (let i = 0, il = this.morphTargets.length; i < il; i++) {\n            // create on first access\n            if (!this.morphNormals[i]) {\n                this.morphNormals[i] = {}; // TODO: check\n                this.morphNormals[i].faceNormals = [];\n                this.morphNormals[i].vertexNormals = [];\n                const dstNormalsFace = this.morphNormals[i].faceNormals;\n                const dstNormalsVertex = this.morphNormals[i].vertexNormals;\n                for (let f = 0, fl = this.faces.length; f < fl; f++) {\n                    const faceNormal = this.factory.newVector3();\n                    const vertexNormals = { a: this.factory.newVector3(), b: this.factory.newVector3(), c: this.factory.newVector3() };\n                    dstNormalsFace.push(faceNormal);\n                    dstNormalsVertex.push(vertexNormals);\n                }\n            }\n            const morphNormals = this.morphNormals[i];\n            // set vertices to morph target\n            tmpGeo.vertices = this.morphTargets[i].vertices;\n            // compute morph normals\n            tmpGeo.computeFaceNormals();\n            tmpGeo.computeVertexNormals();\n            // store morph normals\n            for (let f = 0, fl = this.faces.length; f < fl; f++) {\n                const face = this.faces[f];\n                const faceNormal = morphNormals.faceNormals[f];\n                const vertexNormals = morphNormals.vertexNormals[f];\n                faceNormal.copy(face.normal);\n                vertexNormals.a.copy(face.vertexNormals[0]);\n                vertexNormals.b.copy(face.vertexNormals[1]);\n                vertexNormals.c.copy(face.vertexNormals[2]);\n            }\n        }\n        // restore original normals\n        for (let f = 0, fl = this.faces.length; f < fl; f++) {\n            const face = this.faces[f];\n            face.normal = face.__originalFaceNormal;\n            face.vertexNormals = face.__originalVertexNormals;\n        }\n    }\n    computeBoundingBox() {\n        if (this.boundingBox === null) {\n            this.boundingBox = this.factory.newBox3();\n        }\n        this.boundingBox.setFromPoints(this.vertices);\n    }\n    computeBoundingSphere() {\n        if (this.boundingSphere === null) {\n            this.boundingSphere = this.factory.newSphere();\n        }\n        this.boundingSphere.setFromPoints(this.vertices);\n    }\n    merge(geometry, matrix, materialIndexOffset = 0) {\n        if (!(geometry && geometry.isGeometry)) {\n            console.error(\"THREE.Geometry.merge(): geometry not an instance of THREE.Geometry.\", geometry);\n            return;\n        }\n        let normalMatrix;\n        const vertexOffset = this.vertices.length, vertices1 = this.vertices, vertices2 = geometry.vertices, faces1 = this.faces, faces2 = geometry.faces, colors1 = this.colors, colors2 = geometry.colors;\n        if (matrix !== undefined) {\n            normalMatrix = this.factory.newMatrix3().getNormalMatrix(matrix);\n        }\n        // vertices\n        for (let i = 0, il = vertices2.length; i < il; i++) {\n            const vertex = vertices2[i];\n            const vertexCopy = vertex.clone();\n            if (matrix !== undefined) {\n                vertexCopy.applyMatrix4(matrix);\n            }\n            vertices1.push(vertexCopy);\n        }\n        // colors\n        for (let i = 0, il = colors2.length; i < il; i++) {\n            colors1.push(colors2[i].clone());\n        }\n        // faces\n        for (let i = 0, il = faces2.length; i < il; i++) {\n            const face = faces2[i];\n            let normal;\n            let color;\n            const faceVertexNormals = face.vertexNormals, faceVertexColors = face.vertexColors;\n            const faceCopy = new Face3(face.a + vertexOffset, face.b + vertexOffset, face.c + vertexOffset);\n            faceCopy.normal.copy(face.normal);\n            if (normalMatrix !== undefined) {\n                faceCopy.normal.applyMatrix3(normalMatrix).normalize();\n            }\n            for (let j = 0, jl = faceVertexNormals.length; j < jl; j++) {\n                normal = faceVertexNormals[j].clone();\n                if (normalMatrix !== undefined) {\n                    normal.applyMatrix3(normalMatrix).normalize();\n                }\n                faceCopy.vertexNormals.push(normal);\n            }\n            faceCopy.color.copy(face.color);\n            for (let j = 0, jl = faceVertexColors.length; j < jl; j++) {\n                color = faceVertexColors[j];\n                faceCopy.vertexColors.push(color.clone());\n            }\n            faceCopy.materialIndex = face.materialIndex + materialIndexOffset;\n            faces1.push(faceCopy);\n        }\n        // uvs\n        for (let i = 0, il = geometry.faceVertexUvs.length; i < il; i++) {\n            const faceVertexUvs2 = geometry.faceVertexUvs[i];\n            if (this.faceVertexUvs[i] === undefined) {\n                this.faceVertexUvs[i] = [];\n            }\n            for (let j = 0, jl = faceVertexUvs2.length; j < jl; j++) {\n                const uvs2 = faceVertexUvs2[j], uvsCopy = [];\n                for (let k = 0, kl = uvs2.length; k < kl; k++) {\n                    uvsCopy.push(uvs2[k].clone());\n                }\n                this.faceVertexUvs[i].push(uvsCopy); // TODO: check\n            }\n        }\n    }\n    // TODO: the new version of Mesh operates on BufferGeometry\n    mergeMesh(mesh) {\n        if (!(mesh && mesh.isMesh)) {\n            console.error(\"THREE.Geometry.mergeMesh(): mesh not an instance of THREE.Mesh.\", mesh);\n            return;\n        }\n        if (mesh.matrixAutoUpdate) {\n            mesh.updateMatrix();\n        }\n        this.merge(mesh.geometry, mesh.matrix);\n    }\n    /*\n     * Checks for duplicate vertices with hashmap.\n     * Duplicated vertices are removed\n     * and faces' vertices are updated.\n     */\n    mergeVertices(precisionPoints = 4) {\n        const verticesMap = {}; // Hashmap for looking up vertices by position coordinates (and making sure they are unique)\n        const unique = [], changes = [];\n        const precision = Math.pow(10, precisionPoints);\n        for (let i = 0, il = this.vertices.length; i < il; i++) {\n            const v = this.vertices[i];\n            const key = Math.round(v.x * precision) + \"_\" + Math.round(v.y * precision) + \"_\" + Math.round(v.z * precision);\n            if (verticesMap[key] === undefined) {\n                verticesMap[key] = i;\n                unique.push(this.vertices[i]);\n                changes[i] = unique.length - 1;\n            }\n            else {\n                //console.log('Duplicate vertex found. ', i, ' could be using ', verticesMap[key]);\n                changes[i] = changes[verticesMap[key]];\n            }\n        }\n        // if faces are completely degenerate after merging vertices, we\n        // have to remove them from the geometry.\n        const faceIndicesToRemove = [];\n        for (let i = 0, il = this.faces.length; i < il; i++) {\n            const face = this.faces[i];\n            face.a = changes[face.a];\n            face.b = changes[face.b];\n            face.c = changes[face.c];\n            const indices = [face.a, face.b, face.c];\n            // if any duplicate vertices are found in a Face3\n            // we have to remove the face as nothing can be saved\n            for (let n = 0; n < 3; n++) {\n                if (indices[n] === indices[(n + 1) % 3]) {\n                    faceIndicesToRemove.push(i);\n                    break;\n                }\n            }\n        }\n        for (let i = faceIndicesToRemove.length - 1; i >= 0; i--) {\n            const idx = faceIndicesToRemove[i];\n            this.faces.splice(idx, 1);\n            for (let j = 0, jl = this.faceVertexUvs.length; j < jl; j++) {\n                this.faceVertexUvs[j].splice(idx, 1);\n            }\n        }\n        // Use unique set of vertices\n        const diff = this.vertices.length - unique.length;\n        this.vertices = unique;\n        return diff;\n    }\n    setFromPoints(points) {\n        this.vertices = [];\n        for (let i = 0, l = points.length; i < l; i++) {\n            const point = points[i];\n            // TODO: verify\n            // this.vertices.push( new Vector3( point.x, point.y, point.z || 0 ) );\n            //   this.vertices.push(this.factory.newVector3(point.x, point.y, point.z || 0));\n            this.vertices.push(this.factory.newVector3(point.x, point.y, point.z || 0));\n        }\n        return this;\n    }\n    sortFacesByMaterialIndex() {\n        const faces = this.faces;\n        const length = faces.length;\n        // tag faces\n        for (let i = 0; i < length; i++) {\n            faces[i]._id = i;\n        }\n        // sort faces\n        function materialIndexSort(a, b) {\n            return a.materialIndex - b.materialIndex;\n        }\n        faces.sort(materialIndexSort);\n        // sort uvs\n        const uvs1 = this.faceVertexUvs[0];\n        const uvs2 = this.faceVertexUvs[1];\n        let newUvs1, newUvs2;\n        if (uvs1 && uvs1.length === length) {\n            newUvs1 = [];\n        }\n        if (uvs2 && uvs2.length === length) {\n            newUvs2 = [];\n        }\n        for (let i = 0; i < length; i++) {\n            const id = faces[i]._id;\n            if (newUvs1)\n                newUvs1.push(uvs1[id]);\n            if (newUvs2)\n                newUvs2.push(uvs2[id]);\n        }\n        if (newUvs1) {\n            this.faceVertexUvs[0] = newUvs1;\n        }\n        if (newUvs2) {\n            this.faceVertexUvs[1] = newUvs2;\n        }\n    }\n    toJSON() {\n        const data = {\n            metadata: {\n                version: 4.5,\n                type: \"Geometry\",\n                generator: \"Geometry.toJSON\"\n            },\n            // TODO: check\n            uuid: null,\n            type: null,\n            name: null,\n            data: null\n        };\n        // standard Geometry serialization\n        data.uuid = this.uuid;\n        data.type = this.type;\n        if (this.name !== \"\")\n            data.name = this.name;\n        if (this.parameters !== undefined) {\n            const parameters = this.parameters;\n            for (const key in parameters) {\n                if (parameters[key] !== undefined)\n                    data[key] = parameters[key];\n            }\n            return data;\n        }\n        const vertices = [];\n        for (let i = 0; i < this.vertices.length; i++) {\n            const vertex = this.vertices[i];\n            vertices.push(vertex.x, vertex.y, vertex.z);\n        }\n        const faces = [];\n        const normals = [];\n        const normalsHash = {};\n        const colors = [];\n        const colorsHash = {};\n        const uvs = [];\n        const uvsHash = {};\n        for (let i = 0; i < this.faces.length; i++) {\n            const face = this.faces[i];\n            const hasMaterial = true;\n            const hasFaceUv = false; // deprecated\n            const hasFaceVertexUv = this.faceVertexUvs[0][i] !== undefined;\n            const hasFaceNormal = face.normal.length() > 0;\n            const hasFaceVertexNormal = face.vertexNormals.length > 0;\n            const hasFaceColor = face.color.r !== 1 || face.color.g !== 1 || face.color.b !== 1;\n            const hasFaceVertexColor = face.vertexColors.length > 0;\n            let faceType = 0;\n            // TODO: move to helpers?\n            const setBit = (value, position, enabled) => {\n                return enabled ? value | (1 << position) : value & ~(1 << position);\n            };\n            // TODO: move to helpers?\n            const getNormalIndex = (normal) => {\n                const hash = normal.x.toString() + normal.y.toString() + normal.z.toString();\n                if (normalsHash[hash] !== undefined) {\n                    return normalsHash[hash];\n                }\n                normalsHash[hash] = normals.length / 3;\n                normals.push(normal.x, normal.y, normal.z);\n                return normalsHash[hash];\n            };\n            // TODO: move to helpers?\n            const getColorIndex = (color) => {\n                const hash = color.r.toString() + color.g.toString() + color.b.toString();\n                if (colorsHash[hash] !== undefined) {\n                    return colorsHash[hash];\n                }\n                colorsHash[hash] = colors.length;\n                colors.push(color.getHex());\n                return colorsHash[hash];\n            };\n            // TODO: move to helpers?\n            const getUvIndex = (uv) => {\n                const hash = uv.x.toString() + uv.y.toString();\n                if (uvsHash[hash] !== undefined) {\n                    return uvsHash[hash];\n                }\n                uvsHash[hash] = uvs.length / 2;\n                uvs.push(uv.x, uv.y);\n                return uvsHash[hash];\n            };\n            faceType = setBit(faceType, 0, 0); // isQuad\n            faceType = setBit(faceType, 1, hasMaterial);\n            faceType = setBit(faceType, 2, hasFaceUv);\n            faceType = setBit(faceType, 3, hasFaceVertexUv);\n            faceType = setBit(faceType, 4, hasFaceNormal);\n            faceType = setBit(faceType, 5, hasFaceVertexNormal);\n            faceType = setBit(faceType, 6, hasFaceColor);\n            faceType = setBit(faceType, 7, hasFaceVertexColor);\n            faces.push(faceType);\n            faces.push(face.a, face.b, face.c);\n            faces.push(face.materialIndex);\n            if (hasFaceVertexUv) {\n                const faceVertexUvs = this.faceVertexUvs[0][i];\n                faces.push(getUvIndex(faceVertexUvs[0]), getUvIndex(faceVertexUvs[1]), getUvIndex(faceVertexUvs[2]));\n            }\n            if (hasFaceNormal) {\n                faces.push(getNormalIndex(face.normal));\n            }\n            if (hasFaceVertexNormal) {\n                const vertexNormals = face.vertexNormals;\n                faces.push(getNormalIndex(vertexNormals[0]), getNormalIndex(vertexNormals[1]), getNormalIndex(vertexNormals[2]));\n            }\n            if (hasFaceColor) {\n                faces.push(getColorIndex(face.color));\n            }\n            if (hasFaceVertexColor) {\n                const vertexColors = face.vertexColors;\n                faces.push(getColorIndex(vertexColors[0]), getColorIndex(vertexColors[1]), getColorIndex(vertexColors[2]));\n            }\n        }\n        // // TODO: move to helpers?\n        // const setBit = (value: number, position: number, enabled: boolean | number) => {\n        //   return enabled ? value | (1 << position) : value & ~(1 << position);\n        // };\n        // // TODO: move to helpers?\n        // const getNormalIndex = (normal: Vector3) => {\n        //   const hash = normal.x.toString() + normal.y.toString() + normal.z.toString();\n        //   if (normalsHash[hash] !== undefined) {\n        //     return normalsHash[hash];\n        //   }\n        //   normalsHash[hash] = normals.length / 3;\n        //   normals.push(normal.x, normal.y, normal.z);\n        //   return normalsHash[hash];\n        // };\n        // // TODO: move to helpers?\n        // const getColorIndex = (color: Color) => {\n        //   const hash = color.r.toString() + color.g.toString() + color.b.toString();\n        //   if (colorsHash[hash] !== undefined) {\n        //     return colorsHash[hash];\n        //   }\n        //   colorsHash[hash] = colors.length;\n        //   colors.push(color.getHex());\n        //   return colorsHash[hash];\n        // };\n        // // TODO: move to helpers?\n        // const getUvIndex = (uv: Vector2) => {\n        //   const hash = uv.x.toString() + uv.y.toString();\n        //   if (uvsHash[hash] !== undefined) {\n        //     return uvsHash[hash];\n        //   }\n        //   uvsHash[hash] = uvs.length / 2;\n        //   uvs.push(uv.x, uv.y);\n        //   return uvsHash[hash];\n        // };\n        data.data = {};\n        data.data.vertices = vertices;\n        data.data.normals = normals;\n        if (colors.length > 0) {\n            data.data.colors = colors;\n        }\n        if (uvs.length > 0) {\n            data.data.uvs = [uvs]; // temporal backward compatibility\n        }\n        data.data.faces = faces;\n        return data;\n    }\n    clone() {\n        /*\n             // Handle primitives\n    \n             const parameters = this.parameters;\n    \n             if ( parameters !== undefined ) {\n    \n             const values = [];\n    \n             for ( const key in parameters ) {\n    \n             values.push( parameters[ key ] );\n    \n             }\n    \n             const geometry = Object.create( this.constructor.prototype );\n             this.constructor.apply( geometry, values );\n             return geometry;\n    \n             }\n    \n             return new this.constructor().copy( this );\n             */\n        // return new Geometry().copy( this ); // BEFORE\n        return new Gmetry(this.factory).copy(this);\n    }\n    copy(source) {\n        // reset\n        this.vertices = [];\n        this.colors = [];\n        this.faces = [];\n        this.faceVertexUvs = [[]];\n        this.morphTargets = [];\n        this.morphNormals = [];\n        this.skinWeights = [];\n        this.skinIndices = [];\n        this.lineDistances = [];\n        this.boundingBox = null;\n        this.boundingSphere = null;\n        // name\n        this.name = source.name;\n        // vertices\n        const vertices = source.vertices;\n        for (let i = 0, il = vertices.length; i < il; i++) {\n            this.vertices.push(vertices[i].clone());\n        }\n        // colors\n        const colors = source.colors;\n        for (let i = 0, il = colors.length; i < il; i++) {\n            this.colors.push(colors[i].clone());\n        }\n        // faces\n        const faces = source.faces;\n        for (let i = 0, il = faces.length; i < il; i++) {\n            this.faces.push(faces[i].clone());\n        }\n        // face vertex uvs\n        for (let i = 0, il = source.faceVertexUvs.length; i < il; i++) {\n            const faceVertexUvs = source.faceVertexUvs[i];\n            if (this.faceVertexUvs[i] === undefined) {\n                this.faceVertexUvs[i] = [];\n            }\n            for (let j = 0, jl = faceVertexUvs.length; j < jl; j++) {\n                const uvs = faceVertexUvs[j], uvsCopy = [];\n                for (let k = 0, kl = uvs.length; k < kl; k++) {\n                    const uv = uvs[k];\n                    uvsCopy.push(uv.clone());\n                }\n                this.faceVertexUvs[i].push(uvsCopy); // TODO: check\n            }\n        }\n        // morph targets\n        const morphTargets = source.morphTargets;\n        for (let i = 0, il = morphTargets.length; i < il; i++) {\n            const morphTarget = {}; // // TODO: check\n            morphTarget.name = morphTargets[i].name;\n            // vertices\n            if (morphTargets[i].vertices !== undefined) {\n                morphTarget.vertices = [];\n                for (let j = 0, jl = morphTargets[i].vertices.length; j < jl; j++) {\n                    morphTarget.vertices.push(morphTargets[i].vertices[j].clone());\n                }\n            }\n            // normals\n            if (morphTargets[i].normals !== undefined) {\n                morphTarget.normals = [];\n                for (let j = 0, jl = morphTargets[i].normals.length; j < jl; j++) {\n                    morphTarget.normals.push(morphTargets[i].normals[j].clone());\n                }\n            }\n            this.morphTargets.push(morphTarget);\n        }\n        // morph normals\n        const morphNormals = source.morphNormals;\n        for (let i = 0, il = morphNormals.length; i < il; i++) {\n            const morphNormal = {};\n            // vertex normals\n            if (morphNormals[i].vertexNormals !== undefined) {\n                morphNormal.vertexNormals = [];\n                for (let j = 0, jl = morphNormals[i].vertexNormals.length; j < jl; j++) {\n                    const srcVertexNormal = morphNormals[i].vertexNormals[j];\n                    // TODO: add type\n                    const destVertexNormal = { a: null, b: null, c: null };\n                    destVertexNormal.a = srcVertexNormal.a.clone();\n                    destVertexNormal.b = srcVertexNormal.b.clone();\n                    destVertexNormal.c = srcVertexNormal.c.clone();\n                    morphNormal.vertexNormals.push(destVertexNormal);\n                }\n            }\n            // face normals\n            if (morphNormals[i].faceNormals !== undefined) {\n                morphNormal.faceNormals = [];\n                for (let j = 0, jl = morphNormals[i].faceNormals.length; j < jl; j++) {\n                    morphNormal.faceNormals.push(morphNormals[i].faceNormals[j].clone());\n                }\n            }\n            this.morphNormals.push(morphNormal);\n        }\n        // skin weights\n        const skinWeights = source.skinWeights;\n        for (let i = 0, il = skinWeights.length; i < il; i++) {\n            this.skinWeights.push(skinWeights[i].clone());\n        }\n        // skin indices\n        const skinIndices = source.skinIndices;\n        for (let i = 0, il = skinIndices.length; i < il; i++) {\n            this.skinIndices.push(skinIndices[i].clone());\n        }\n        // line distances\n        const lineDistances = source.lineDistances;\n        for (let i = 0, il = lineDistances.length; i < il; i++) {\n            this.lineDistances.push(lineDistances[i]);\n        }\n        // bounding box\n        const boundingBox = source.boundingBox;\n        if (boundingBox !== null) {\n            this.boundingBox = boundingBox.clone();\n        }\n        // bounding sphere\n        const boundingSphere = source.boundingSphere;\n        if (boundingSphere !== null) {\n            this.boundingSphere = boundingSphere.clone();\n        }\n        // update flags\n        this.elementsNeedUpdate = source.elementsNeedUpdate;\n        this.verticesNeedUpdate = source.verticesNeedUpdate;\n        this.uvsNeedUpdate = source.uvsNeedUpdate;\n        this.normalsNeedUpdate = source.normalsNeedUpdate;\n        this.colorsNeedUpdate = source.colorsNeedUpdate;\n        this.lineDistancesNeedUpdate = source.lineDistancesNeedUpdate;\n        this.groupsNeedUpdate = source.groupsNeedUpdate;\n        return this;\n    }\n    toBufferGeometry() {\n        const geometry = new DirectGeometry(this.factory).fromGeometry(this);\n        // TODO: verify\n        // const buffergeometry = new BufferGeometry();\n        const buffergeometry = this.factory.newBufferGeometry();\n        const positions = new Float32Array(geometry.vertices.length * 3);\n        // TODO: verfify\n        // buffergeometry.setAttribute( 'position', new BufferAttribute( positions, 3 ).copyVector3sArray( geometry.vertices ) );\n        buffergeometry.setAttribute(\"position\", this.factory.newBufferAttribute(positions, 3).copyVector3sArray(geometry.vertices));\n        if (geometry.normals.length > 0) {\n            const normals = new Float32Array(geometry.normals.length * 3);\n            // TODO: verfify\n            // buffergeometry.setAttribute( 'normal', new BufferAttribute( normals, 3 ).copyVector3sArray( geometry.normals ) );\n            buffergeometry.setAttribute(\"normal\", this.factory.newBufferAttribute(normals, 3).copyVector3sArray(geometry.normals));\n        }\n        if (geometry.colors.length > 0) {\n            const colors = new Float32Array(geometry.colors.length * 3);\n            // TODO: verfify\n            // buffergeometry.setAttribute( 'color', new BufferAttribute( colors, 3 ).copyColorsArray( geometry.colors ) );\n            buffergeometry.setAttribute(\"color\", this.factory.newBufferAttribute(colors, 3).copyColorsArray(geometry.colors));\n        }\n        if (geometry.uvs.length > 0) {\n            const uvs = new Float32Array(geometry.uvs.length * 2);\n            // TODO: verfify\n            // buffergeometry.setAttribute( 'uv', new BufferAttribute( uvs, 2 ).copyVector2sArray( geometry.uvs ) );\n            buffergeometry.setAttribute(\"uv\", this.factory.newBufferAttribute(uvs, 2).copyVector2sArray(geometry.uvs));\n        }\n        if (geometry.uvs2.length > 0) {\n            const uvs2 = new Float32Array(geometry.uvs2.length * 2);\n            // TODO: verfify\n            // buffergeometry.setAttribute( 'uv2', new BufferAttribute( uvs2, 2 ).copyVector2sArray( geometry.uvs2 ) );\n            buffergeometry.setAttribute(\"uv2\", this.factory.newBufferAttribute(uvs2, 2).copyVector2sArray(geometry.uvs2));\n        }\n        // groups\n        buffergeometry.groups = geometry.groups;\n        // morphs\n        for (const name in geometry.morphTargets) {\n            const array = [];\n            const morphTargets = geometry.morphTargets[name];\n            for (let i = 0, l = morphTargets.length; i < l; i++) {\n                const morphTarget = morphTargets[i];\n                // TODO: verify\n                // const attribute = new Float32BufferAttribute( morphTarget.data.length * 3, 3 );\n                const attribute = this.factory.newFloat32BufferAttribute(morphTarget.data.length * 3, 3);\n                attribute.name = morphTarget.name;\n                array.push(attribute.copyVector3sArray(morphTarget.data));\n            }\n            buffergeometry.morphAttributes[name] = array;\n        }\n        // skinning\n        if (geometry.skinIndices.length > 0) {\n            const skinIndices = this.factory.newFloat32BufferAttribute(geometry.skinIndices.length * 4, 4);\n            buffergeometry.setAttribute(\"skinIndex\", skinIndices.copyVector4sArray(geometry.skinIndices));\n        }\n        if (geometry.skinWeights.length > 0) {\n            const skinWeights = this.factory.newFloat32BufferAttribute(geometry.skinWeights.length * 4, 4);\n            buffergeometry.setAttribute(\"skinWeight\", skinWeights.copyVector4sArray(geometry.skinWeights));\n        }\n        //\n        if (geometry.boundingSphere !== null) {\n            buffergeometry.boundingSphere = geometry.boundingSphere.clone();\n        }\n        if (geometry.boundingBox !== null) {\n            buffergeometry.boundingBox = geometry.boundingBox.clone();\n        }\n        return buffergeometry;\n    }\n    computeTangents() {\n        console.error(\"THREE.Geometry: .computeTangents() has been removed.\");\n    }\n    computeLineDistances() {\n        console.error(\"THREE.Geometry: .computeLineDistances() has been removed. Use THREE.Line.computeLineDistances() instead.\");\n    }\n    applyMatrix(matrix) {\n        console.warn(\"THREE.Geometry: .applyMatrix() has been renamed to .applyMatrix4().\");\n        return this.applyMatrix4(matrix);\n    }\n    dispose() {\n        // This is not required when used outside of THREE.\n        // this.dispatchEvent( { type: 'dispose' } );\n    }\n    // TODO: can we specify and types for 'object' here?\n    static createBufferGeometryFromObject(object, factory) {\n        const fact = factory || DefaultFactory;\n        let buffergeometry = fact.newBufferGeometry();\n        const geometry = object.geometry;\n        if (object.isPoints || object.isLine) {\n            const positions = fact.newFloat32BufferAttribute(geometry.vertices.length * 3, 3);\n            const colors = fact.newFloat32BufferAttribute(geometry.colors.length * 3, 3);\n            buffergeometry.setAttribute(\"position\", positions.copyVector3sArray(geometry.vertices));\n            buffergeometry.setAttribute(\"color\", colors.copyColorsArray(geometry.colors));\n            if (geometry.lineDistances && geometry.lineDistances.length === geometry.vertices.length) {\n                const lineDistances = fact.newFloat32BufferAttribute(geometry.lineDistances.length, 1);\n                buffergeometry.setAttribute(\"lineDistance\", lineDistances.copyArray(geometry.lineDistances));\n            }\n            if (geometry.boundingSphere !== null) {\n                buffergeometry.boundingSphere = geometry.boundingSphere.clone();\n            }\n            if (geometry.boundingBox !== null) {\n                buffergeometry.boundingBox = geometry.boundingBox.clone();\n            }\n        }\n        else if (object.isMesh) {\n            buffergeometry = geometry.toBufferGeometry();\n        }\n        return buffergeometry;\n    }\n}\n//# sourceMappingURL=Gmetry.js.map","import { DefaultFactory } from \"./DefaultFactory\";\nimport { DirectGeometry } from \"./DirectGeometry\";\nimport { Face3 } from \"./Face3\";\nimport { Gmetry } from \"./Gmetry\";\nexport const ThreeGeometryHellfix = {\n    DirectGeometry,\n    Face3,\n    Gmetry,\n    DefaultFactory\n};\n//# sourceMappingURL=mylibrary.js.map"],"names":["DefaultFactory","newVector2","x","y","window","Vector2","newVector3","z","Vector3","newMatrix3","Matrix3","newMatrix4","Matrix4","newObject3D","Object3D","newBox3","Box3","newSphere","Sphere","newBufferGeometry","BufferGeometry","generateUUID","MathUtils","newFloat32BufferAttribute","array","itemSize","normalized","Float32BufferAttribute","newColor","Color","newBufferAttribute","BufferAttribute","DirectGeometry","constructor","factory","this","vertices","normals","colors","uvs","uvs2","groups","morphTargets","skinWeights","skinIndices","boundingBox","boundingSphere","verticesNeedUpdate","normalsNeedUpdate","colorsNeedUpdate","uvsNeedUpdate","groupsNeedUpdate","computeGroups","geometry","group","i","materialIndex","faces","length","face","undefined","count","start","push","fromGeometry","faceVertexUvs","hasFaceVertexUv","hasFaceVertexUv2","morphTargetsLength","morphTargetsPosition","name","data","position","morphNormals","morphNormalsLength","morphTargetsNormal","normal","hasSkinIndices","hasSkinWeights","console","error","a","b","c","vertexNormals","vertexColors","color","vertexUvs","warn","j","morphTarget","morphNormal","clone","Face3","fact","isVector3","Array","isArray","isColor","copy","source","il","Gmetry","type","lineDistances","elementsNeedUpdate","lineDistancesNeedUpdate","isGeometry","uuid","_m1","_obj","_offset","applyMatrix4","matrix","normalMatrix","getNormalMatrix","applyMatrix3","normalize","jl","computeBoundingBox","computeBoundingSphere","rotateX","angle","makeRotationX","rotateY","makeRotationY","rotateZ","makeRotationZ","translate","makeTranslation","scale","makeScale","lookAt","vector","updateMatrix","fromBufferGeometry","scope","index","attributes","uv","uv2","fromBufferAttribute","addFace","getX","computeFaceNormals","center","getCenter","negate","radius","s","set","cb","ab","f","fl","vA","vB","vC","subVectors","cross","computeVertexNormals","areaWeighted","v","vl","add","computeFlatVertexNormals","computeMorphNormals","__originalFaceNormal","__originalVertexNormals","tmpGeo","faceNormals","dstNormalsFace","dstNormalsVertex","faceNormal","setFromPoints","merge","materialIndexOffset","vertexOffset","vertices1","vertices2","faces1","faces2","colors1","colors2","vertexCopy","faceVertexNormals","faceVertexColors","faceCopy","faceVertexUvs2","uvsCopy","k","kl","mergeMesh","mesh","isMesh","matrixAutoUpdate","mergeVertices","precisionPoints","verticesMap","unique","changes","precision","Math","pow","key","round","faceIndicesToRemove","indices","n","idx","splice","diff","points","l","point","sortFacesByMaterialIndex","_id","sort","uvs1","newUvs1","newUvs2","id","toJSON","metadata","version","generator","parameters","vertex","normalsHash","colorsHash","uvsHash","hasMaterial","hasFaceUv","hasFaceNormal","hasFaceVertexNormal","hasFaceColor","r","g","hasFaceVertexColor","faceType","setBit","value","enabled","getNormalIndex","hash","toString","getColorIndex","getHex","getUvIndex","srcVertexNormal","destVertexNormal","toBufferGeometry","buffergeometry","positions","Float32Array","setAttribute","copyVector3sArray","copyColorsArray","copyVector2sArray","attribute","morphAttributes","copyVector4sArray","computeTangents","computeLineDistances","applyMatrix","dispose","static","object","isPoints","isLine","copyArray","ThreeGeometryHellfix"],"sourceRoot":""}