"use strict";(self.webpackChunkthreejs_slice_geometry_typescript=self.webpackChunkthreejs_slice_geometry_typescript||[]).push([[736],{686:(e,t,s)=>{s.r(t),s.d(t,{DirectGeometry:()=>r,Face3:()=>n,Gmetry:()=>i,ThreeGeometryHellfix:()=>a});const o={newVector2:(e,t)=>new window.THREE.Vector2(e,t),newVector3:(e,t,s)=>new window.THREE.Vector3(e,t,s),newMatrix3:()=>new window.THREE.Matrix3,newMatrix4:()=>new window.THREE.Matrix4,newObject3D:()=>new window.THREE.Object3D,newBox3:()=>new window.THREE.Box3,newSphere:()=>new window.THREE.Sphere,newBufferGeometry:()=>new window.THREE.BufferGeometry,generateUUID:()=>window.THREE.MathUtils.generateUUID(),newFloat32BufferAttribute:(e,t,s)=>new window.THREE.Float32BufferAttribute(e,t,s),newColor:()=>new window.THREE.Color,newBufferAttribute:(e,t,s)=>new window.THREE.BufferAttribute(e,t,s)};class r{constructor(e){this.vertices=[],this.normals=[],this.colors=[],this.uvs=[],this.uvs2=[],this.groups=[],this.morphTargets={},this.skinWeights=[],this.skinIndices=[],this.boundingBox=null,this.boundingSphere=null,this.verticesNeedUpdate=!1,this.normalsNeedUpdate=!1,this.colorsNeedUpdate=!1,this.uvsNeedUpdate=!1,this.groupsNeedUpdate=!1,this.factory=e||o}computeGroups(e){const t=[];let s,o,r;const n=e.faces;for(o=0;o<n.length;o++){const e=n[o];e.materialIndex!==r&&(r=e.materialIndex,void 0!==s&&(s.count=3*o-s.start,t.push(s)),s={start:3*o,materialIndex:r})}void 0!==s&&(s.count=3*o-s.start,t.push(s)),this.groups=t}fromGeometry(e){const t=e.faces,s=e.vertices,o=e.faceVertexUvs,r=o[0]&&o[0].length>0,n=o[1]&&o[1].length>0,i=e.morphTargets,a=i.length;let c;if(a>0){c=[];for(let e=0;e<a;e++)c[e]={name:i[e].name,data:[]};this.morphTargets.position=c}const l=e.morphNormals,h=l.length;let u;if(h>0){u=[];for(let e=0;e<h;e++)u[e]={name:l[e].name,data:[]};this.morphTargets.normal=u}const f=e.skinIndices,m=e.skinWeights,p=f.length===s.length,d=m.length===s.length;s.length>0&&0===t.length&&console.error("THREE.DirectGeometry: Faceless geometries are not supported.");for(let e=0;e<t.length;e++){const g=t[e];this.vertices.push(s[g.a],s[g.b],s[g.c]);const v=g.vertexNormals;if(3===v.length)this.normals.push(v[0],v[1],v[2]);else{const e=g.normal;this.normals.push(e,e,e)}const y=g.vertexColors;if(3===y.length)this.colors.push(y[0],y[1],y[2]);else{const e=g.color;this.colors.push(e,e,e)}if(!0===r){const t=o[0][e];void 0!==t?this.uvs.push(t[0],t[1],t[2]):(console.warn("THREE.DirectGeometry.fromGeometry(): Undefined vertexUv ",e),this.uvs.push(this.factory.newVector2(),this.factory.newVector2(),this.factory.newVector2()))}if(!0===n){const t=o[1][e];void 0!==t?this.uvs2.push(t[0],t[1],t[2]):(console.warn("THREE.DirectGeometry.fromGeometry(): Undefined vertexUv2 ",e),this.uvs2.push(this.factory.newVector2(),this.factory.newVector2(),this.factory.newVector2()))}for(let e=0;e<a;e++){const t=i[e].vertices;c[e].data.push(t[g.a],t[g.b],t[g.c])}for(let t=0;t<h;t++){const s=l[t].vertexNormals[e];u[t].data.push(s.a,s.b,s.c)}p&&this.skinIndices.push(f[g.a],f[g.b],f[g.c]),d&&this.skinWeights.push(m[g.a],m[g.b],m[g.c])}return this.computeGroups(e),this.verticesNeedUpdate=e.verticesNeedUpdate,this.normalsNeedUpdate=e.normalsNeedUpdate,this.colorsNeedUpdate=e.colorsNeedUpdate,this.uvsNeedUpdate=e.uvsNeedUpdate,this.groupsNeedUpdate=e.groupsNeedUpdate,null!==e.boundingSphere&&(this.boundingSphere=e.boundingSphere.clone()),null!==e.boundingBox&&(this.boundingBox=e.boundingBox.clone()),this}}class n{constructor(e,t,s,r,n,i=0,a){var c=a||o;this.a=e,this.b=t,this.c=s,this.normal=r&&r.isVector3?r:c.newVector3(),this.vertexNormals=Array.isArray(r)?r:[],this.color=n&&n.isColor?n:c.newColor(),this.vertexColors=Array.isArray(n)?n:[],this.materialIndex=i}clone(){return new n(this.a,this.b,this.c,this.normal.clone(),this.color.clone(),this.materialIndex).copy(this)}copy(e){this.a=e.a,this.b=e.b,this.c=e.c,this.normal.copy(e.normal),this.color.copy(e.color),this.materialIndex=e.materialIndex;for(let t=0,s=e.vertexNormals.length;t<s;t++)this.vertexNormals[t]=e.vertexNormals[t].clone();for(let t=0,s=e.vertexColors.length;t<s;t++)this.vertexColors[t]=e.vertexColors[t].clone();return this}}class i{constructor(e){this.name="",this.type="Geometry",this.vertices=[],this.colors=[],this.faces=[],this.faceVertexUvs=[[]],this.morphTargets=[],this.morphNormals=[],this.skinWeights=[],this.skinIndices=[],this.lineDistances=[],this.boundingBox=null,this.boundingSphere=null,this.elementsNeedUpdate=!1,this.verticesNeedUpdate=!1,this.uvsNeedUpdate=!1,this.normalsNeedUpdate=!1,this.colorsNeedUpdate=!1,this.lineDistancesNeedUpdate=!1,this.groupsNeedUpdate=!1,this.isGeometry=!0,this.factory=e||o,this.uuid=this.factory.generateUUID(),this._m1=this.factory.newMatrix4(),this._obj=this.factory.newObject3D(),this._offset=this.factory.newVector3()}applyMatrix4(e){const t=this.factory.newMatrix3().getNormalMatrix(e);for(let t=0,s=this.vertices.length;t<s;t++){this.vertices[t].applyMatrix4(e)}for(let e=0,s=this.faces.length;e<s;e++){const s=this.faces[e];s.normal.applyMatrix3(t).normalize();for(let e=0,o=s.vertexNormals.length;e<o;e++)s.vertexNormals[e].applyMatrix3(t).normalize()}return null!==this.boundingBox&&this.computeBoundingBox(),null!==this.boundingSphere&&this.computeBoundingSphere(),this.verticesNeedUpdate=!0,this.normalsNeedUpdate=!0,this}rotateX(e){return this._m1.makeRotationX(e),this.applyMatrix4(this._m1),this}rotateY(e){return this._m1.makeRotationY(e),this.applyMatrix4(this._m1),this}rotateZ(e){return this._m1.makeRotationZ(e),this.applyMatrix4(this._m1),this}translate(e,t,s){return this._m1.makeTranslation(e,t,s),this.applyMatrix4(this._m1),this}scale(e,t,s){return this._m1.makeScale(e,t,s),this.applyMatrix4(this._m1),this}lookAt(e){return this._obj.lookAt(e),this._obj.updateMatrix(),this.applyMatrix4(this._obj.matrix),this}fromBufferGeometry(e){const t=this,s=null!==e.index?e.index:void 0,o=e.attributes;if(void 0===o.position)return console.error("THREE.Geometry.fromBufferGeometry(): Position attribute required for conversion."),this;const r=o.position,i=o.normal,a=o.color,c=o.uv,l=o.uv2;void 0!==l&&(this.faceVertexUvs[1]=[]);for(let e=0;e<r.count;e++)t.vertices.push(this.factory.newVector3().fromBufferAttribute(r,e)),void 0!==a&&t.colors.push(this.factory.newColor().fromBufferAttribute(a,e));const h=this.factory,u=(e,s,o,r)=>{const u=void 0===a?[]:[t.colors[e].clone(),t.colors[s].clone(),t.colors[o].clone()],f=void 0===i?[]:[h.newVector3().fromBufferAttribute(i,e),h.newVector3().fromBufferAttribute(i,s),h.newVector3().fromBufferAttribute(i,o)],m=new n(e,s,o,f,u,r);t.faces.push(m),void 0!==c&&t.faceVertexUvs[0].push([h.newVector2().fromBufferAttribute(c,e),h.newVector2().fromBufferAttribute(c,s),h.newVector2().fromBufferAttribute(c,o)]),void 0!==l&&t.faceVertexUvs[1].push([h.newVector2().fromBufferAttribute(l,e),h.newVector2().fromBufferAttribute(l,s),h.newVector2().fromBufferAttribute(l,o)])},f=e.groups;if(f.length>0)for(let e=0;e<f.length;e++){const t=f[e],o=t.start;for(let e=o,r=o+t.count;e<r;e+=3)void 0!==s?u(s.getX(e),s.getX(e+1),s.getX(e+2),t.materialIndex):u(e,e+1,e+2,t.materialIndex)}else if(void 0!==s)for(let e=0;e<s.count;e+=3)u(s.getX(e),s.getX(e+1),s.getX(e+2));else for(let e=0;e<r.count;e+=3)u(e,e+1,e+2);return this.computeFaceNormals(),null!==e.boundingBox&&(this.boundingBox=e.boundingBox.clone()),null!==e.boundingSphere&&(this.boundingSphere=e.boundingSphere.clone()),this}center(){return this.computeBoundingBox(),this.boundingBox.getCenter(this._offset).negate(),this.translate(this._offset.x,this._offset.y,this._offset.z),this}normalize(){this.computeBoundingSphere();const e=this.boundingSphere.center,t=this.boundingSphere.radius,s=0===t?1:1/t,o=this.factory.newMatrix4();return o.set(s,0,0,-s*e.x,0,s,0,-s*e.y,0,0,s,-s*e.z,0,0,0,1),this.applyMatrix4(o),this}computeFaceNormals(){const e=this.factory.newVector3(),t=this.factory.newVector3();for(let s=0,o=this.faces.length;s<o;s++){const o=this.faces[s],r=this.vertices[o.a],n=this.vertices[o.b],i=this.vertices[o.c];e.subVectors(i,n),t.subVectors(r,n),e.cross(t),e.normalize(),o.normal.copy(e)}}computeVertexNormals(e=!0){const t=new Array(this.vertices.length);for(let e=0,s=this.vertices.length;e<s;e++)t[e]=this.factory.newVector3();if(e){const e=this.factory.newVector3(),s=this.factory.newVector3();for(let o=0,r=this.faces.length;o<r;o++){const r=this.faces[o],n=this.vertices[r.a],i=this.vertices[r.b],a=this.vertices[r.c];e.subVectors(a,i),s.subVectors(n,i),e.cross(s),t[r.a].add(e),t[r.b].add(e),t[r.c].add(e)}}else{this.computeFaceNormals();for(let e=0,s=this.faces.length;e<s;e++){const s=this.faces[e];t[s.a].add(s.normal),t[s.b].add(s.normal),t[s.c].add(s.normal)}}for(let e=0,s=this.vertices.length;e<s;e++)t[e].normalize();for(let e=0,s=this.faces.length;e<s;e++){const s=this.faces[e],o=s.vertexNormals;3===o.length?(o[0].copy(t[s.a]),o[1].copy(t[s.b]),o[2].copy(t[s.c])):(o[0]=t[s.a].clone(),o[1]=t[s.b].clone(),o[2]=t[s.c].clone())}this.faces.length>0&&(this.normalsNeedUpdate=!0)}computeFlatVertexNormals(){this.computeFaceNormals();for(let e=0,t=this.faces.length;e<t;e++){const t=this.faces[e],s=t.vertexNormals;3===s.length?(s[0].copy(t.normal),s[1].copy(t.normal),s[2].copy(t.normal)):(s[0]=t.normal.clone(),s[1]=t.normal.clone(),s[2]=t.normal.clone())}this.faces.length>0&&(this.normalsNeedUpdate=!0)}computeMorphNormals(){for(let e=0,t=this.faces.length;e<t;e++){const t=this.faces[e];t.__originalFaceNormal?t.__originalFaceNormal.copy(t.normal):t.__originalFaceNormal=t.normal.clone(),t.__originalVertexNormals||(t.__originalVertexNormals=[]);for(let e=0,s=t.vertexNormals.length;e<s;e++)t.__originalVertexNormals[e]?t.__originalVertexNormals[e].copy(t.vertexNormals[e]):t.__originalVertexNormals[e]=t.vertexNormals[e].clone()}const e=new i(this.factory);e.faces=this.faces;for(let t=0,s=this.morphTargets.length;t<s;t++){if(!this.morphNormals[t]){this.morphNormals[t]={},this.morphNormals[t].faceNormals=[],this.morphNormals[t].vertexNormals=[];const e=this.morphNormals[t].faceNormals,s=this.morphNormals[t].vertexNormals;for(let t=0,o=this.faces.length;t<o;t++){const t=this.factory.newVector3(),o={a:this.factory.newVector3(),b:this.factory.newVector3(),c:this.factory.newVector3()};e.push(t),s.push(o)}}const s=this.morphNormals[t];e.vertices=this.morphTargets[t].vertices,e.computeFaceNormals(),e.computeVertexNormals();for(let e=0,t=this.faces.length;e<t;e++){const t=this.faces[e],o=s.faceNormals[e],r=s.vertexNormals[e];o.copy(t.normal),r.a.copy(t.vertexNormals[0]),r.b.copy(t.vertexNormals[1]),r.c.copy(t.vertexNormals[2])}}for(let e=0,t=this.faces.length;e<t;e++){const t=this.faces[e];t.normal=t.__originalFaceNormal,t.vertexNormals=t.__originalVertexNormals}}computeBoundingBox(){null===this.boundingBox&&(this.boundingBox=this.factory.newBox3()),this.boundingBox.setFromPoints(this.vertices)}computeBoundingSphere(){null===this.boundingSphere&&(this.boundingSphere=this.factory.newSphere()),this.boundingSphere.setFromPoints(this.vertices)}merge(e,t,s=0){if(!e||!e.isGeometry)return void console.error("THREE.Geometry.merge(): geometry not an instance of THREE.Geometry.",e);let o;const r=this.vertices.length,i=this.vertices,a=e.vertices,c=this.faces,l=e.faces,h=this.colors,u=e.colors;void 0!==t&&(o=this.factory.newMatrix3().getNormalMatrix(t));for(let e=0,s=a.length;e<s;e++){const s=a[e].clone();void 0!==t&&s.applyMatrix4(t),i.push(s)}for(let e=0,t=u.length;e<t;e++)h.push(u[e].clone());for(let e=0,t=l.length;e<t;e++){const t=l[e];let i,a;const h=t.vertexNormals,u=t.vertexColors,f=new n(t.a+r,t.b+r,t.c+r);f.normal.copy(t.normal),void 0!==o&&f.normal.applyMatrix3(o).normalize();for(let e=0,t=h.length;e<t;e++)i=h[e].clone(),void 0!==o&&i.applyMatrix3(o).normalize(),f.vertexNormals.push(i);f.color.copy(t.color);for(let e=0,t=u.length;e<t;e++)a=u[e],f.vertexColors.push(a.clone());f.materialIndex=t.materialIndex+s,c.push(f)}for(let t=0,s=e.faceVertexUvs.length;t<s;t++){const s=e.faceVertexUvs[t];void 0===this.faceVertexUvs[t]&&(this.faceVertexUvs[t]=[]);for(let e=0,o=s.length;e<o;e++){const o=s[e],r=[];for(let e=0,t=o.length;e<t;e++)r.push(o[e].clone());this.faceVertexUvs[t].push(r)}}}mergeMesh(e){e&&e.isMesh?(e.matrixAutoUpdate&&e.updateMatrix(),this.merge(e.geometry,e.matrix)):console.error("THREE.Geometry.mergeMesh(): mesh not an instance of THREE.Mesh.",e)}mergeVertices(e=4){const t={},s=[],o=[],r=Math.pow(10,e);for(let e=0,n=this.vertices.length;e<n;e++){const n=this.vertices[e],i=Math.round(n.x*r)+"_"+Math.round(n.y*r)+"_"+Math.round(n.z*r);void 0===t[i]?(t[i]=e,s.push(this.vertices[e]),o[e]=s.length-1):o[e]=o[t[i]]}const n=[];for(let e=0,t=this.faces.length;e<t;e++){const t=this.faces[e];t.a=o[t.a],t.b=o[t.b],t.c=o[t.c];const s=[t.a,t.b,t.c];for(let t=0;t<3;t++)if(s[t]===s[(t+1)%3]){n.push(e);break}}for(let e=n.length-1;e>=0;e--){const t=n[e];this.faces.splice(t,1);for(let e=0,s=this.faceVertexUvs.length;e<s;e++)this.faceVertexUvs[e].splice(t,1)}const i=this.vertices.length-s.length;return this.vertices=s,i}setFromPoints(e){this.vertices=[];for(let t=0,s=e.length;t<s;t++){const s=e[t];this.vertices.push(this.factory.newVector3(s.x,s.y,s.z||0))}return this}sortFacesByMaterialIndex(){const e=this.faces,t=e.length;for(let s=0;s<t;s++)e[s]._id=s;e.sort((function(e,t){return e.materialIndex-t.materialIndex}));const s=this.faceVertexUvs[0],o=this.faceVertexUvs[1];let r,n;s&&s.length===t&&(r=[]),o&&o.length===t&&(n=[]);for(let i=0;i<t;i++){const t=e[i]._id;r&&r.push(s[t]),n&&n.push(o[t])}r&&(this.faceVertexUvs[0]=r),n&&(this.faceVertexUvs[1]=n)}toJSON(){const e={metadata:{version:4.5,type:"Geometry",generator:"Geometry.toJSON"},uuid:null,type:null,name:null,data:null};if(e.uuid=this.uuid,e.type=this.type,""!==this.name&&(e.name=this.name),void 0!==this.parameters){const t=this.parameters;for(const s in t)void 0!==t[s]&&(e[s]=t[s]);return e}const t=[];for(let e=0;e<this.vertices.length;e++){const s=this.vertices[e];t.push(s.x,s.y,s.z)}const s=[],o=[],r={},n=[],i={},a=[],c={};for(let e=0;e<this.faces.length;e++){const t=this.faces[e],l=!0,h=!1,u=void 0!==this.faceVertexUvs[0][e],f=t.normal.length()>0,m=t.vertexNormals.length>0,p=1!==t.color.r||1!==t.color.g||1!==t.color.b,d=t.vertexColors.length>0;let g=0;const v=(e,t,s)=>s?e|1<<t:e&~(1<<t),y=e=>{const t=e.x.toString()+e.y.toString()+e.z.toString();return void 0!==r[t]||(r[t]=o.length/3,o.push(e.x,e.y,e.z)),r[t]},x=e=>{const t=e.r.toString()+e.g.toString()+e.b.toString();return void 0!==i[t]||(i[t]=n.length,n.push(e.getHex())),i[t]},b=e=>{const t=e.x.toString()+e.y.toString();return void 0!==c[t]||(c[t]=a.length/2,a.push(e.x,e.y)),c[t]};if(g=v(g,0,0),g=v(g,1,l),g=v(g,2,h),g=v(g,3,u),g=v(g,4,f),g=v(g,5,m),g=v(g,6,p),g=v(g,7,d),s.push(g),s.push(t.a,t.b,t.c),s.push(t.materialIndex),u){const t=this.faceVertexUvs[0][e];s.push(b(t[0]),b(t[1]),b(t[2]))}if(f&&s.push(y(t.normal)),m){const e=t.vertexNormals;s.push(y(e[0]),y(e[1]),y(e[2]))}if(p&&s.push(x(t.color)),d){const e=t.vertexColors;s.push(x(e[0]),x(e[1]),x(e[2]))}}return e.data={},e.data.vertices=t,e.data.normals=o,n.length>0&&(e.data.colors=n),a.length>0&&(e.data.uvs=[a]),e.data.faces=s,e}clone(){return new i(this.factory).copy(this)}copy(e){this.vertices=[],this.colors=[],this.faces=[],this.faceVertexUvs=[[]],this.morphTargets=[],this.morphNormals=[],this.skinWeights=[],this.skinIndices=[],this.lineDistances=[],this.boundingBox=null,this.boundingSphere=null,this.name=e.name;const t=e.vertices;for(let e=0,s=t.length;e<s;e++)this.vertices.push(t[e].clone());const s=e.colors;for(let e=0,t=s.length;e<t;e++)this.colors.push(s[e].clone());const o=e.faces;for(let e=0,t=o.length;e<t;e++)this.faces.push(o[e].clone());for(let t=0,s=e.faceVertexUvs.length;t<s;t++){const s=e.faceVertexUvs[t];void 0===this.faceVertexUvs[t]&&(this.faceVertexUvs[t]=[]);for(let e=0,o=s.length;e<o;e++){const o=s[e],r=[];for(let e=0,t=o.length;e<t;e++){const t=o[e];r.push(t.clone())}this.faceVertexUvs[t].push(r)}}const r=e.morphTargets;for(let e=0,t=r.length;e<t;e++){const t={};if(t.name=r[e].name,void 0!==r[e].vertices){t.vertices=[];for(let s=0,o=r[e].vertices.length;s<o;s++)t.vertices.push(r[e].vertices[s].clone())}if(void 0!==r[e].normals){t.normals=[];for(let s=0,o=r[e].normals.length;s<o;s++)t.normals.push(r[e].normals[s].clone())}this.morphTargets.push(t)}const n=e.morphNormals;for(let e=0,t=n.length;e<t;e++){const t={};if(void 0!==n[e].vertexNormals){t.vertexNormals=[];for(let s=0,o=n[e].vertexNormals.length;s<o;s++){const o=n[e].vertexNormals[s],r={a:null,b:null,c:null};r.a=o.a.clone(),r.b=o.b.clone(),r.c=o.c.clone(),t.vertexNormals.push(r)}}if(void 0!==n[e].faceNormals){t.faceNormals=[];for(let s=0,o=n[e].faceNormals.length;s<o;s++)t.faceNormals.push(n[e].faceNormals[s].clone())}this.morphNormals.push(t)}const i=e.skinWeights;for(let e=0,t=i.length;e<t;e++)this.skinWeights.push(i[e].clone());const a=e.skinIndices;for(let e=0,t=a.length;e<t;e++)this.skinIndices.push(a[e].clone());const c=e.lineDistances;for(let e=0,t=c.length;e<t;e++)this.lineDistances.push(c[e]);const l=e.boundingBox;null!==l&&(this.boundingBox=l.clone());const h=e.boundingSphere;return null!==h&&(this.boundingSphere=h.clone()),this.elementsNeedUpdate=e.elementsNeedUpdate,this.verticesNeedUpdate=e.verticesNeedUpdate,this.uvsNeedUpdate=e.uvsNeedUpdate,this.normalsNeedUpdate=e.normalsNeedUpdate,this.colorsNeedUpdate=e.colorsNeedUpdate,this.lineDistancesNeedUpdate=e.lineDistancesNeedUpdate,this.groupsNeedUpdate=e.groupsNeedUpdate,this}toBufferGeometry(){const e=new r(this.factory).fromGeometry(this),t=this.factory.newBufferGeometry(),s=new Float32Array(3*e.vertices.length);if(t.setAttribute("position",this.factory.newBufferAttribute(s,3).copyVector3sArray(e.vertices)),e.normals.length>0){const s=new Float32Array(3*e.normals.length);t.setAttribute("normal",this.factory.newBufferAttribute(s,3).copyVector3sArray(e.normals))}if(e.colors.length>0){const s=new Float32Array(3*e.colors.length);t.setAttribute("color",this.factory.newBufferAttribute(s,3).copyColorsArray(e.colors))}if(e.uvs.length>0){const s=new Float32Array(2*e.uvs.length);t.setAttribute("uv",this.factory.newBufferAttribute(s,2).copyVector2sArray(e.uvs))}if(e.uvs2.length>0){const s=new Float32Array(2*e.uvs2.length);t.setAttribute("uv2",this.factory.newBufferAttribute(s,2).copyVector2sArray(e.uvs2))}t.groups=e.groups;for(const s in e.morphTargets){const o=[],r=e.morphTargets[s];for(let e=0,t=r.length;e<t;e++){const t=r[e],s=this.factory.newFloat32BufferAttribute(3*t.data.length,3);s.name=t.name,o.push(s.copyVector3sArray(t.data))}t.morphAttributes[s]=o}if(e.skinIndices.length>0){const s=this.factory.newFloat32BufferAttribute(4*e.skinIndices.length,4);t.setAttribute("skinIndex",s.copyVector4sArray(e.skinIndices))}if(e.skinWeights.length>0){const s=this.factory.newFloat32BufferAttribute(4*e.skinWeights.length,4);t.setAttribute("skinWeight",s.copyVector4sArray(e.skinWeights))}return null!==e.boundingSphere&&(t.boundingSphere=e.boundingSphere.clone()),null!==e.boundingBox&&(t.boundingBox=e.boundingBox.clone()),t}computeTangents(){console.error("THREE.Geometry: .computeTangents() has been removed.")}computeLineDistances(){console.error("THREE.Geometry: .computeLineDistances() has been removed. Use THREE.Line.computeLineDistances() instead.")}applyMatrix(e){return console.warn("THREE.Geometry: .applyMatrix() has been renamed to .applyMatrix4()."),this.applyMatrix4(e)}dispose(){}static createBufferGeometryFromObject(e,t){const s=t||o;let r=s.newBufferGeometry();const n=e.geometry;if(e.isPoints||e.isLine){const e=s.newFloat32BufferAttribute(3*n.vertices.length,3),t=s.newFloat32BufferAttribute(3*n.colors.length,3);if(r.setAttribute("position",e.copyVector3sArray(n.vertices)),r.setAttribute("color",t.copyColorsArray(n.colors)),n.lineDistances&&n.lineDistances.length===n.vertices.length){const e=s.newFloat32BufferAttribute(n.lineDistances.length,1);r.setAttribute("lineDistance",e.copyArray(n.lineDistances))}null!==n.boundingSphere&&(r.boundingSphere=n.boundingSphere.clone()),null!==n.boundingBox&&(r.boundingBox=n.boundingBox.clone())}else e.isMesh&&(r=n.toBufferGeometry());return r}}const a={DirectGeometry:r,Face3:n,Gmetry:i,DefaultFactory:o}}}]);
//# sourceMappingURL=threejs-slice-geometry-typescript-vendor.min.js.map