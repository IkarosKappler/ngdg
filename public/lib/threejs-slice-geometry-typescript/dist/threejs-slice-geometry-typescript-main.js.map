{"version":3,"file":"threejs-slice-geometry-typescript-main.js","mappings":";;;;;;;;;;AAAa;AACb;AACA;AACA;AACA;AACA;AACA,8CAA6C,EAAE,aAAa,EAAC;AAC7D,uBAAuB;AACvB,yBAAyB,mBAAO,CAAC,yDAAoB;AACrD,kBAAkB,mBAAO,CAAC,2CAAa;AACvC,+BAA+B,mBAAO,CAAC,sFAAwB;AAC/D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,oBAAoB;AAC5C,gCAAgC,oBAAoB;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD,uBAAuB;AACvB;;;;;;;;;;;ACpOa;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,iBAAiB,GAAG,UAAU,GAAG,YAAY,GAAG,aAAa;AAC7D,aAAa;AACb,YAAY;AACZ,UAAU;AACV,iBAAiB;AACjB;;;;;;;;;;ACPA;;AAEA,2BAA2B,sEAAgC;;;;;;;;;;;ACF9C;AACb;AACA;AACA;AACA;AACA;AACA,8CAA6C,EAAE,aAAa,EAAC;AAC7D,sBAAsB;AACtB;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,KAAK;AACL;AACA;AACA,sBAAsB;AACtB;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;;;;;;;;;;;AClFa;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,qBAAqB;AACrB,wBAAwB,mBAAO,CAAC,uDAAmB;AACnD,kBAAkB,mBAAO,CAAC,2CAAa;AACvC,+BAA+B,mBAAO,CAAC,sFAAwB;AAC/D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;UC1EA;UACA;;UAEA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;;UAEA;UACA;;UAEA;UACA;UACA;;UAEA;UACA;;;;;WCzBA;WACA;WACA;WACA;WACA,+BAA+B,wCAAwC;WACvE;WACA;WACA;WACA;WACA,iBAAiB,qBAAqB;WACtC;WACA;WACA,kBAAkB,qBAAqB;WACvC;WACA;WACA,KAAK;WACL;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;;;;;WC3BA;WACA;WACA;WACA;WACA,yCAAyC,wCAAwC;WACjF;WACA;WACA;;;;;WCPA;;;;;WCAA;WACA;WACA;WACA,uDAAuD,iBAAiB;WACxE;WACA,gDAAgD,aAAa;WAC7D;;;;;WCNA;;WAEA;WACA;WACA;WACA;WACA;WACA;;WAEA;;WAEA;;WAEA;;WAEA;;WAEA;;WAEA;;WAEA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA,MAAM,qBAAqB;WAC3B;WACA;WACA;WACA;WACA;WACA;WACA;WACA;;WAEA;WACA;WACA;;;;;UEhDA;UACA;UACA;UACA;UACA","sources":["webpack://threejs-slice-geometry-typescript/./src/cjs/GeometryBuilder.js","webpack://threejs-slice-geometry-typescript/./src/cjs/constants.js","webpack://threejs-slice-geometry-typescript/./src/cjs/entry.js","webpack://threejs-slice-geometry-typescript/./src/cjs/faces-from-edges.js","webpack://threejs-slice-geometry-typescript/./src/cjs/slice.js","webpack://threejs-slice-geometry-typescript/webpack/bootstrap","webpack://threejs-slice-geometry-typescript/webpack/runtime/chunk loaded","webpack://threejs-slice-geometry-typescript/webpack/runtime/define property getters","webpack://threejs-slice-geometry-typescript/webpack/runtime/hasOwnProperty shorthand","webpack://threejs-slice-geometry-typescript/webpack/runtime/make namespace object","webpack://threejs-slice-geometry-typescript/webpack/runtime/jsonp chunk loading","webpack://threejs-slice-geometry-typescript/webpack/before-startup","webpack://threejs-slice-geometry-typescript/webpack/startup","webpack://threejs-slice-geometry-typescript/webpack/after-startup"],"sourcesContent":["\"use strict\";\n/**\n * Ported to TypeScript from vanilla-js by Ikaros Kappler.\n *\n * @date 2021-09-28\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.GeometryBuilder = void 0;\nvar faces_from_edges_1 = require(\"./faces-from-edges\");\nvar constants_1 = require(\"./constants\");\nvar three_geometry_hellfix_1 = require(\"three-geometry-hellfix\");\nvar GeometryBuilder = /** @class */ (function () {\n    function GeometryBuilder(sourceGeometry, targetGeometry, slicePlane) {\n        this.sourceGeometry = sourceGeometry;\n        this.targetGeometry = targetGeometry;\n        this.slicePlane = slicePlane;\n        this.addedVertices = [];\n        this.addedIntersections = [];\n        this.newEdges = [[]];\n    }\n    ;\n    // TODO: check undfined?\n    // This is called without params in line ---67 but param used here as an index??\n    GeometryBuilder.prototype.startFace = function (sourceFaceIndex) {\n        this.sourceFaceIndex = sourceFaceIndex;\n        this.sourceFace = this.sourceGeometry.faces[sourceFaceIndex];\n        this.sourceFaceUvs = this.sourceGeometry.faceVertexUvs[0][sourceFaceIndex];\n        this.faceIndices = [];\n        this.faceNormals = [];\n        this.faceUvs = [];\n    };\n    ;\n    GeometryBuilder.prototype.endFace = function () {\n        var indices = this.faceIndices.map(function (index, i) {\n            return i;\n        });\n        this.addFace(indices);\n    };\n    ;\n    GeometryBuilder.prototype.closeHoles = function () {\n        var _this = this;\n        if (!this.newEdges[0].length) {\n            return;\n        }\n        (0, faces_from_edges_1.facesFromEdges)(this.newEdges)\n            .forEach(function (faceIndices) {\n            var normal = _this.faceNormal(faceIndices);\n            if (normal.dot(_this.slicePlane.normal) > .5) {\n                faceIndices.reverse();\n            }\n            _this.startFace();\n            _this.faceIndices = faceIndices;\n            _this.endFace();\n        }, this);\n    };\n    ;\n    GeometryBuilder.prototype.addVertex = function (key) {\n        this.addUv(key);\n        this.addNormal(key);\n        var index = this.sourceFace[key];\n        var newIndex;\n        if (this.addedVertices.hasOwnProperty(index)) {\n            newIndex = this.addedVertices[index];\n        }\n        else {\n            var vertex = this.sourceGeometry.vertices[index];\n            this.targetGeometry.vertices.push(vertex);\n            newIndex = this.targetGeometry.vertices.length - 1;\n            this.addedVertices[index] = newIndex;\n        }\n        this.faceIndices.push(newIndex);\n    };\n    ;\n    GeometryBuilder.prototype.addIntersection = function (keyA, keyB, distanceA, distanceB) {\n        var t = Math.abs(distanceA) / (Math.abs(distanceA) + Math.abs(distanceB));\n        this.addIntersectionUv(keyA, keyB, t);\n        this.addIntersectionNormal(keyA, keyB, t);\n        var indexA = this.sourceFace[keyA];\n        var indexB = this.sourceFace[keyB];\n        var id = this.intersectionId(indexA, indexB);\n        var index;\n        if (this.addedIntersections.hasOwnProperty(id)) {\n            index = this.addedIntersections[id];\n        }\n        else {\n            var vertexA = this.sourceGeometry.vertices[indexA];\n            var vertexB = this.sourceGeometry.vertices[indexB];\n            var newVertex = vertexA.clone().lerp(vertexB, t);\n            this.targetGeometry.vertices.push(newVertex);\n            index = this.targetGeometry.vertices.length - 1;\n            this.addedIntersections[id] = index;\n        }\n        this.faceIndices.push(index);\n        this.updateNewEdges(index);\n    };\n    ;\n    GeometryBuilder.prototype.addUv = function (key) {\n        if (!this.sourceFaceUvs) {\n            return;\n        }\n        var index = this.keyIndex(key);\n        var uv = this.sourceFaceUvs[index];\n        this.faceUvs.push(uv);\n    };\n    ;\n    GeometryBuilder.prototype.addIntersectionUv = function (keyA, keyB, t) {\n        if (!this.sourceFaceUvs) {\n            return;\n        }\n        var indexA = this.keyIndex(keyA);\n        var indexB = this.keyIndex(keyB);\n        var uvA = this.sourceFaceUvs[indexA];\n        var uvB = this.sourceFaceUvs[indexB];\n        var uv = uvA.clone().lerp(uvB, t);\n        this.faceUvs.push(uv);\n    };\n    ;\n    GeometryBuilder.prototype.addNormal = function (key) {\n        if (!this.sourceFace.vertexNormals.length) {\n            return;\n        }\n        var index = this.keyIndex(key);\n        var normal = this.sourceFace.vertexNormals[index];\n        this.faceNormals.push(normal);\n    };\n    ;\n    GeometryBuilder.prototype.addIntersectionNormal = function (keyA, keyB, t) {\n        if (!this.sourceFace.vertexNormals.length) {\n            return;\n        }\n        var indexA = this.keyIndex(keyA);\n        var indexB = this.keyIndex(keyB);\n        var normalA = this.sourceFace.vertexNormals[indexA];\n        var normalB = this.sourceFace.vertexNormals[indexB];\n        var normal = normalA.clone().lerp(normalB, t).normalize();\n        this.faceNormals.push(normal);\n    };\n    ;\n    GeometryBuilder.prototype.addFace = function (indices) {\n        var _this = this;\n        if (indices.length === 3) {\n            this.addFacePart(indices[0], indices[1], indices[2]);\n            return;\n        }\n        var pairs = [];\n        for (var i = 0; i < indices.length; i++) {\n            for (var j = i + 1; j < indices.length; j++) {\n                var diff = Math.abs(i - j);\n                if (diff > 1 && diff < indices.length - 1) {\n                    pairs.push([indices[i], indices[j]]);\n                }\n            }\n        }\n        pairs.sort((function (pairA, pairB) {\n            var lengthA = _this.faceEdgeLength(pairA[0], pairA[1]);\n            var lengthB = _this.faceEdgeLength(pairB[0], pairB[1]);\n            return lengthA - lengthB;\n        }).bind(this));\n        var a = indices.indexOf(pairs[0][0]);\n        indices = indices.slice(a).concat(indices.slice(0, a));\n        var b = indices.indexOf(pairs[0][1]);\n        var indicesA = indices.slice(0, b + 1);\n        var indicesB = indices.slice(b).concat(indices.slice(0, 1));\n        this.addFace(indicesA);\n        this.addFace(indicesB);\n    };\n    ;\n    GeometryBuilder.prototype.addFacePart = function (a, b, c) {\n        var normals = null;\n        if (this.faceNormals.length) {\n            normals = [\n                this.faceNormals[a],\n                this.faceNormals[b],\n                this.faceNormals[c],\n            ];\n        }\n        var face = new three_geometry_hellfix_1.Face3(this.faceIndices[a], this.faceIndices[b], this.faceIndices[c], normals);\n        this.targetGeometry.faces.push(face);\n        if (!this.sourceFaceUvs) {\n            return;\n        }\n        this.targetGeometry.faceVertexUvs[0].push([\n            this.faceUvs[a],\n            this.faceUvs[b],\n            this.faceUvs[c]\n        ]);\n    };\n    ;\n    GeometryBuilder.prototype.faceEdgeLength = function (a, b) {\n        var indexA = this.faceIndices[a];\n        var indexB = this.faceIndices[b];\n        var vertexA = this.targetGeometry.vertices[indexA];\n        var vertexB = this.targetGeometry.vertices[indexB];\n        return vertexA.distanceToSquared(vertexB);\n    };\n    ;\n    GeometryBuilder.prototype.intersectionId = function (indexA, indexB) {\n        return [indexA, indexB].sort().join(',');\n    };\n    ;\n    GeometryBuilder.prototype.keyIndex = function (key) {\n        return constants_1.FACE_KEYS.indexOf(key);\n    };\n    ;\n    GeometryBuilder.prototype.updateNewEdges = function (index) {\n        var edgeIndex = this.newEdges.length - 1;\n        var edge = this.newEdges[edgeIndex];\n        if (edge.length < 2) {\n            edge.push(index);\n        }\n        else {\n            this.newEdges.push([index]);\n        }\n    };\n    ;\n    GeometryBuilder.prototype.faceNormal = function (faceIndices) {\n        var _this = this;\n        var vertices = faceIndices.map((function (index) {\n            return _this.targetGeometry.vertices[index];\n        }).bind(this));\n        var edgeA = vertices[0].clone().sub(vertices[1]);\n        var edgeB = vertices[0].clone().sub(vertices[2]);\n        return edgeA.cross(edgeB).normalize();\n    };\n    ;\n    return GeometryBuilder;\n}());\nexports.GeometryBuilder = GeometryBuilder;\n//# sourceMappingURL=GeometryBuilder.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.FACE_KEYS = exports.ON = exports.BACK = exports.FRONT = void 0;\nexports.FRONT = 'front';\nexports.BACK = 'back';\nexports.ON = 'on';\nexports.FACE_KEYS = ['a', 'b', 'c'];\n//# sourceMappingURL=constants.js.map","/** Expose the main function */\n\nglobalThis.sliceGeometry = require(\"./slice\").sliceGeometry;","\"use strict\";\n/**\n * Ported to TypeScript from vanilla-js by Ikaros Kappler.\n *\n * @date 2021-09-28\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.facesFromEdges = void 0;\nvar facesFromEdges = function (edges) {\n    var chains = joinEdges(edges).filter(validFace);\n    var faces = chains.map(function (chain) {\n        return chain.map(function (edge) {\n            return edge[0];\n        });\n    });\n    return faces;\n};\nexports.facesFromEdges = facesFromEdges;\nvar joinEdges = function (edges) {\n    var changes = true;\n    var chains = edges.map(function (edge) {\n        return [edge];\n    });\n    while (changes) {\n        changes = connectChains(chains);\n    }\n    chains = chains.filter(function (chain) {\n        return chain.length;\n    });\n    return chains;\n};\nvar connectChains = function (chains) {\n    chains.forEach(function (chainA, i) {\n        chains.forEach(function (chainB, j) {\n            var merged = mergeChains(chainA, chainB);\n            if (merged) {\n                delete chains[j];\n                return true;\n            }\n        });\n    });\n    return false;\n};\nvar mergeChains = function (chainA, chainB) {\n    if (chainA === chainB) {\n        return false;\n    }\n    if (chainStart(chainA) === chainEnd(chainB)) {\n        chainA.unshift.apply(chainA, chainB);\n        return true;\n    }\n    if (chainStart(chainA) === chainStart(chainB)) {\n        reverseChain(chainB);\n        chainA.unshift.apply(chainA, chainB);\n        return true;\n    }\n    if (chainEnd(chainA) === chainStart(chainB)) {\n        chainA.push.apply(chainA, chainB);\n        return true;\n    }\n    if (chainEnd(chainA) === chainEnd(chainB)) {\n        reverseChain(chainB);\n        chainA.push.apply(chainA, chainB);\n        return true;\n    }\n    return false;\n};\nvar chainStart = function (chain) {\n    return chain[0][0];\n};\nvar chainEnd = function (chain) {\n    return chain[chain.length - 1][1];\n};\nvar reverseChain = function (chain) {\n    chain.reverse();\n    chain.forEach(function (edge) {\n        edge.reverse();\n    });\n};\nvar validFace = function (chain) {\n    return chainStart(chain) === chainEnd(chain) ? 1 : 0;\n};\n//# sourceMappingURL=faces-from-edges.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.sliceGeometry = void 0;\nvar GeometryBuilder_1 = require(\"./GeometryBuilder\");\nvar constants_1 = require(\"./constants\");\nvar three_geometry_hellfix_1 = require(\"three-geometry-hellfix\");\nvar sliceGeometry = function (geometry, plane, closeHoles) {\n    var sliced = new three_geometry_hellfix_1.Gmetry();\n    var builder = new GeometryBuilder_1.GeometryBuilder(geometry, sliced, plane);\n    var distances = [];\n    var positions = [];\n    geometry.vertices.forEach(function (vertex) {\n        var distance = findDistance(vertex, plane);\n        var position = distanceAsPosition(distance);\n        distances.push(distance);\n        positions.push(position);\n    });\n    geometry.faces.forEach(function (face, faceIndex) {\n        var facePositions = constants_1.FACE_KEYS.map(function (key) {\n            return positions[face[key]];\n        });\n        if (facePositions.indexOf(constants_1.FRONT) === -1 &&\n            facePositions.indexOf(constants_1.BACK) !== -1) {\n            return;\n        }\n        builder.startFace(faceIndex);\n        var lastKey = constants_1.FACE_KEYS[constants_1.FACE_KEYS.length - 1];\n        var lastIndex = face[lastKey];\n        var lastDistance = distances[lastIndex];\n        var lastPosition = positions[lastIndex];\n        constants_1.FACE_KEYS.map(function (key) {\n            var index = face[key];\n            var distance = distances[index];\n            var position = positions[index];\n            if (position === constants_1.FRONT) {\n                if (lastPosition === constants_1.BACK) {\n                    builder.addIntersection(lastKey, key, lastDistance, distance);\n                    builder.addVertex(key);\n                }\n                else {\n                    builder.addVertex(key);\n                }\n            }\n            if (position === constants_1.ON) {\n                builder.addVertex(key);\n            }\n            if (position === constants_1.BACK && lastPosition === constants_1.FRONT) {\n                builder.addIntersection(lastKey, key, lastDistance, distance);\n            }\n            lastKey = key;\n            lastIndex = index;\n            lastPosition = position;\n            lastDistance = distance;\n        });\n        builder.endFace();\n    });\n    if (closeHoles) {\n        builder.closeHoles();\n    }\n    return sliced;\n};\nexports.sliceGeometry = sliceGeometry;\nvar distanceAsPosition = function (distance) {\n    if (distance < 0) {\n        return constants_1.BACK;\n    }\n    if (distance > 0) {\n        return constants_1.FRONT;\n    }\n    return constants_1.ON;\n};\nvar findDistance = function (vertex, plane) {\n    return plane.distanceToPoint(vertex);\n};\n//# sourceMappingURL=slice.js.map","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n// expose the modules object (__webpack_modules__)\n__webpack_require__.m = __webpack_modules__;\n\n","var deferred = [];\n__webpack_require__.O = (result, chunkIds, fn, priority) => {\n\tif(chunkIds) {\n\t\tpriority = priority || 0;\n\t\tfor(var i = deferred.length; i > 0 && deferred[i - 1][2] > priority; i--) deferred[i] = deferred[i - 1];\n\t\tdeferred[i] = [chunkIds, fn, priority];\n\t\treturn;\n\t}\n\tvar notFulfilled = Infinity;\n\tfor (var i = 0; i < deferred.length; i++) {\n\t\tvar [chunkIds, fn, priority] = deferred[i];\n\t\tvar fulfilled = true;\n\t\tfor (var j = 0; j < chunkIds.length; j++) {\n\t\t\tif ((priority & 1 === 0 || notFulfilled >= priority) && Object.keys(__webpack_require__.O).every((key) => (__webpack_require__.O[key](chunkIds[j])))) {\n\t\t\t\tchunkIds.splice(j--, 1);\n\t\t\t} else {\n\t\t\t\tfulfilled = false;\n\t\t\t\tif(priority < notFulfilled) notFulfilled = priority;\n\t\t\t}\n\t\t}\n\t\tif(fulfilled) {\n\t\t\tdeferred.splice(i--, 1)\n\t\t\tvar r = fn();\n\t\t\tif (r !== undefined) result = r;\n\t\t}\n\t}\n\treturn result;\n};","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","// no baseURI\n\n// object to store loaded and loading chunks\n// undefined = chunk not loaded, null = chunk preloaded/prefetched\n// [resolve, reject, Promise] = chunk loading, 0 = chunk loaded\nvar installedChunks = {\n\t\"main\": 0\n};\n\n// no chunk on demand loading\n\n// no prefetching\n\n// no preloaded\n\n// no HMR\n\n// no HMR manifest\n\n__webpack_require__.O.j = (chunkId) => (installedChunks[chunkId] === 0);\n\n// install a JSONP callback for chunk loading\nvar webpackJsonpCallback = (parentChunkLoadingFunction, data) => {\n\tvar [chunkIds, moreModules, runtime] = data;\n\t// add \"moreModules\" to the modules object,\n\t// then flag all \"chunkIds\" as loaded and fire callback\n\tvar moduleId, chunkId, i = 0;\n\tif(chunkIds.some((id) => (installedChunks[id] !== 0))) {\n\t\tfor(moduleId in moreModules) {\n\t\t\tif(__webpack_require__.o(moreModules, moduleId)) {\n\t\t\t\t__webpack_require__.m[moduleId] = moreModules[moduleId];\n\t\t\t}\n\t\t}\n\t\tif(runtime) var result = runtime(__webpack_require__);\n\t}\n\tif(parentChunkLoadingFunction) parentChunkLoadingFunction(data);\n\tfor(;i < chunkIds.length; i++) {\n\t\tchunkId = chunkIds[i];\n\t\tif(__webpack_require__.o(installedChunks, chunkId) && installedChunks[chunkId]) {\n\t\t\tinstalledChunks[chunkId][0]();\n\t\t}\n\t\tinstalledChunks[chunkIds[i]] = 0;\n\t}\n\treturn __webpack_require__.O(result);\n}\n\nvar chunkLoadingGlobal = self[\"webpackChunkthreejs_slice_geometry_typescript\"] = self[\"webpackChunkthreejs_slice_geometry_typescript\"] || [];\nchunkLoadingGlobal.forEach(webpackJsonpCallback.bind(null, 0));\nchunkLoadingGlobal.push = webpackJsonpCallback.bind(null, chunkLoadingGlobal.push.bind(chunkLoadingGlobal));","","// startup\n// Load entry module and return exports\n// This entry module depends on other loaded chunks and execution need to be delayed\nvar __webpack_exports__ = __webpack_require__.O(undefined, [\"vendor\"], () => (__webpack_require__(\"./src/cjs/entry.js\")))\n__webpack_exports__ = __webpack_require__.O(__webpack_exports__);\n",""],"names":[],"sourceRoot":""}