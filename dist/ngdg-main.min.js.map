{"version":3,"file":"ngdg-main.min.js","mappings":"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","sources":["webpack://ngdg/webpack/runtime/chunk loaded","webpack://ngdg/../earcut-typescript/src/cjs/earcut.js","webpack://ngdg/./src/cjs/BumpMapper.js","webpack://ngdg/./src/cjs/DildoGeneration.js","webpack://ngdg/./src/cjs/DildoGeometry.js","webpack://ngdg/./src/cjs/DildoMaterials.js","webpack://ngdg/./src/cjs/GeometryGenerationHelpers.js","webpack://ngdg/./src/cjs/ImageStore.js","webpack://ngdg/./src/cjs/PathFinder.js","webpack://ngdg/./src/cjs/PlaneMeshIntersection.js","webpack://ngdg/./src/cjs/UVHelpers.js","webpack://ngdg/./src/cjs/clearDuplicateVertices3.js","webpack://ngdg/./src/cjs/computeVertexNormals.js","webpack://ngdg/./src/cjs/constants.js","webpack://ngdg/./src/cjs/defaults.js","webpack://ngdg/./src/cjs/entry.js","webpack://ngdg/./src/cjs/locateVertexInArray.js","webpack://ngdg/./src/cjs/mergeGeometries.js","webpack://ngdg/./src/cjs/ngdg.js","webpack://ngdg/./src/cjs/randomWebColor.js","webpack://ngdg/./src/cjs/thirdparty-ported/threejs-slice-geometry/faces-from-edges.js","webpack://ngdg/./src/cjs/thirdparty-ported/threejs-slice-geometry/index.js","webpack://ngdg/./src/cjs/thirdparty-ported/threejs-slice-geometry/slice.js","webpack://ngdg/webpack/bootstrap","webpack://ngdg/webpack/runtime/define property getters","webpack://ngdg/webpack/runtime/hasOwnProperty shorthand","webpack://ngdg/webpack/runtime/make namespace object","webpack://ngdg/webpack/runtime/jsonp chunk loading","webpack://ngdg/webpack/startup"],"sourcesContent":["var deferred = [];\n__webpack_require__.O = (result, chunkIds, fn, priority) => {\n\tif(chunkIds) {\n\t\tpriority = priority || 0;\n\t\tfor(var i = deferred.length; i > 0 && deferred[i - 1][2] > priority; i--) deferred[i] = deferred[i - 1];\n\t\tdeferred[i] = [chunkIds, fn, priority];\n\t\treturn;\n\t}\n\tvar notFulfilled = Infinity;\n\tfor (var i = 0; i < deferred.length; i++) {\n\t\tvar [chunkIds, fn, priority] = deferred[i];\n\t\tvar fulfilled = true;\n\t\tfor (var j = 0; j < chunkIds.length; j++) {\n\t\t\tif ((priority & 1 === 0 || notFulfilled >= priority) && Object.keys(__webpack_require__.O).every((key) => (__webpack_require__.O[key](chunkIds[j])))) {\n\t\t\t\tchunkIds.splice(j--, 1);\n\t\t\t} else {\n\t\t\t\tfulfilled = false;\n\t\t\t\tif(priority < notFulfilled) notFulfilled = priority;\n\t\t\t}\n\t\t}\n\t\tif(fulfilled) {\n\t\t\tdeferred.splice(i--, 1)\n\t\t\tvar r = fn();\n\t\t\tif (r !== undefined) result = r;\n\t\t}\n\t}\n\treturn result;\n};","\"use strict\";\n// Original algorithm by https://github.com/mapbox/earcut\n//\n// Ported to TypeScript by Ikaros Kappler\n// @date 2020-12-08\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.earcut = void 0;\n;\nexports.earcut = (function () {\n    /**\n     * Nodes of a linked list, each node representing a vertex of a ring (a polygon).\n     */\n    var Node = /** @class */ (function () {\n        function Node(i, x, y) {\n            // vertex index in coordinates array\n            this.i = i;\n            // vertex coordinates\n            this.x = x;\n            this.y = y;\n            // previous and next vertex nodes in a polygon ring\n            this.prev = null;\n            this.next = null;\n            // z-order curve value\n            this.z = null;\n            // previous and next nodes in z-order\n            this.prevZ = null;\n            this.nextZ = null;\n            // indicates whether this is a steiner point\n            this.steiner = false;\n        }\n        return Node;\n    }());\n    ;\n    var earcut = function (data, holeIndices, dim) {\n        if (dim === void 0) { dim = 2; }\n        dim = dim || 2;\n        var hasHoles = holeIndices && holeIndices.length > 0;\n        var outerLen = hasHoles ? holeIndices[0] * dim : data.length;\n        var outerNode = linkedList(data, 0, outerLen, dim, true);\n        var triangles = []; // [t0a, t0b, t0c,  t1a, t2a, t3a, ... ]\n        if (!outerNode || outerNode.next === outerNode.prev)\n            return triangles;\n        var minX;\n        var minY;\n        var maxX;\n        var maxY;\n        var x;\n        var y;\n        var invSize;\n        if (hasHoles) {\n            outerNode = eliminateHoles(data, holeIndices, outerNode, dim);\n        }\n        // if the shape is not too simple, we'll use z-order curve hash later; calculate polygon bbox\n        // TODO: use Bounds class for calculation?\n        if (data.length > 80 * dim) {\n            minX = maxX = data[0];\n            minY = maxY = data[1];\n            for (var i = dim; i < outerLen; i += dim) {\n                x = data[i];\n                y = data[i + 1];\n                if (x < minX)\n                    minX = x;\n                if (y < minY)\n                    minY = y;\n                if (x > maxX)\n                    maxX = x;\n                if (y > maxY)\n                    maxY = y;\n            }\n            // minX, minY and invSize are later used to transform coords into integers for z-order calculation\n            invSize = Math.max(maxX - minX, maxY - minY);\n            invSize = invSize !== 0 ? 1 / invSize : 0;\n        }\n        earcutLinked(outerNode, triangles, dim, minX, minY, invSize);\n        return triangles;\n    };\n    // create a circular doubly linked list from polygon points in the specified winding order\n    var linkedList = function (data, start, end, dim, clockwise) {\n        var i;\n        var last;\n        if (clockwise === (signedArea(data, start, end, dim) > 0)) {\n            for (i = start; i < end; i += dim) {\n                last = insertNode(i, data[i], data[i + 1], last);\n            }\n        }\n        else {\n            for (i = end - dim; i >= start; i -= dim) {\n                last = insertNode(i, data[i], data[i + 1], last);\n            }\n        }\n        if (last && equals(last, last.next)) {\n            removeNode(last);\n            last = last.next;\n        }\n        return last;\n    };\n    // eliminate colinear or duplicate points\n    var filterPoints = function (start, end) {\n        if (!start)\n            return start;\n        if (!end)\n            end = start;\n        // Remember starting node\n        var p = start;\n        var again = false;\n        do {\n            // TODO: move into 'else' branch?\n            again = false;\n            if (!p.steiner && (equals(p, p.next) || area(p.prev, p, p.next) === 0)) {\n                removeNode(p);\n                p = end = p.prev;\n                if (p === p.next)\n                    break;\n                again = true;\n            }\n            else {\n                p = p.next;\n            }\n        } while (again || p !== end);\n        return end;\n    };\n    // main ear slicing loop which triangulates a polygon (given as a linked list)\n    var earcutLinked = function (ear, triangles, dim, minX, minY, invSize, pass) {\n        if (!ear)\n            return;\n        // interlink polygon nodes in z-order\n        if (!pass && invSize) {\n            indexCurve(ear, minX, minY, invSize);\n        }\n        var stop = ear;\n        var prev;\n        var next;\n        // iterate through ears, slicing them one by one\n        while (ear.prev !== ear.next) {\n            prev = ear.prev;\n            next = ear.next;\n            if (invSize ? isEarHashed(ear, minX, minY, invSize) : isEar(ear)) {\n                // cut off the triangle\n                triangles.push(prev.i / dim);\n                triangles.push(ear.i / dim);\n                triangles.push(next.i / dim);\n                removeNode(ear);\n                // skipping the next vertex leads to less sliver triangles\n                ear = next.next;\n                stop = next.next;\n                continue;\n            }\n            ear = next;\n            // if we looped through the whole remaining polygon and can't find any more ears\n            if (ear === stop) {\n                // try filtering points and slicing again\n                if (!pass) {\n                    earcutLinked(filterPoints(ear), triangles, dim, minX, minY, invSize, 1);\n                    // if this didn't work, try curing all small self-intersections locally\n                }\n                else if (pass === 1) {\n                    ear = cureLocalIntersections(filterPoints(ear), triangles, dim);\n                    earcutLinked(ear, triangles, dim, minX, minY, invSize, 2);\n                    // as a last resort, try splitting the remaining polygon into two\n                }\n                else if (pass === 2) {\n                    splitEarcut(ear, triangles, dim, minX, minY, invSize);\n                }\n                break;\n            }\n        }\n    }; // END earcutLinked\n    // check whether a polygon node forms a valid ear with adjacent nodes\n    var isEar = function (ear) {\n        var a = ear.prev;\n        var b = ear;\n        var c = ear.next;\n        if (area(a, b, c) >= 0)\n            return false; // reflex, can't be an ear\n        // now make sure we don't have other points inside the potential ear\n        var p = ear.next.next;\n        while (p !== ear.prev) {\n            if (pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, p.x, p.y) &&\n                area(p.prev, p, p.next) >= 0)\n                return false;\n            p = p.next;\n        }\n        return true;\n    };\n    var isEarHashed = function (ear, minX, minY, invSize) {\n        var a = ear.prev;\n        var b = ear;\n        var c = ear.next;\n        if (area(a, b, c) >= 0)\n            return false; // reflex, can't be an ear\n        // triangle bbox; min & max are calculated like this for speed\n        // TODO: use Triangle.bounds\n        var minTX = a.x < b.x ? (a.x < c.x ? a.x : c.x) : (b.x < c.x ? b.x : c.x), minTY = a.y < b.y ? (a.y < c.y ? a.y : c.y) : (b.y < c.y ? b.y : c.y), maxTX = a.x > b.x ? (a.x > c.x ? a.x : c.x) : (b.x > c.x ? b.x : c.x), maxTY = a.y > b.y ? (a.y > c.y ? a.y : c.y) : (b.y > c.y ? b.y : c.y);\n        // z-order range for the current triangle bbox;\n        var minZ = zOrder(minTX, minTY, minX, minY, invSize), maxZ = zOrder(maxTX, maxTY, minX, minY, invSize);\n        var p = ear.prevZ, n = ear.nextZ;\n        // look for points inside the triangle in both directions\n        while (p && p.z >= minZ && n && n.z <= maxZ) {\n            if (p !== ear.prev && p !== ear.next &&\n                // TODO: use Triangle.utils.pointIsInTriangle\n                pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, p.x, p.y) &&\n                area(p.prev, p, p.next) >= 0)\n                return false;\n            p = p.prevZ;\n            if (n !== ear.prev && n !== ear.next &&\n                // TODO: use Triangle.utils.pointIsInTriangle\n                pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, n.x, n.y) &&\n                area(n.prev, n, n.next) >= 0)\n                return false;\n            n = n.nextZ;\n        }\n        // look for remaining points in decreasing z-order\n        while (p && p.z >= minZ) {\n            if (p !== ear.prev && p !== ear.next &&\n                // TODO: use Triangle.utils.pointIsInTriangle\n                pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, p.x, p.y) &&\n                area(p.prev, p, p.next) >= 0)\n                return false;\n            p = p.prevZ;\n        }\n        // look for remaining points in increasing z-order\n        while (n && n.z <= maxZ) {\n            if (n !== ear.prev && n !== ear.next &&\n                // TODO: use Triangle.utils.pointIsInTriangle\n                pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, n.x, n.y) &&\n                area(n.prev, n, n.next) >= 0)\n                return false;\n            n = n.nextZ;\n        }\n        return true;\n    };\n    // go through all polygon nodes and cure small local self-intersections\n    var cureLocalIntersections = function (start, triangles, dim) {\n        var p = start;\n        do {\n            var a = p.prev;\n            var b = p.next.next;\n            if (!equals(a, b) && intersects(a, p, p.next, b) && locallyInside(a, b) && locallyInside(b, a)) {\n                triangles.push(a.i / dim);\n                triangles.push(p.i / dim);\n                triangles.push(b.i / dim);\n                // remove two nodes involved\n                removeNode(p);\n                removeNode(p.next);\n                p = start = b;\n            }\n            p = p.next;\n        } while (p !== start);\n        return filterPoints(p);\n    };\n    // try splitting polygon into two and triangulate them independently\n    var splitEarcut = function (start, triangles, dim, minX, minY, invSize) {\n        // look for a valid diagonal that divides the polygon into two\n        var a = start;\n        do {\n            var b = a.next.next;\n            while (b !== a.prev) {\n                if (a.i !== b.i && isValidDiagonal(a, b)) {\n                    // split the polygon in two by the diagonal\n                    var c = splitPolygon(a, b);\n                    // filter colinear points around the cuts\n                    a = filterPoints(a, a.next);\n                    c = filterPoints(c, c.next);\n                    // run earcut on each half\n                    earcutLinked(a, triangles, dim, minX, minY, invSize);\n                    earcutLinked(c, triangles, dim, minX, minY, invSize);\n                    return;\n                }\n                b = b.next;\n            }\n            a = a.next;\n        } while (a !== start);\n    };\n    // link every hole into the outer loop, producing a single-ring polygon without holes\n    var eliminateHoles = function (data, holeIndices, outerNode, dim) {\n        var queue = [];\n        var i;\n        var len = holeIndices.length;\n        var start;\n        var end;\n        var list;\n        for (i = 0; i < len; i++) {\n            start = holeIndices[i] * dim;\n            end = i < len - 1 ? holeIndices[i + 1] * dim : data.length;\n            list = linkedList(data, start, end, dim, false);\n            if (list === list.next)\n                list.steiner = true;\n            queue.push(getLeftmost(list));\n        }\n        queue.sort(compareX);\n        // process holes from left to right\n        for (i = 0; i < queue.length; i++) {\n            eliminateHole(queue[i], outerNode);\n            outerNode = filterPoints(outerNode, outerNode.next);\n        }\n        return outerNode;\n    };\n    var compareX = function (a, b) {\n        return a.x - b.x;\n    };\n    // find a bridge between vertices that connects hole with an outer ring and and link it\n    var eliminateHole = function (hole, outerNode) {\n        var bridge = findHoleBridge(hole, outerNode);\n        if (!bridge) {\n            return outerNode;\n        }\n        var bridgeReverse = splitPolygon(bridge, hole);\n        // filter collinear points around the cuts\n        var filteredBridge = filterPoints(bridge, bridge.next);\n        filterPoints(bridgeReverse, bridgeReverse.next);\n        // Check if input node was removed by the filtering\n        return outerNode === bridge ? filteredBridge : outerNode;\n        // }\n    };\n    // David Eberly's algorithm for finding a bridge between hole and outer polygon\n    var findHoleBridge = function (hole, outerNode) {\n        var p = outerNode;\n        var hx = hole.x;\n        var hy = hole.y;\n        var qx = -Infinity;\n        var m;\n        // find a segment intersected by a ray from the hole's leftmost point to the left;\n        // segment's endpoint with lesser x will be potential connection point\n        do {\n            if (hy <= p.y && hy >= p.next.y && p.next.y !== p.y) {\n                var x = p.x + (hy - p.y) * (p.next.x - p.x) / (p.next.y - p.y);\n                if (x <= hx && x > qx) {\n                    qx = x;\n                    if (x === hx) {\n                        if (hy === p.y)\n                            return p;\n                        if (hy === p.next.y)\n                            return p.next;\n                    }\n                    m = p.x < p.next.x ? p : p.next;\n                }\n            }\n            p = p.next;\n        } while (p !== outerNode);\n        if (!m) {\n            return null;\n        }\n        if (hx === qx) {\n            return m; // hole touches outer segment; pick leftmost endpoint\n        }\n        // look for points inside the triangle of hole point, segment intersection and endpoint;\n        // if there are no points found, we have a valid connection;\n        // otherwise choose the point of the minimum angle with the ray as connection point\n        var stop = m;\n        var mx = m.x;\n        var my = m.y;\n        var tanMin = Infinity;\n        var tan;\n        p = m;\n        do {\n            if (hx >= p.x && p.x >= mx && hx !== p.x &&\n                pointInTriangle(hy < my ? hx : qx, hy, mx, my, hy < my ? qx : hx, hy, p.x, p.y)) {\n                tan = Math.abs(hy - p.y) / (hx - p.x); // tangential\n                if (locallyInside(p, hole) &&\n                    (tan < tanMin || (tan === tanMin && (p.x > m.x || (p.x === m.x && sectorContainsSector(m, p)))))) {\n                    m = p;\n                    tanMin = tan;\n                }\n            }\n            p = p.next;\n        } while (p !== stop);\n        return m;\n    };\n    // whether sector in vertex m contains sector in vertex p in the same coordinates\n    var sectorContainsSector = function (m, p) {\n        return area(m.prev, m, p.prev) < 0 && area(p.next, m, m.next) < 0;\n    };\n    // interlink polygon nodes in z-order\n    var indexCurve = function (start, minX, minY, invSize) {\n        var p = start;\n        do {\n            if (p.z === null)\n                p.z = zOrder(p.x, p.y, minX, minY, invSize);\n            p.prevZ = p.prev;\n            p.nextZ = p.next;\n            p = p.next;\n        } while (p !== start);\n        p.prevZ.nextZ = null;\n        p.prevZ = null;\n        sortLinked(p);\n    };\n    // Simon Tatham's linked list merge sort algorithm\n    // http://www.chiark.greenend.org.uk/~sgtatham/algorithms/listsort.html\n    var sortLinked = function (list) {\n        var i;\n        var p;\n        var q;\n        var e;\n        var tail;\n        var numMerges;\n        var pSize;\n        var qSize;\n        var inSize = 1;\n        do {\n            p = list;\n            list = null;\n            tail = null;\n            numMerges = 0;\n            while (p) {\n                numMerges++;\n                q = p;\n                pSize = 0;\n                for (i = 0; i < inSize; i++) {\n                    pSize++;\n                    q = q.nextZ;\n                    if (!q)\n                        break;\n                }\n                qSize = inSize;\n                while (pSize > 0 || (qSize > 0 && q)) {\n                    if (pSize !== 0 && (qSize === 0 || !q || p.z <= q.z)) {\n                        e = p;\n                        p = p.nextZ;\n                        pSize--;\n                    }\n                    else {\n                        e = q;\n                        q = q.nextZ;\n                        qSize--;\n                    }\n                    if (tail)\n                        tail.nextZ = e;\n                    else\n                        list = e;\n                    e.prevZ = tail;\n                    tail = e;\n                }\n                p = q;\n            }\n            tail.nextZ = null;\n            inSize *= 2;\n        } while (numMerges > 1);\n        return list;\n    };\n    // z-order of a point given coords and inverse of the longer side of data bbox\n    var zOrder = function (x, y, minX, minY, invSize) {\n        // coords are transformed into non-negative 15-bit integer range\n        x = 32767 * (x - minX) * invSize;\n        y = 32767 * (y - minY) * invSize;\n        x = (x | (x << 8)) & 0x00FF00FF;\n        x = (x | (x << 4)) & 0x0F0F0F0F;\n        x = (x | (x << 2)) & 0x33333333;\n        x = (x | (x << 1)) & 0x55555555;\n        y = (y | (y << 8)) & 0x00FF00FF;\n        y = (y | (y << 4)) & 0x0F0F0F0F;\n        y = (y | (y << 2)) & 0x33333333;\n        y = (y | (y << 1)) & 0x55555555;\n        return x | (y << 1);\n    };\n    // find the leftmost node of a polygon ring\n    var getLeftmost = function (start) {\n        var p = start;\n        var leftmost = start;\n        do {\n            if (p.x < leftmost.x || (p.x === leftmost.x && p.y < leftmost.y)) {\n                leftmost = p;\n            }\n            p = p.next;\n        } while (p !== start);\n        return leftmost;\n    };\n    // check if a point lies within a convex triangle\n    // TODO: use Triangle.containsPoint\n    var pointInTriangle = function (ax, ay, bx, by, cx, cy, px, py) {\n        return (cx - px) * (ay - py) - (ax - px) * (cy - py) >= 0 &&\n            (ax - px) * (by - py) - (bx - px) * (ay - py) >= 0 &&\n            (bx - px) * (cy - py) - (cx - px) * (by - py) >= 0;\n    };\n    // check if a diagonal between two polygon nodes is valid (lies in polygon interior)\n    var isValidDiagonal = function (a, b) {\n        return a.next.i !== b.i && a.prev.i !== b.i && !intersectsPolygon(a, b) && // dones't intersect other edges\n            (locallyInside(a, b) && locallyInside(b, a) && middleInside(a, b) && // locally visible\n                (area(a.prev, a, b.prev) != 0 || area(a, b.prev, b)) != 0 || // does not create opposite-facing sectors\n                equals(a, b) && area(a.prev, a, a.next) > 0 && area(b.prev, b, b.next) > 0); // special zero-length case\n    };\n    // signed area of a triangle\n    var area = function (p, q, r) {\n        return (q.y - p.y) * (r.x - q.x) - (q.x - p.x) * (r.y - q.y);\n    };\n    // check if two points are equal\n    // TODO: as member function of vertex\n    var equals = function (p1, p2) {\n        return p1.x === p2.x && p1.y === p2.y;\n    };\n    // check if two segments intersect\n    // TODO: use Line.intersects\n    var intersects = function (p1, q1, p2, q2) {\n        var o1 = sign(area(p1, q1, p2));\n        var o2 = sign(area(p1, q1, q2));\n        var o3 = sign(area(p2, q2, p1));\n        var o4 = sign(area(p2, q2, q1));\n        if (o1 !== o2 && o3 !== o4)\n            return true; // general case\n        if (o1 === 0 && onSegment(p1, p2, q1))\n            return true; // p1, q1 and p2 are collinear and p2 lies on p1q1\n        if (o2 === 0 && onSegment(p1, q2, q1))\n            return true; // p1, q1 and q2 are collinear and q2 lies on p1q1\n        if (o3 === 0 && onSegment(p2, p1, q2))\n            return true; // p2, q2 and p1 are collinear and p1 lies on p2q2\n        if (o4 === 0 && onSegment(p2, q1, q2))\n            return true; // p2, q2 and q1 are collinear and q1 lies on p2q2\n        return false;\n    };\n    // for collinear points p, q, r, check if point q lies on segment pr\n    var onSegment = function (p, q, r) {\n        return q.x <= Math.max(p.x, r.x) && q.x >= Math.min(p.x, r.x) && q.y <= Math.max(p.y, r.y) && q.y >= Math.min(p.y, r.y);\n    };\n    var sign = function (num) {\n        return num > 0 ? 1 : num < 0 ? -1 : 0;\n    };\n    // check if a polygon diagonal intersects any polygon segments\n    var intersectsPolygon = function (a, b) {\n        var p = a;\n        do {\n            if (p.i !== a.i && p.next.i !== a.i && p.i !== b.i && p.next.i !== b.i && intersects(p, p.next, a, b)) {\n                return true;\n            }\n            p = p.next;\n        } while (p !== a);\n        return false;\n    };\n    // check if a polygon diagonal is locally inside the polygon\n    var locallyInside = function (a, b) {\n        return area(a.prev, a, a.next) < 0 ?\n            area(a, b, a.next) >= 0 && area(a, a.prev, b) >= 0 :\n            area(a, b, a.prev) < 0 || area(a, a.next, b) < 0;\n    };\n    // check if the middle point of a polygon diagonal is inside the polygon\n    var middleInside = function (a, b) {\n        var p = a;\n        var inside = false;\n        var px = (a.x + b.x) / 2;\n        var py = (a.y + b.y) / 2;\n        // TODO: call Polygon.contains here?\n        do {\n            if (((p.y > py) !== (p.next.y > py)) && p.next.y !== p.y &&\n                (px < (p.next.x - p.x) * (py - p.y) / (p.next.y - p.y) + p.x))\n                inside = !inside;\n            p = p.next;\n        } while (p !== a);\n        return inside;\n    };\n    // link two polygon vertices with a bridge; if the vertices belong to the same ring, it splits polygon into two;\n    // if one belongs to the outer ring and another to a hole, it merges it into a single ring\n    var splitPolygon = function (a, b) {\n        var a2 = new Node(a.i, a.x, a.y);\n        var b2 = new Node(b.i, b.x, b.y);\n        var an = a.next;\n        var bp = b.prev;\n        a.next = b;\n        b.prev = a;\n        a2.next = an;\n        an.prev = a2;\n        b2.next = a2;\n        a2.prev = b2;\n        bp.next = b2;\n        b2.prev = bp;\n        return b2;\n    };\n    // create a node and optionally link it with previous one (in a circular doubly linked list)\n    var insertNode = function (i, x, y, last) {\n        var p = new Node(i, x, y);\n        if (!last) {\n            p.prev = p;\n            p.next = p;\n        }\n        else {\n            p.next = last.next;\n            p.prev = last;\n            last.next.prev = p;\n            last.next = p;\n        }\n        return p;\n    };\n    var removeNode = function (p) {\n        p.next.prev = p.prev;\n        p.prev.next = p.next;\n        if (p.prevZ)\n            p.prevZ.nextZ = p.nextZ;\n        if (p.nextZ)\n            p.nextZ.prevZ = p.prevZ;\n    };\n    var signedArea = function (data, start, end, dim) {\n        var sum = 0;\n        for (var i = start, j = end - dim; i < end; i += dim) {\n            sum += (data[j] - data[i]) * (data[i + 1] + data[j + 1]);\n            j = i;\n        }\n        return sum;\n    };\n    return earcut;\n})();\n//# sourceMappingURL=earcut.js.map","\"use strict\";\n/**\n * A helper to apply bumpmaps to any rectangular mesh.\n *\n * @author  Ikaros Kappler\n * @date    2021-09-06\n * @version 1.0.0\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.BumpMapper = void 0;\nvar THREE = require(\"three\");\nvar computeVertexNormals_1 = require(\"./computeVertexNormals\");\nvar GeometryGenerationHelpers_1 = require(\"./GeometryGenerationHelpers\");\nexports.BumpMapper = {\n    applyBumpmap: function (dildoGeometry, bufferedGeometry, bumpmap, material, options) {\n        var collectedVertexNormals = (0, computeVertexNormals_1.computeVertexNormals)(dildoGeometry, bufferedGeometry);\n        var dildoNormalGeometry = new THREE.Geometry();\n        dildoNormalGeometry.vertices = collectedVertexNormals.map(function (normalLine) {\n            var endPoint = normalLine.end.clone();\n            GeometryGenerationHelpers_1.GeometryGenerationHelpers.normalizeVectorXYZ(normalLine.start, endPoint, options.bumpmapStrength);\n            return endPoint;\n        });\n        var dildoNormalsMesh = new THREE.Points(dildoNormalGeometry, new THREE.PointsMaterial({\n            size: 1.4,\n            color: 0x00ffff\n        }));\n        // if (options.showBumpmapTargets) {\n        //   dildoNormalsMesh.position.y = -100;\n        //   this.addMesh(dildoNormalsMesh);\n        // }\n        var dildoMesh = null;\n        console.log(\"options.useBumpmap\", options.useBumpmap, \"bumpmap\", bumpmap);\n        // const heightMap = createHeightMapFromImage( bumpmapTexture ):\n        if (options.useBumpmap && bumpmap) {\n            for (var y = 0; y < dildoGeometry.vertexMatrix.length; y++) {\n                for (var x = 0; x < dildoGeometry.vertexMatrix[y].length; x++) {\n                    var vertIndex = dildoGeometry.vertexMatrix[y][x];\n                    var vertex = dildoGeometry.vertices[vertIndex];\n                    var yRatio = 1.0 - y / (dildoGeometry.vertexMatrix.length - 1);\n                    var xRatio = x / (dildoGeometry.vertexMatrix[y].length - 1);\n                    var lerpFactor = bumpmap.getHeightAt(xRatio, yRatio);\n                    var lerpTarget = dildoNormalGeometry.vertices[vertIndex];\n                    vertex.lerp(lerpTarget, lerpFactor);\n                }\n            }\n            // Also lerp top point\n            //   const vertIndex: number = dildoGeometry.topIndex;\n            //   //   const vertIndex: number = dildoGeometry.vertexMatrix[dildoGeometry.vertexMatrix.length - 1][0];\n            //   const vertex: THREE.Vector3 = dildoGeometry.vertices[vertIndex];\n            //   const yRatio: number = 0.0;\n            //   const xRatio: number = 0.5;\n            //   const lerpFactor: number = bumpmap.getHeightAt(xRatio, yRatio);\n            //   const lerpTarget: THREE.Vector3 = dildoNormalGeometry.vertices[vertIndex];\n            //   vertex.lerp(lerpTarget, lerpFactor);\n            // Override the buffered geometry! (bumpmap has been applied)\n            bufferedGeometry = new THREE.BufferGeometry().fromGeometry(dildoGeometry);\n            bufferedGeometry.computeVertexNormals();\n            // Override the mesh! (bumpmap has been applied)\n            dildoMesh = new THREE.Mesh(bufferedGeometry, material);\n        }\n        return { dildoMesh: dildoMesh, dildoNormalsMesh: dildoNormalsMesh };\n    }\n};\n//# sourceMappingURL=BumpMapper.js.map","\"use strict\";\n/**\n * A class to manage 3d scenes and the generation of dildo models.\n *\n * @author   Ikaros Kappler\n * @date     2020-07-01\n * @modified 2020-09-11 Added proper texture loading.\n * @modified 2021-06-07 Fixing `removeCachedGeometries`. Adding bending of model.\n * @modified 2021-08-29 Ported this class to Typescript from vanilla JS.\n * @version  1.2.1\n **/\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.DildoGeneration = void 0;\nvar THREE = require(\"three\");\nvar VertexNormalsHelper_1 = require(\"three/examples/jsm/helpers/VertexNormalsHelper\");\nvar DildoGeometry_1 = require(\"./DildoGeometry\");\nvar DildoMaterials_1 = require(\"./DildoMaterials\");\nvar GeometryGenerationHelpers_1 = require(\"./GeometryGenerationHelpers\");\nvar mergeGeometries_1 = require(\"./mergeGeometries\");\nvar PathFinder_1 = require(\"./PathFinder\");\nvar randomWebColor_1 = require(\"./randomWebColor\");\nvar constants_1 = require(\"./constants\");\nvar BumpMapper_1 = require(\"./BumpMapper\");\nvar DildoGeneration = /** @class */ (function () {\n    function DildoGeneration(canvasId, options) {\n        this.canvas = document.getElementById(canvasId);\n        this.parent = this.canvas.parentElement;\n        this.scene = new THREE.Scene();\n        this.camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 10000);\n        this.camera.position.z = 500;\n        var lightDistanceFactor = 10.0;\n        var intensityFactor = 1.0;\n        this.ambientLightA = new THREE.AmbientLight(0x444444);\n        this.ambientLightA.position.set(350, 0, -350).multiplyScalar(lightDistanceFactor * 5);\n        // this.ambientLightA = new THREE.PointLight(0xffffff, intensityFactor * 5.0, 350.0 * lightDistanceFactor, 0.5); // color, intensity, distance, decay);\n        // this.ambientLightA.position.set(350, 0, -350).multiplyScalar(lightDistanceFactor);\n        this.scene.add(this.ambientLightA);\n        this.ambientLightB = new THREE.PointLight(0xffffff, intensityFactor * 5.0, 350.0 * lightDistanceFactor, 0.5); // color, intensity, distance, decay);\n        this.ambientLightB.position.set(-350, 0, 350).multiplyScalar(lightDistanceFactor);\n        this.scene.add(this.ambientLightB);\n        this.directionalLightA = new THREE.DirectionalLight(0xffffff, intensityFactor * 2.0);\n        // this.directionalLightA = new THREE.PointLight(0xffffff, 1.0, 350.0 * lightDistanceFactor, 0.5); // color, intensity, distance, decay);\n        this.directionalLightA.position.set(350, 350, 350).multiplyScalar(lightDistanceFactor);\n        this.scene.add(this.directionalLightA);\n        this.scene.add(this.directionalLightA.target);\n        this.directionalLightB = new THREE.DirectionalLight(0xffffff, intensityFactor * 2.0);\n        this.directionalLightB.position.set(-350, -350, -50).multiplyScalar(lightDistanceFactor);\n        this.scene.add(this.directionalLightB);\n        this.renderer = new THREE.WebGLRenderer({\n            canvas: this.canvas,\n            preserveDrawingBuffer: true,\n            antialias: true // false\n        });\n        // TODO: check if this works!\n        // this.controls = new OrbitControls(this.camera, this.renderer.domElement);\n        this.controls = options.makeOrbitControls(this.camera, this.renderer.domElement);\n        this.controls.update();\n        // Cache all geometries for later removal\n        this.geometries = [];\n        // Remember partial results\n        // Record<string,object>\n        this.partialResults = {};\n        var _self = this;\n        window.addEventListener(\"resize\", function () {\n            _self.resizeCanvas();\n        });\n        this.resizeCanvas();\n        var animate = function () {\n            requestAnimationFrame(animate);\n            _self.controls.update();\n            _self.renderer.render(_self.scene, _self.camera);\n        };\n        animate();\n    }\n    /**\n     * Resize the 3d canvas to fit its container.\n     */\n    DildoGeneration.prototype.resizeCanvas = function () {\n        var width = window.innerWidth || document.documentElement.clientWidth || document.body.clientWidth;\n        var height = window.innerHeight || document.documentElement.clientHeight || document.body.clientHeight;\n        this.canvas.width = width;\n        this.canvas.height = height;\n        this.canvas.style.width = \"\" + width + \"px\";\n        this.canvas.style.height = \"\" + height + \"px\";\n        this.canvas.setAttribute(\"width\", \"\" + width + \"px\");\n        this.canvas.setAttribute(\"height\", height + \"px\");\n        this.renderer.setSize(width, height);\n        // What am I doing here?\n        this.camera.setViewOffset(width, height, width / 4, height / 20, width, height);\n    };\n    /**\n     * Clears the current scene and rebuilds everything from scratch according to the\n     * mesh options being passed.\n     *\n     * @param {BezierPath} options.outline\n     * @param {number}     options.segmentCount\n     * @param {number}     options.outlineSegmentCount (>= 2).\n     * @param {number}     options.bendAngle The bending angle in degrees (!).\n     * @param {boolean}    options.performSlice\n     * @param {boolean?}   options.useTextureImage\n     * @param {string?}    options.textureImagePath\n     * @param {boolean?}   options.wireframe\n     * @param {string}     options.renderFaces - \"double\" or \"front\" (default) or \"back\"\n     **/\n    DildoGeneration.prototype.rebuild = function (options) {\n        this.removeCachedGeometries();\n        var baseRadius = options.outline.getBounds().width;\n        var baseShape = GeometryGenerationHelpers_1.GeometryGenerationHelpers.mkCircularPolygon(baseRadius, options.shapeSegmentCount, options.baseShapeExcentricity);\n        var useBumpmap = typeof options.useBumpmap !== \"undefined\" ? options.useBumpmap : false;\n        // const bumpmapPath = \"./assets/img/bumpmap.png\";\n        // const bumpmapTexture: THREE.Texture | null = useBumpmap ? DildoMaterials.loadTextureImage(bumpmapPath) : null;\n        var bumpmap = useBumpmap && options.bumpmap ? options.bumpmap : null;\n        var dildoGeometry = new DildoGeometry_1.DildoGeometry(Object.assign({ baseShape: baseShape /*, bumpmapTexture: bumpmapTexture */ }, options));\n        var useTextureImage = options.useTextureImage && typeof options.textureImagePath !== \"undefined\";\n        var textureImagePath = typeof options.textureImagePath !== \"undefined\" ? options.textureImagePath : null;\n        var doubleSingleSide = options.renderFaces === \"double\" ? THREE.DoubleSide : options.renderFaces === \"back\" ? THREE.BackSide : THREE.FrontSide;\n        var wireframe = typeof options.wireframe !== \"undefined\" ? options.wireframe : false;\n        // const isBumpmappingPossible : boolean = (options.useBumpmap && bumpmapTexture);\n        var material = DildoMaterials_1.DildoMaterials.createMainMaterial(useTextureImage, wireframe, textureImagePath, doubleSingleSide);\n        // This can be overriden in later steps! (after bumpmap was applied)\n        var bufferedGeometry = new THREE.BufferGeometry().fromGeometry(dildoGeometry);\n        bufferedGeometry.computeVertexNormals();\n        // This can be overriden in later steps! (after bumpmap was applied)\n        var dildoMesh = new THREE.Mesh(bufferedGeometry, material);\n        this.camera.lookAt(new THREE.Vector3(20, 0, 150));\n        this.camera.lookAt(dildoMesh.position);\n        var spineGeometry = new THREE.Geometry();\n        dildoGeometry.spineVertices.forEach(function (spineVert) {\n            spineGeometry.vertices.push(spineVert.clone());\n        });\n        if (options.addSpine) {\n            GeometryGenerationHelpers_1.GeometryGenerationHelpers.addSpine(this, spineGeometry);\n        }\n        // Add perpendicular path?\n        if (options.showBasicPerpendiculars) {\n            GeometryGenerationHelpers_1.GeometryGenerationHelpers.addPerpendicularPaths(this, dildoGeometry);\n        }\n        // Show computed dildo normals?\n        // if (options.previewBumpmap || options.useBumpmap) {\n        if (options.useBumpmap) {\n            // const collectedVertexNormals: Array<THREE.Line3> = computeVertexNormals(\n            //   dildoGeometry as unknown as THREE.Geometry,\n            //   bufferedGeometry\n            // );\n            // const dildoNormalGeometry = new THREE.Geometry();\n            // dildoNormalGeometry.vertices = collectedVertexNormals.map((normalLine: THREE.Line3) => {\n            //   const endPoint: THREE.Vector3 = normalLine.end.clone();\n            //   GeometryGenerationHelpers.normalizeVectorXYZ(normalLine.start, endPoint, options.bumpmapStrength);\n            //   return endPoint;\n            // });\n            // const dildoNormalsMesh: THREE.Points = new THREE.Points(\n            //   dildoNormalGeometry,\n            //   new THREE.PointsMaterial({\n            //     size: 1.4,\n            //     color: 0x00ffff\n            //   })\n            // );\n            // if (options.showBumpmapTargets) {\n            //   dildoNormalsMesh.position.y = -100;\n            //   this.addMesh(dildoNormalsMesh);\n            // }\n            // console.log(\"options.useBumpmap\", options.useBumpmap, \"bumpmap\", bumpmap);\n            // // const heightMap = createHeightMapFromImage( bumpmapTexture ):\n            // if (options.useBumpmap && bumpmap) {\n            //   for (var y = 0; y < dildoGeometry.vertexMatrix.length; y++) {\n            //     for (var x = 0; x < dildoGeometry.vertexMatrix[y].length; x++) {\n            //       const vertIndex: number = dildoGeometry.vertexMatrix[y][x];\n            //       const vertex: THREE.Vector3 = dildoGeometry.vertices[vertIndex];\n            //       const yRatio: number = y / (dildoGeometry.vertexMatrix.length - 1);\n            //       const xRatio: number = x / (dildoGeometry.vertexMatrix[y].length - 1);\n            //       const lerpFactor: number = bumpmap.getHeightAt(xRatio, yRatio);\n            //       const lerpTarget: THREE.Vector3 = dildoNormalGeometry.vertices[vertIndex];\n            //       vertex.lerp(lerpTarget, lerpFactor);\n            //     }\n            //   }\n            //   // Override the buffered geometry! (bumpmap has been applied)\n            //   bufferedGeometry = new THREE.BufferGeometry().fromGeometry(dildoGeometry as unknown as THREE.Geometry);\n            //   bufferedGeometry.computeVertexNormals();\n            //   // Override the mesh! (bumpmap has been applied)\n            //   dildoMesh = new THREE.Mesh(bufferedGeometry, material);\n            // }\n            var _a = BumpMapper_1.BumpMapper.applyBumpmap(dildoGeometry, bufferedGeometry, bumpmap, material, options), bumpmappedDildoMesh = _a.dildoMesh, dildoNormalsMesh = _a.dildoNormalsMesh;\n            dildoMesh = bumpmappedDildoMesh;\n            if (options.showBumpmapTargets) {\n                dildoNormalsMesh.position.y = -100;\n                this.addMesh(dildoNormalsMesh);\n            }\n        }\n        if (options.performSlice) {\n            this.__performPlaneSlice(dildoMesh, dildoGeometry, wireframe, useTextureImage, textureImagePath, options);\n            // The CSG operations are not reliable.\n            // this.__performCsgSlice(latheMesh, geometry, material);\n        }\n        else {\n            dildoMesh.position.y = -100;\n            dildoMesh.userData[\"isExportable\"] = true;\n            this.addMesh(dildoMesh);\n            if (options.showNormals) {\n                var vnHelper = new VertexNormalsHelper_1.VertexNormalsHelper(dildoMesh, options.normalsLength, 0x00ff00); // Fourth param 1?\n                // TODO: use addMesh() here?\n                this.scene.add(vnHelper);\n                this.geometries.push(vnHelper);\n            }\n        }\n    };\n    /**\n     * Perform the actual slice operation.\n     *\n     * This will create several new meshes:\n     *  * a left geometry slice (along the z- axis).\n     *  * a right geometry slice (along the z+ axis).\n     *  * an inner slice cut geometry (inside the dildo model, cutting it into two halves).\n     *  * an outer slice cut geometry (inside the mould model, cutting that one into two halves).\n     *\n     * These will always be generated, even if the options tell different; if so then they are set\n     * to be invisible.\n     *\n     * @param {THREE.Geometry} latheMesh - The buffered dildo geometry (required to perform the slice operation).\n     * @param {DildoGeometry} latheUnbufferedGeometry - The unbuffered dildo geometry (required to obtain the perpendicular path lines).\n     * @param {boolean} wireframe\n     */\n    DildoGeneration.prototype.__performPlaneSlice = function (latheMesh, latheUnbufferedGeometry, wireframe, useTextureImage, textureImagePath, options) {\n        // var epsilon = 0.000001;\n        var leftPlane = new THREE.Plane(new THREE.Vector3(0, 0, 1), 0);\n        var leftSliceGeometry = GeometryGenerationHelpers_1.GeometryGenerationHelpers.makeSlice(latheUnbufferedGeometry, leftPlane);\n        var rightPlane = new THREE.Plane(new THREE.Vector3(0, 0, -1), 0);\n        var rightSliceGeometry = GeometryGenerationHelpers_1.GeometryGenerationHelpers.makeSlice(latheUnbufferedGeometry, rightPlane);\n        var sliceMaterial = DildoMaterials_1.DildoMaterials.createSliceMaterial(useTextureImage, wireframe, textureImagePath);\n        // Find points on intersection path (this is a single path in this configuration)\n        var planeGeom = new THREE.PlaneGeometry(300, 500);\n        var planeMesh = new THREE.Mesh(planeGeom, new THREE.MeshBasicMaterial({\n            color: 0x484848,\n            transparent: true,\n            opacity: 0.35,\n            side: THREE.DoubleSide\n        }));\n        planeMesh.rotation.x = Math.PI / 5;\n        this.partialResults[constants_1.KEY_SPLIT_PANE_MESH] = planeMesh;\n        if (options.showSplitPane) {\n            planeMesh.position.z = 0.5;\n            this.addMesh(planeMesh);\n        }\n        var planeIntersectionPoints = GeometryGenerationHelpers_1.GeometryGenerationHelpers.makeAndAddPlaneIntersection(this, latheMesh, latheUnbufferedGeometry, planeMesh, planeGeom, options);\n        // Find the connected path (there is only one if you choose the cut plane properly)\n        // Note that it doesn't matter which slice geometry we use as left and right match\n        // perfectly together at their cut plane.\n        // Array<number[]>\n        var connectedPaths = new PathFinder_1.PathFinder().findAllPathsOnMesh(leftSliceGeometry, planeIntersectionPoints);\n        // TEST what the connected paths look like\n        // TODO: add an option and only add to scene if desired.\n        for (var p = 0; p < connectedPaths.length; p++) {\n            var geometry = new THREE.Geometry();\n            geometry.vertices = connectedPaths[p].map(function (geometryVertexIndex) {\n                return leftSliceGeometry.vertices[geometryVertexIndex];\n            });\n            var linesMesh_1 = new THREE.Line(geometry, new THREE.LineBasicMaterial({\n                color: (0, randomWebColor_1.randomWebColor)(i, \"Mixed\") // 0x8800a8\n            }));\n            linesMesh_1.position.y = -100;\n            // linesMesh.position.z = -50;\n            this.addMesh(linesMesh_1);\n        }\n        if (options.addPrecalculatedShapeOutlines) {\n            // TEST what the line mesh looks like\n            var pointGeometry = new THREE.Geometry();\n            pointGeometry.vertices = planeIntersectionPoints;\n            var linesMesh = new THREE.Line(pointGeometry, new THREE.LineBasicMaterial({\n                color: 0x8800a8\n            }));\n            linesMesh.position.y = -100;\n            linesMesh.position.z = -50;\n            this.addMesh(linesMesh);\n        }\n        // Triangulate connected paths\n        var triangulatedGeometries = [];\n        for (var i = 0; i < connectedPaths.length; i++) {\n            var triangulationGeometry = GeometryGenerationHelpers_1.GeometryGenerationHelpers.makePlaneTriangulation(this, leftSliceGeometry, connectedPaths[i], options);\n            triangulatedGeometries.push(triangulationGeometry);\n            // Merge together left and right slice geometry with the triangulated\n            // cut faces.\n            if (options.closeCutAreas) {\n                (0, mergeGeometries_1.mergeGeometries)(leftSliceGeometry, triangulationGeometry, constants_1.EPS);\n                (0, mergeGeometries_1.mergeGeometries)(rightSliceGeometry, triangulationGeometry, constants_1.EPS);\n            }\n        }\n        if (options.showLeftSplit) {\n            leftSliceGeometry.uvsNeedUpdate = true;\n            // TODO: check if this is still required\n            leftSliceGeometry.buffersNeedUpdate = true;\n            leftSliceGeometry.computeVertexNormals();\n            var slicedMeshLeft = new THREE.Mesh(leftSliceGeometry, sliceMaterial);\n            slicedMeshLeft.position.y = -100;\n            slicedMeshLeft.position.z = -50;\n            slicedMeshLeft.userData[\"isExportable\"] = true;\n            this.addMesh(slicedMeshLeft);\n            if (options.showNormals) {\n                var vnHelper = new VertexNormalsHelper_1.VertexNormalsHelper(slicedMeshLeft, options.normalsLength, 0x00ff00);\n                this.scene.add(vnHelper);\n                this.geometries.push(vnHelper);\n            }\n        }\n        if (options.showRightSplit) {\n            rightSliceGeometry.uvsNeedUpdate = true;\n            // TODO: check if this is still required\n            rightSliceGeometry.buffersNeedUpdate = true;\n            rightSliceGeometry.computeVertexNormals();\n            var slicedMeshRight = new THREE.Mesh(rightSliceGeometry, sliceMaterial);\n            slicedMeshRight.position.y = -100;\n            slicedMeshRight.position.z = 50;\n            slicedMeshRight.userData[\"isExportable\"] = true;\n            this.addMesh(slicedMeshRight);\n            if (options.showNormals) {\n                var vnHelper = new VertexNormalsHelper_1.VertexNormalsHelper(slicedMeshRight, options.normalsLength, 0x00ff00);\n                this.scene.add(vnHelper);\n                this.geometries.push(vnHelper);\n            }\n        }\n        // Remember everything\n        this.partialResults[constants_1.KEY_LEFT_SLICE_PLANE] = leftPlane;\n        this.partialResults[constants_1.KEY_LEFT_SLICE_GEOMETRY] = leftSliceGeometry;\n        this.partialResults[constants_1.KEY_RIGHT_SLICE_PLANE] = rightPlane;\n        this.partialResults[constants_1.KEY_RIGHT_SLICE_GEOMETRY] = rightSliceGeometry;\n        this.partialResults[constants_1.KEY_PLANE_INTERSECTION_POINTS] = planeIntersectionPoints;\n        this.partialResults[constants_1.KEY_SPLIT_TRIANGULATION_GEOMETRIES] = triangulatedGeometries;\n    };\n    //   /**\n    //    * Make a triangulation of the given path specified by the verted indices.\n    //    *\n    //    * @param {Array<number>} connectedPath - An array of vertex indices.\n    //    * @return {THREE.Geometry} trianglesMesh\n    //    */\n    //   var makePlaneTriangulation = function (generator, sliceGeometry, connectedPath, options) {\n    //     // Convert the connected paths indices to [x, y, x, y, x, y, ...] coordinates (requied by earcut)\n    //     var currentPathXYData = connectedPath.reduce(function (earcutInput, vertIndex) {\n    //       var vert = sliceGeometry.vertices[vertIndex];\n    //       earcutInput.push(vert.x, vert.y);\n    //       return earcutInput;\n    //     }, []);\n    //     // Array<number> : triplets of vertex indices in the plain XY array\n    //     var triangles = earcut(currentPathXYData);\n    //     // Convert triangle indices back to a geometry\n    //     var trianglesGeometry = new THREE.Geometry();\n    //     // We will merge the geometries in the end which will create clones of the vertices.\n    //     // No need to clone here.\n    //     // trianglesGeometry.vertices = leftSliceGeometry.vertices;\n    //     trianglesGeometry.vertices = connectedPath.map(function (geometryVertexIndex) {\n    //       return sliceGeometry.vertices[geometryVertexIndex];\n    //     });\n    //     // Array<{x,y}> is compatible with Array<{x,y,z}> here :)\n    //     var flatSideBounds = Bounds.computeFromVertices(trianglesGeometry.vertices);\n    //     for (var t = 0; t < triangles.length; t += 3) {\n    //       var a = triangles[t];\n    //       var b = triangles[t + 1];\n    //       var c = triangles[t + 2];\n    //       trianglesGeometry.faces.push(new THREE.Face3(a, b, c));\n    //       // Add UVs\n    //       UVHelpers.makeFlatTriangleUVs(trianglesGeometry, flatSideBounds, a, b, c);\n    //     }\n    //     trianglesGeometry.uvsNeedUpdate = true;\n    //     trianglesGeometry.buffersNeedUpdate = true;\n    //     trianglesGeometry.computeVertexNormals();\n    //     var trianglesMesh = new THREE.Mesh(\n    //       trianglesGeometry,\n    //       new THREE.MeshBasicMaterial({\n    //         color: 0x0048ff,\n    //         transparent: true,\n    //         opacity: 0.55,\n    //         side: THREE.DoubleSide\n    //       })\n    //     );\n    //     trianglesMesh.position.y = -100;\n    //     // trianglesMesh.position.z += 1.0; // Avoid Moiré with plane mesh?\n    //     trianglesMesh.userData[\"isExportable\"] = false;\n    //     generator.partialResults[KEY_PLANE_INTERSECTION_TRIANGULATION] = trianglesGeometry;\n    //     if (options.showSplitShapeTriangulation) {\n    //       generator.addMesh(trianglesMesh);\n    //     }\n    //     return trianglesGeometry;\n    //   };\n    /**\n     * NOT CURRENTLY IN USE (too unstable?)\n     *\n     * @param {*} latheMesh\n     * @param {*} latheUnbufferedGeometry\n     * @param {*} material\n     */\n    //   __performCsgSlice(latheMesh, latheUnbufferedGeometry, material) {\n    //     latheMesh.updateMatrix();\n    //     var bbox = new THREE.Box3().setFromObject(latheMesh);\n    //     // console.log(bbox);\n    //     var box_material = new THREE.MeshBasicMaterial({ wireframe: true });\n    //     var cube_geometry = new THREE.BoxGeometry( // new THREE.CubeGeometry(\n    //       ((bbox.max.x - bbox.min.x) / 2) * 1.2 + 0.01,\n    //       (bbox.max.y - bbox.min.y) * 1.1,\n    //       (bbox.max.z - bbox.min.z) * 1.2\n    //     );\n    //     var cube_mesh = new THREE.Mesh(cube_geometry, box_material);\n    //     cube_mesh.updateMatrix();\n    //     cube_mesh.position.x = latheMesh.position.x + (bbox.max.x - bbox.min.x) / 4;\n    //     cube_mesh.position.y = bbox.min.y + (bbox.max.y - bbox.min.y) / 2 + -30;\n    //     cube_mesh.position.z = bbox.min.z + (bbox.max.z - bbox.min.z) / 2;\n    //     this.addMesh(cube_mesh);\n    //     var cube_bsp = new ThreeBSP(cube_mesh);\n    //     var mesh_bsp = new ThreeBSP(new THREE.Mesh(latheUnbufferedGeometry, material));\n    //     var subtract_bsp = cube_bsp.subtract(mesh_bsp);\n    //     var result = subtract_bsp.toMesh(material);\n    //     this.addMesh(result);\n    //   };\n    /**\n     * Add a mesh to the underlying scene.\n     *\n     * The function will make some modifications to the rotation of the meshes.\n     * @param {THREE.Mesh} mesh\n     */\n    DildoGeneration.prototype.addMesh = function (mesh) {\n        mesh.rotation.x = Math.PI;\n        this.scene.add(mesh);\n        this.geometries.push(mesh);\n    };\n    DildoGeneration.prototype.removeCachedGeometries = function () {\n        for (var i = 0; i < this.geometries.length; i++) {\n            var old = this.geometries[i];\n            // Remove old object.\n            //  A better way would be to update the lathe in-place. Possible?\n            this.scene.remove(old);\n            //   if (typeof old.dispose == \"function\") old.dispose();\n            //   if (typeof old.material != \"undefined\" && typeof old.material.dispose == \"function\") old.material.dispose();\n            if (old instanceof THREE.Mesh) {\n                old.geometry.dispose();\n                old.material.dispose();\n            }\n        }\n        this.geometries = [];\n    };\n    /**\n     * Generate an STL string from the (exportable) meshes that are currently stored inside this generator.\n     *\n     * @param {function(string)} options.onComplete\n     **/\n    DildoGeneration.prototype.generateSTL = function (options, exporter) {\n        // const exporter: STLExporter = new STLExporter();\n        var stlBuffer = [];\n        // TODO: merge all exportable geometries together and export as one.\n        for (var i in this.geometries) {\n            if (this.geometries[i].userData[\"isExportable\"] === true) {\n                var stlData = exporter.parse(this.geometries[i]);\n                stlBuffer.push(stlData);\n            }\n        }\n        if (typeof options.onComplete === \"function\") {\n            options.onComplete(stlBuffer.join(\"\\n\\n\"));\n        }\n        else {\n            console.warn(\"STL data was generated but no 'onComplete' callback was defined.\");\n        }\n    };\n    return DildoGeneration;\n}()); // END class\nexports.DildoGeneration = DildoGeneration;\n//# sourceMappingURL=DildoGeneration.js.map","\"use strict\";\n/**\n * @require THREE.Geometry\n *\n * @author   Ikaros Kappler\n * @date     2020-07-08\n * @modified 2021-06-11 Fixing top and bottom points; preparing slicing of mesh.\n * @modified 2021-08-29 Ported to Typescript from vanilla JS.\n * @version  1.0.2\n **/\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        if (typeof b !== \"function\" && b !== null)\n            throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.DildoGeometry = exports.DildoBaseClass = void 0;\n// TODOs\n// + Add cut-plane faces when hollow\n// + Move vertex-creating helper functions out of the class\n// + Move face-creating helper functions out of the class\n// + Move UV-creating helper functions out of the class\n// + port to typescript\nvar plotboilerplate_1 = require(\"plotboilerplate\");\nvar THREE = require(\"three\");\nvar GeometryGenerationHelpers_1 = require(\"./GeometryGenerationHelpers\");\n// import { earcut } from \"./thirdparty-ported/earcut\"; // TODO: fix earcut types\nvar earcut_typescript_1 = require(\"earcut-typescript\"); // TODO: fix earcut types\nvar UVHelpers_1 = require(\"./UVHelpers\");\nvar DEG_TO_RAD = Math.PI / 180.0;\n// import { DEG_TO_RAD } from \"./constants\";\n// This is a dirty workaround to\n// avoid direct class extending of THREE.Geometry.\n// I am using `THREE.Geometry.call(this);` instead :/\nvar DildoBaseClass = /** @class */ (function () {\n    function DildoBaseClass() {\n        this.vertices = [];\n        this.faces = [];\n        this.faceVertexUvs = [[]];\n    }\n    return DildoBaseClass;\n}());\nexports.DildoBaseClass = DildoBaseClass;\n// export class DildoGeometry { // extends globalThis.THREE.Geometry {\nvar DildoGeometry = /** @class */ (function (_super) {\n    __extends(DildoGeometry, _super);\n    /**\n     * Create a new dildo geometry from the passed options..\n     *\n     * @param {Polygon} options.baseShape - The base shape to use (this is usually some regular polygon).\n     * @param {BezierPath} options.outline - The lathe outline to use.\n     * @param {number} options.bendAngle - A bend angle (in degrees!). Will only be applied if isBending=true.\n     * @param {number} options.outlineSegmentCount (>= 2).\n     * @param {boolean} options.isBending - Switch bending on/off no matter what the bend angle says.\n     * @param {boolean} options.makeHollow - Make a hollow mold.\n     **/\n    function DildoGeometry(options) {\n        var _this = _super.call(this) || this;\n        THREE.Geometry.call(_this);\n        _this.vertexMatrix = []; // Array<Array<number>>\n        _this.topIndex = -1;\n        _this.bottomIndex = -1;\n        _this.spineVertices = []; // Array<THREE.Vector>\n        _this.outerPerpLines = []; // Array<Three.Line3>\n        _this.innerPerpLines = []; // Array<Three.Line3>\n        _this.flatSidePolygon = null; // Polygon (2d)\n        _this.leftFlatIndices = []; // Array<number>\n        _this.rightFlatIndices = []; // Array<number>\n        _this.leftFlatTriangleIndices = []; // Array[[number,number,number]]\n        _this.rightFlatTriangleIndices = []; // Array[[number,number,number]]\n        _this.flatSideBounds = null; // Bounds\n        // The four corner vertices from the hollow shell plus the bottom vertex indices left and right\n        _this.hollowBottomEdgeVertIndices = []; // [number,number,number,number, number, number]\n        _this.hollowBottomTriagles = []; // Array<[number,number,number]>\n        _this.dildoNormals = [];\n        _this._buildVertices(options);\n        _this._buildFaces(options);\n        _this._buildUVMapping(options);\n        // Fill up missing UVs to avoid warnings\n        // This is a bit dirty, but not in call cases it is useful to create UV mappings\n        // while (this.faceVertexUvs[0].length < this.faces.length) {\n        //   this.faceVertexUvs[0].push([new THREE.Vector2(0, 0), new THREE.Vector2(1, 0), new THREE.Vector2(0.5, 1)]);\n        // }\n        if (options.useBumpmap) {\n            if (options.bumpmapTexture) {\n                _this.__applyBumpmap(options.bumpmapTexture);\n            }\n            else {\n                console.warn(\"Cannot apply bumpmap as desired, because the bumpmap texture is null or undefined.\");\n            }\n        }\n        return _this;\n    }\n    /**\n     *\n     * @param {Polygon} baseShape\n     * @param {Vertex} shapeCenter\n     * @param {Bounds} outlineBounds\n     * @param {THREE.Vertex3} outlineVert\n     * @param {number} sliceIndex\n     * @param {number} heightT A value between 0.0 and 1.0 (inclusive) to indicate the height position.\n     * @param {boolean} isBending\n     * @param {number=} bendAngle Must not be null, NaN or infinity if `isBending==true`\n     * @param {number=} arcRadius\n     * @param {boolean=} normalizePerpendiculars\n     * @param {number=} normalsLength\n     * @param {number=0} shapeTwistAngle - The angle to twist this particular shape around the y axis.\n     * @return { yMin: number, yMax : number }\n     */\n    DildoGeometry.prototype.__buildSlice = function (baseShape, outlineBounds, outlineVert, sliceIndex, heightT, isBending, bendAngle, arcRadius, shapeTwistAngle) {\n        var outlineXPct = (outlineBounds.max.x - outlineVert.x) / outlineBounds.width;\n        // TODO: are these is use?\n        var yMin, yMax;\n        for (var i = 0; i < baseShape.vertices.length; i++) {\n            var shapeVert = baseShape.vertices[i];\n            if (isBending) {\n                var vert = new THREE.Vector3(shapeVert.x * outlineXPct, 0, shapeVert.y * outlineXPct);\n                // Apply twist\n                rotateVertY(vert, shapeTwistAngle, 0, 0);\n                this._bendVertex(vert, bendAngle, arcRadius, heightT);\n                vert.y += outlineBounds.max.y;\n            }\n            else {\n                var vert = new THREE.Vector3(shapeVert.x * outlineXPct, outlineVert.y, shapeVert.y * outlineXPct);\n                // Apply twist\n                rotateVertY(vert, shapeTwistAngle, 0, 0);\n            }\n            this.vertexMatrix[sliceIndex][i] = this.vertices.length;\n            this.vertices.push(vert);\n            if (sliceIndex == 0) {\n                if (i == 0)\n                    yMin = vert.y;\n                if (i + 1 == baseShape.vertices.length)\n                    yMax = vert.y;\n            }\n        } // END for\n    };\n    /**\n     *\n     * @param {Polygon} baseShape\n     * @param {Vertex} shapeCenter\n     * @param {Bounds} outlineBounds\n     * @param {THREE.Vertex3} outlineVert\n     * @param {number} sliceIndex\n     * @param {number} heightT A value between 0.0 and 1.0 (inclusive) to indicate the height position.\n     * @param {boolean} isBending\n     * @param {number=} bendAngle Must not be null, NaN or infinity if `isBending==true`\n     * @param {number=} arcRadius\n     * @param {boolean=} normalizePerpendiculars\n     * @param {number=} normalsLength\n     * @return { yMin: number, yMax : number }\n     */\n    DildoGeometry.prototype.__buildSpine = function (shapeCenter, outlineBounds, outlineVert, heightT, isBending, bendAngle, arcRadius) {\n        var outlineXPct = (outlineBounds.max.x - outlineVert.x) / outlineBounds.width;\n        // Find shape's center point to construct a spine\n        var spineVert = shapeCenter.clone();\n        if (isBending) {\n            var vert = new THREE.Vector3(spineVert.x * outlineXPct, 0, spineVert.y * outlineXPct);\n            this._bendVertex(vert, bendAngle, arcRadius, heightT);\n            vert.y += outlineBounds.max.y;\n        }\n        else {\n            var vert = new THREE.Vector3(spineVert.x * outlineXPct, outlineVert.y, spineVert.y * outlineXPct);\n        }\n        this.spineVertices.push(vert);\n    };\n    /**\n     *\n     * @param {Polygon} baseShape\n     * @param {Bounds} outlineBounds\n     * @param {THREE.Vertex3} outlineVert\n     * @param {number} sliceIndex\n     * @param {number} heightT A value between 0.0 and 1.0 (inclusive) to indicate the height position.\n     * @param {boolean} isBending\n     * @param {number=} bendAngle Must not be null, NaN or infinity if `isBending==true`\n     * @param {number=} arcRadius\n     * @param {boolean=} normalizePerpendiculars\n     * @param {number=} normalsLength\n     * @return { yMin: number, yMax : number }\n     */\n    DildoGeometry.prototype.__buildPerps = function (baseShape, outlineBounds, outlineVert, // THREE.Vector3?\n    perpendicularVert, heightT, isBending, bendAngle, arcRadius, normalizePerpendiculars, normalsLength) {\n        var outlineXPct = (outlineBounds.max.x - outlineVert.x) / outlineBounds.width;\n        var halfIndices = [0, Math.floor(baseShape.vertices.length / 2)];\n        for (var j = 0; j < halfIndices.length; j++) {\n            var i = halfIndices[j];\n            var shapeVert = baseShape.vertices[i];\n            if (isBending) {\n                var vert = new THREE.Vector3(shapeVert.x * outlineXPct, 0, shapeVert.y * outlineXPct);\n                this._bendVertex(vert, bendAngle, arcRadius, heightT);\n                vert.y += outlineBounds.max.y;\n            }\n            else {\n                var vert = new THREE.Vector3(shapeVert.x * outlineXPct, outlineVert.y, shapeVert.y * outlineXPct);\n            }\n            var perpDifference = new THREE.Vector3(outlineVert.x - perpendicularVert.x, outlineVert.y - perpendicularVert.y, 0);\n            // TODO: check (this is in both cases the same)\n            if (i == 0)\n                var endVert = new THREE.Vector3(vert.x - perpendicularVert.x, vert.y + perpendicularVert.y, 0);\n            else\n                var endVert = new THREE.Vector3(vert.x + perpendicularVert.x, vert.y + perpendicularVert.y, 0);\n            rotateVert(endVert, bendAngle * heightT, vert.x, vert.y);\n            var outerPerpVert = vert.clone();\n            outerPerpVert.x += perpDifference.x;\n            outerPerpVert.y += perpDifference.y;\n            outerPerpVert.z += perpDifference.z;\n            if (normalizePerpendiculars) {\n                GeometryGenerationHelpers_1.GeometryGenerationHelpers.normalizeVectorXY(vert, endVert, normalsLength);\n            }\n            if (i == 0) {\n                this.outerPerpLines.push(new THREE.Line3(vert, endVert));\n            }\n            else {\n                this.innerPerpLines.push(new THREE.Line3(vert, endVert));\n            }\n        } // END for\n    };\n    //   /**\n    //    *\n    //    * @param {Polygon} baseShape\n    //    * @param {Bounds} outlineBounds\n    //    * @param {THREE.Vertex3} outlineVert\n    //    * @param {number} sliceIndex\n    //    * @param {number} heightT A value between 0.0 and 1.0 (inclusive) to indicate the height position.\n    //    * @param {boolean} isBending\n    //    * @param {number=} bendAngle Must not be null, NaN or infinity if `isBending==true`\n    //    * @param {number=} arcRadius\n    //    * @param {boolean=} normalizePerpendiculars\n    //    * @param {number=} normalsLength\n    //    * @return { yMin: number, yMax : number }\n    //    */\n    //   __buildNormals(\n    //     outlineSegmentIndex: number,\n    //     baseShape: Polygon,\n    //     outlineBounds: Bounds,\n    //     outlineVert: Vertex, // THREE.Vector3?\n    //     perpendicularVert: Vertex,\n    //     heightT: number,\n    //     isBending: boolean,\n    //     bendAngle: number,\n    //     arcRadius: number,\n    //     normalizePerpendiculars: boolean,\n    //     normalsLength: number\n    //   ) {\n    //     // var outlineXPct = (outlineBounds.max.x - outlineVert.x) / outlineBounds.width;\n    //     // var halfIndices = [0, Math.floor(baseShape.vertices.length / 2)];\n    //     // for (var j = 0; j < halfIndices.length; j++) {\n    //     //   var i = halfIndices[j];\n    //     //   var shapeVert = baseShape.vertices[i];\n    //     //   if (isBending) {\n    //     //     var vert = new THREE.Vector3(shapeVert.x * outlineXPct, 0, shapeVert.y * outlineXPct);\n    //     //     this._bendVertex(vert, bendAngle, arcRadius, heightT);\n    //     //     vert.y += outlineBounds.max.y;\n    //     //   } else {\n    //     //     var vert = new THREE.Vector3(shapeVert.x * outlineXPct, outlineVert.y, shapeVert.y * outlineXPct);\n    //     //   }\n    //     //   var perpDifference = new THREE.Vector3(outlineVert.x - perpendicularVert.x, outlineVert.y - perpendicularVert.y, 0);\n    //     //   if (i == 0) var endVert = new THREE.Vector3(vert.x - perpendicularVert.x, vert.y + perpendicularVert.y, 0);\n    //     //   else var endVert = new THREE.Vector3(vert.x + perpendicularVert.x, vert.y + perpendicularVert.y, 0);\n    //     //   rotateVert(endVert, bendAngle * heightT, vert.x, vert.y);\n    //     //   var outerPerpVert = vert.clone();\n    //     //   outerPerpVert.x += perpDifference.x;\n    //     //   outerPerpVert.y += perpDifference.y;\n    //     //   outerPerpVert.z += perpDifference.z;\n    //     //   if (normalizePerpendiculars) {\n    //     //     normalizeVectorXY(vert, endVert, normalsLength);\n    //     //   }\n    //     //   if (i == 0) {\n    //     //     this.outerPerpLines.push(new THREE.Line3(vert, endVert));\n    //     //   } else {\n    //     //     this.innerPerpLines.push(new THREE.Line3(vert, endVert));\n    //     //   }\n    //     // } // END for\n    //     var outlineXPct = (outlineBounds.max.x - outlineVert.x) / outlineBounds.width;\n    //     var halfIndices = [0, Math.floor(baseShape.vertices.length / 2)];\n    //     // Just append? Should be growing from 0 to n-1\n    //     this.dildoNormals[outlineSegmentIndex] = [];\n    //     // for (var j = 0; j < halfIndices.length; j++) {\n    //     console.log(\"baseShape.vertices.length\", baseShape.vertices.length);\n    //     for (var i = 0; i < baseShape.vertices.length; i++) {\n    //       //   var i = halfIndices[j];\n    //       var shapeVert = baseShape.vertices[i];\n    //       var perpDifference = new THREE.Vector3(outlineVert.x - perpendicularVert.x, outlineVert.y - perpendicularVert.y, 0);\n    //       normalizeVectorXY(outlineVert, perpDifference, normalsLength);\n    //       rotateVertY(perpDifference, bendAngle * heightT, vert.x, vert.y);\n    //       if (i == 0) {\n    //         console.log(\"perpDifference\", perpDifference);\n    //       }\n    //       if (isBending) {\n    //         var vert = new THREE.Vector3(shapeVert.x * outlineXPct, 0, shapeVert.y * outlineXPct);\n    //         // vert.add(new THREE.Vector3(perpDifference.x, 0, perpDifference.y));\n    //         // vert.sub(perpDifference);\n    //         this._bendVertex(vert, bendAngle, arcRadius, heightT);\n    //         vert.y += outlineBounds.max.y;\n    //       } else {\n    //         var vert = new THREE.Vector3(shapeVert.x * outlineXPct, outlineVert.y, shapeVert.y * outlineXPct);\n    //         // vert.add(new THREE.Vector3(perpDifference.x, perpDifference.y, 0));\n    //         // vert.sub(perpDifference);\n    //       }\n    //       //   var perpDifference = new THREE.Vector3(outlineVert.x - perpendicularVert.x, outlineVert.y - perpendicularVert.y, 0);\n    //       // TODO: check (this is in both cases the same)\n    //       //   if (i == 0) var endVert = new THREE.Vector3(vert.x - perpendicularVert.x, vert.y + perpendicularVert.y, vert.z);\n    //       //   //0);\n    //       //   else var endVert = new THREE.Vector3(vert.x + perpendicularVert.x, vert.y + perpendicularVert.y, vert.z); // 0);\n    //       // var endVert = new THREE.Vector3(vert.x + perpendicularVert.x, vert.y + perpendicularVert.y, vert.z);\n    //       //   rotateVert(endVert, bendAngle * heightT, vert.x, vert.y);\n    //       var outerPerpVert = vert.clone();\n    //       outerPerpVert.x += perpDifference.x;\n    //       outerPerpVert.y += perpDifference.y;\n    //       outerPerpVert.z += perpDifference.z;\n    //       // TODO: re-check\n    //       if (true || normalizePerpendiculars) {\n    //         // normalizeVectorXY(vert, endVert, normalsLength);\n    //         // normalizeVectorXYZ(vert, endVert, normalsLength);\n    //       }\n    //       // Add to cut lines?\n    //       //   if (i == 0) {\n    //       //     this.outerPerpLines.push(new THREE.Line3(vert, endVert));\n    //       //   } else if (i == halfIndices[1]) {\n    //       //     this.innerPerpLines.push(new THREE.Line3(vert, endVert));\n    //       //   }\n    //       // Add to regular normals\n    //       this.dildoNormals[outlineSegmentIndex].push(vert);\n    //       if (i == 0) {\n    //         // console.log(\"endVert\", outerPerpVert);\n    //       }\n    //     } // END for\n    //   }\n    /**\n     * Pre: perpLines are already built.\n     *\n     * Note: the last indices in the array will show to the point equivalent to the bottom point.\n     *\n     * @param {*} options\n     */\n    DildoGeometry.prototype.__makeFlatSideVertices = function (shapeRadius) {\n        // We are using the earcut algorithm later\n        //  + create an outline of the perpendicular end points\n        //  + shift the outline to the left bound of the mesh\n        //  + [LATER] run earcut\n        //  + [LATER] add all triangle faces\n        //  + [LATER] create a copy of the vertices and the triangulation the the right side\n        // Step 1: serialize the 2d vertex data along the perpendicular path\n        // var polygon = new Polygon(this.getPerpendicularPathVertices(true), false);\n        this.flatSidePolygon = new plotboilerplate_1.Polygon(this.getPerpendicularPathVertices(true), false);\n        this.flatSideBounds = this.flatSidePolygon.getBounds();\n        // Step 2: Add the 3d vertices to this geometry (and store positions in left-/rightFlatIndices array)\n        for (var i = 0; i < this.flatSidePolygon.vertices.length; i++) {\n            var nextIndex = this.vertices.length;\n            this.leftFlatIndices.push(nextIndex);\n            this.vertices.push(new THREE.Vector3(this.flatSidePolygon.vertices[i].x, this.flatSidePolygon.vertices[i].y, shapeRadius));\n            if (i === 0 || i + 1 === this.flatSidePolygon.vertices.length || i + 2 === this.flatSidePolygon.vertices.length) {\n                // Keep track of the four corner points (two left, two right)\n                this.hollowBottomEdgeVertIndices.push(nextIndex);\n            }\n        }\n        for (var i = 0; i < this.flatSidePolygon.vertices.length; i++) {\n            var nextIndex = this.vertices.length;\n            this.rightFlatIndices.push(nextIndex);\n            this.vertices.push(new THREE.Vector3(this.flatSidePolygon.vertices[i].x, this.flatSidePolygon.vertices[i].y, -shapeRadius));\n            if (i === 0 || i + 1 === this.flatSidePolygon.vertices.length || i + 2 === this.flatSidePolygon.vertices.length) {\n                // Keep track of the four corner points (two left, two right)\n                this.hollowBottomEdgeVertIndices.push(nextIndex);\n            }\n        }\n    };\n    /**\n     * Pre: perpLines are already built.\n     *\n     * Note: the last indices in the array will show to the point equivalent to the bottom point.\n     *\n     * @param {*}\n     */\n    DildoGeometry.prototype.__makeFlatSideFaces = function () {\n        // We are using the earcut algorithm here\n        //  + [DONE before] create an outline of the perpendicular end points\n        //  + [DONE before] shift the outline to the left bound of the mesh\n        //  + run earcut\n        //  + add all triangle faces\n        //  + create a copy of the vertices and the triangulation the the right side\n        var _self = this;\n        // Array<THREE.Vector3>  (compatible with XYCoords :)\n        var polygonVertices = this.leftFlatIndices.map(function (flatSideIndex) {\n            return _self.vertices[flatSideIndex];\n        });\n        var polygonData = GeometryGenerationHelpers_1.GeometryGenerationHelpers.flattenVert2dArray(polygonVertices);\n        // Step 3: run Earcut\n        var triangleIndices = (0, earcut_typescript_1.earcut)(polygonData);\n        // Step 4: process the earcut result;\n        //         add the retrieved triangles as geometry faces.\n        for (var i = 0; i + 2 < triangleIndices.length; i += 3) {\n            var a = triangleIndices[i];\n            var b = triangleIndices[i + 1];\n            var c = triangleIndices[i + 2];\n            GeometryGenerationHelpers_1.GeometryGenerationHelpers.makeFace3(this, this.leftFlatIndices[a], this.leftFlatIndices[b], this.leftFlatIndices[c]);\n            this.leftFlatTriangleIndices.push([this.leftFlatIndices[a], this.leftFlatIndices[b], this.leftFlatIndices[c]]);\n        }\n        for (var i = 0; i + 2 < triangleIndices.length; i += 3) {\n            var a = triangleIndices[i];\n            var b = triangleIndices[i + 1];\n            var c = triangleIndices[i + 2];\n            GeometryGenerationHelpers_1.GeometryGenerationHelpers.makeFace3(this, this.rightFlatIndices[a], this.rightFlatIndices[c], this.rightFlatIndices[b]);\n            this.rightFlatTriangleIndices.push([this.rightFlatIndices[a], this.rightFlatIndices[b], this.rightFlatIndices[c]]);\n        }\n    };\n    DildoGeometry.prototype.getPerpendicularPathVertices = function (includeBottomVert, getInner) {\n        // Array<XYCoords>\n        var polygonVertices = [];\n        for (var i = 0; i < this.innerPerpLines.length; i++) {\n            polygonVertices.push(getInner ? this.innerPerpLines[i].start : this.innerPerpLines[i].end);\n        }\n        // Reverse the outer path segment (both begin at bottom and meet at the top)\n        for (var i = this.outerPerpLines.length - 1; i >= 0; i--) {\n            polygonVertices.push(getInner ? this.outerPerpLines[i].start : this.outerPerpLines[i].end);\n        }\n        // Also add base point at last index\n        if (includeBottomVert) {\n            polygonVertices.push(this.vertices[this.bottomIndex]);\n        }\n        return polygonVertices;\n    };\n    DildoGeometry.prototype.getPerpendicularHullLines = function () {\n        // Array<XYCoords>\n        var perpLines = [];\n        for (var i = 0; i < this.innerPerpLines.length; i++) {\n            perpLines.push(this.innerPerpLines[i]);\n        }\n        // Reverse the outer path segment (both begin at bottom and meet at the top)\n        for (var i = this.outerPerpLines.length - 1; i >= 0; i--) {\n            perpLines.push(this.outerPerpLines[i]);\n        }\n        return perpLines;\n    };\n    /**\n     * Construct the top vertex that's used to closed the cylinder geometry at the top.\n     *\n     * @param {plotboilerplate.Bounds} outlineBounds\n     * @param {boolean} isBending\n     * @param {number|NaN|undefined} bendAngle\n     * @param {number|undefined} arcRadius\n     * @returns THREE.Vector\n     */\n    DildoGeometry.prototype._getTopVertex = function (outlineBounds, isBending, bendAngle, arcRadius) {\n        if (isBending) {\n            var topPoint = new THREE.Vector3(0, 0, 0);\n            this._bendVertex(topPoint, bendAngle, arcRadius, 1.0);\n            topPoint.y += outlineBounds.max.y;\n            return topPoint;\n        }\n        else {\n            return new THREE.Vector3(0, outlineBounds.min.y, 0);\n        }\n    };\n    /**\n     * Construct the bottom vertex that's used to closed the cylinder geometry at the bottom.\n     *\n     * @param {plotboilerplate.Bounds} outlineBounds\n     * @param {boolean} isBending\n     * @returns THREE.Vector\n     */\n    DildoGeometry.prototype._getBottomVertex = function (outlineBounds) {\n        var bottomPoint = new THREE.Vector3(0, outlineBounds.max.y, 0);\n        // if (isBending) {\n        // No need to bend the bottom point (no effect)\n        // this._bendVertex(bottomPoint, bendAngle, arcRadius, 0.0);\n        // }\n        return bottomPoint;\n    };\n    /**\n     * A helper function to 'bend' a vertex position around the desired bend axis (angle + radius).\n     * @private\n     * @param {} vert\n     * @param {*} bendAngle\n     * @param {*} arcRadius\n     * @param {*} heightT\n     */\n    DildoGeometry.prototype._bendVertex = function (vert, bendAngle, arcRadius, heightT) {\n        var axis = new THREE.Vector3(0, 0, 1);\n        var angle = bendAngle * heightT;\n        // Move slice point along radius, rotate, then move back\n        // (equivalent to rotation around arc center)\n        vert.x -= arcRadius;\n        vert.applyAxisAngle(axis, angle);\n        vert.x += arcRadius;\n    };\n    /**\n     * Rotate a 3d vector around the z axis (back-front-axis).\n     *\n     * @param {THREE.Vector3} vert\n     * @param {THREE.Vector3} angle\n     * @param {number} xCenter\n     * @param {number} yCenter\n     * @returns\n     */\n    //   // TODO: move to helpers\n    //   var rotateVert = function (vert, angle, xCenter, yCenter) {\n    //     var axis = new THREE.Vector3(0, 0, 1);\n    //     vert.x -= xCenter;\n    //     vert.y -= yCenter;\n    //     vert.applyAxisAngle(axis, angle);\n    //     vert.x += xCenter;\n    //     vert.y += yCenter;\n    //     return vert;\n    //   };\n    //   /**\n    //    * Rotate a 3d vector around the y axis (up-down-axis).\n    //    *\n    //    * @param {THREE.Vector3} vert\n    //    * @param {THREE.Vector3} angle\n    //    * @param {number} xCenter\n    //    * @param {number} zCenter\n    //    * @returns\n    //    */\n    //   // TODO: move to helpers\n    //   var rotateVertY = function (vert, angle, xCenter, zCenter) {\n    //     var axis = new THREE.Vector3(0, 1, 0);\n    //     vert.x -= xCenter;\n    //     vert.z -= zCenter;\n    //     vert.applyAxisAngle(axis, angle);\n    //     vert.x += xCenter;\n    //     vert.z += zCenter;\n    //     return vert;\n    //   };\n    //   /**\n    //    * Normalize a 2D vector to a given length.\n    //    *\n    //    * @param {XYCoords} base - The start point.\n    //    * @param {XYCoords} extend - The end point.\n    //    * @param {number} normalLength - The desired length\n    //    */\n    //   var normalizeVectorXY = function (base, extend, normalLength) {\n    //     var diff = { x: extend.x - base.x, y: extend.y - base.y }; // XYCoords\n    //     var length = Math.sqrt(diff.x * diff.x + diff.y * diff.y);\n    //     var ratio = normalLength / length;\n    //     extend.x = base.x + diff.x * ratio;\n    //     extend.y = base.y + diff.y * ratio;\n    //   };\n    // computeVertexNormals() {\n    //   for( var f = 0; f < this.faces.length; f++ ) {\n    //       var face = this.faces[f];\n    //   }\n    // }\n    // TODO\n    DildoGeometry.prototype.applyBumpMap = function (bumpMapTexture) {\n        // Build normals\n        for (var i = 0; i < this.vertexMatrix.length; i++) {\n            for (var j = 0; j < this.vertexMatrix[i].length; j++) {\n                var vertIndex = this.vertexMatrix[i][j];\n                var vertex = this.vertices[vertIndex];\n            }\n        }\n    };\n    /**\n     * Build up the faces for this geometry.\n     * @param {*} options\n     */\n    // DildoGeometry.prototype._buildFaces = function (options) {\n    DildoGeometry.prototype._buildFaces = function (options) {\n        var baseShape = options.baseShape;\n        var outlineSegmentCount = options.outlineSegmentCount;\n        var closeTop = Boolean(options.closeTop);\n        var closeBottom = Boolean(options.closeBottom);\n        var makeHollow = Boolean(options.makeHollow);\n        var baseShapeSegmentCount = baseShape.vertices.length;\n        this.faceVertexUvs[0] = [];\n        for (var s = 0; s < outlineSegmentCount; s++) {\n            for (var i = 0; i < baseShapeSegmentCount; i++) {\n                if (s > 0) {\n                    if (i > 0) {\n                        this.addFace4ByIndices(s, i - 1, s - 1, i, makeHollow);\n                        if (i + 1 == baseShape.vertices.length) {\n                            // Close the gap on the shape\n                            this.addFace4ByIndices(s, i, s - 1, 0, makeHollow);\n                        }\n                    }\n                }\n            } // END for\n        } // END for\n        if (makeHollow) {\n            this.__makeFlatSideFaces();\n            this.__makeBackFrontFaces();\n        }\n        if (closeBottom) {\n            if (makeHollow)\n                this._buildHollowBottomFaces();\n            else\n                this._buildEndFaces(this.bottomIndex, 0, baseShapeSegmentCount, false);\n        }\n        if (closeTop) {\n            this._buildEndFaces(this.topIndex, this.vertexMatrix.length - 1, baseShapeSegmentCount, makeHollow);\n        }\n    };\n    DildoGeometry.prototype._buildHollowBottomFaces = function () {\n        var _self = this;\n        var edgeVertices = this.hollowBottomEdgeVertIndices.map(function (edgeVertIndex) {\n            return _self.vertices[edgeVertIndex];\n        });\n        var findClosestEdgeIndex = function (vert) {\n            // THREE.Vector\n            var index = 0;\n            var distance = Number.MAX_VALUE;\n            var tmpDist;\n            for (var i = 0; i < edgeVertices.length; i++) {\n                var tmpIndex = _self.hollowBottomEdgeVertIndices[i];\n                if ((tmpDist = edgeVertices[i].distanceTo(vert)) < distance) {\n                    index = tmpIndex;\n                    distance = tmpDist;\n                }\n            }\n            return index;\n        };\n        // 'Last index' starts at last point at all : )\n        var n = this.vertexMatrix[0].length;\n        var lastIndex = findClosestEdgeIndex(this.vertices[n - 1]);\n        var triangleIndices; // = []; // [number,number,number]\n        // Use first slice (at bottom position)\n        for (var i = 0; i < n; i++) {\n            var curIndex = findClosestEdgeIndex(this.vertices[this.vertexMatrix[0][i]]);\n            // Close gap to last (different shell index)\n            triangleIndices = [lastIndex, this.vertexMatrix[0][i == 0 ? n - 1 : i - 1], this.vertexMatrix[0][i]];\n            this.faces.push(new THREE.Face3(triangleIndices[0], triangleIndices[1], triangleIndices[2])); // Same?\n            this.hollowBottomTriagles.push(triangleIndices);\n            if (lastIndex !== curIndex) {\n                // Add normal triangle to same shell index\n                triangleIndices = [curIndex, lastIndex, this.vertexMatrix[0][i]];\n                this.faces.push(new THREE.Face3(triangleIndices[0], triangleIndices[1], triangleIndices[2]));\n                this.hollowBottomTriagles.push(triangleIndices);\n            }\n            lastIndex = curIndex;\n        }\n    };\n    /**\n     * Build the face and the top or bottom end of the geometry. Imagine the dildo geometry\n     * as a closed cylinder: this function created the top or the bottom 'circle'.\n     *\n     * @param {number} endVertexIndex - This should be `this.topIndex` or `this.bottomIndex`.\n     * @param {number} shapeIndex - This should be `0` (top) or `outlineSegmentCount-1` (bottom).\n     * @param {number} baseShapeSegmentCount - The number of shape segments.\n     * @param {boolean=false} inverseFaceDirection - If true then the face will have left winding order (instead of right which is the default).\n     */\n    DildoGeometry.prototype._buildEndFaces = function (endVertexIndex, shapeIndex, baseShapeSegmentCount, inverseFaceDirection) {\n        // Close at top.\n        for (var i = 1; i < baseShapeSegmentCount; i++) {\n            GeometryGenerationHelpers_1.GeometryGenerationHelpers.makeFace3(this, this.vertexMatrix[shapeIndex][i - 1], endVertexIndex, this.vertexMatrix[shapeIndex][i], inverseFaceDirection);\n            if (i + 1 == baseShapeSegmentCount) {\n                GeometryGenerationHelpers_1.GeometryGenerationHelpers.makeFace3(this, this.vertexMatrix[shapeIndex][i], endVertexIndex, this.vertexMatrix[shapeIndex][0], inverseFaceDirection);\n            }\n        }\n    };\n    /**\n     * Pre: flatSides are made\n     *\n     * @param {*} options\n     */\n    DildoGeometry.prototype.__makeBackFrontFaces = function () {\n        // Connect left and right side (important: ignore bottom vertex at last index)\n        for (var i = 1; i + 1 < this.flatSidePolygon.vertices.length; i++) {\n            GeometryGenerationHelpers_1.GeometryGenerationHelpers.makeFace4(this, this.leftFlatIndices[i], this.leftFlatIndices[i - 1], this.rightFlatIndices[i], this.rightFlatIndices[i - 1]);\n        }\n    };\n    /**\n     * Build the texture UV mapping for all faces.\n     *\n     * @param {Polygon} options.baseShape\n     * @param {number} options.outlineSegmentCount\n     * @param {number} options.vertices.length\n     */\n    // DildoGeometry.prototype._buildUVMapping = function (options) {\n    DildoGeometry.prototype._buildUVMapping = function (options) {\n        var baseShape = options.baseShape;\n        var outlineSegmentCount = options.outlineSegmentCount;\n        var baseShapeSegmentCount = baseShape.vertices.length;\n        var closeTop = Boolean(options.closeTop);\n        var closeBottom = Boolean(options.closeBottom);\n        var makeHollow = Boolean(options.makeHollow);\n        // https://stackoverflow.com/questions/20774648/three-js-generate-uv-coordinate\n        for (var s = 1; s < outlineSegmentCount; s++) {\n            for (var i = 1; i < baseShape.vertices.length; i++) {\n                GeometryGenerationHelpers_1.GeometryGenerationHelpers.addCylindricUV4(this, s, i - 1, s - 1, i, outlineSegmentCount, baseShapeSegmentCount, makeHollow);\n                if (i + 1 == baseShape.vertices.length) {\n                    // Close the gap on the shape\n                    GeometryGenerationHelpers_1.GeometryGenerationHelpers.addCylindricUV4(this, s, i - 1, s - 1, i, outlineSegmentCount, baseShapeSegmentCount, makeHollow);\n                }\n            }\n        }\n        if (makeHollow) {\n            // Make flat side UVS (left)\n            // Note: left flat side and right flat side have the same number of polygon vertices\n            for (var i = 0; i < this.leftFlatTriangleIndices.length; i++) {\n                var leftA = this.leftFlatTriangleIndices[i][0];\n                var leftB = this.leftFlatTriangleIndices[i][1];\n                var leftC = this.leftFlatTriangleIndices[i][2];\n                UVHelpers_1.UVHelpers.makeFlatTriangleUVs(this, this.flatSideBounds, leftA, leftB, leftC);\n            }\n            // Make flat side UVS (right)\n            for (var i = 0; i < this.rightFlatTriangleIndices.length; i++) {\n                // NOTE: as the triangles are computed on the left flat side -> for the right side\n                //          change the winding order!!!\n                var rightA = this.rightFlatTriangleIndices[i][0];\n                var rightB = this.rightFlatTriangleIndices[i][2];\n                var rightC = this.rightFlatTriangleIndices[i][1];\n                UVHelpers_1.UVHelpers.makeFlatTriangleUVs(this, this.flatSideBounds, rightA, rightB, rightC);\n            }\n            // TODO: add these as function\n            for (var i = 1; i + 1 < this.flatSidePolygon.vertices.length; i++) {\n                var ratioI = (i - 1) / (this.flatSidePolygon.vertices.length - 1);\n                var ratioJ = i / (this.flatSidePolygon.vertices.length - 1);\n                this.faceVertexUvs[0].push([\n                    new THREE.Vector2(0.0, ratioJ),\n                    new THREE.Vector2(0.0, ratioI),\n                    new THREE.Vector2(1.0, ratioJ)\n                ]);\n                this.faceVertexUvs[0].push([\n                    new THREE.Vector2(0.0, ratioI),\n                    new THREE.Vector2(1.0, ratioI),\n                    new THREE.Vector2(1.0, ratioJ)\n                ]);\n            }\n        } // END if[makeHollow]\n        // Build UV mapping for the bottom (base)\n        if (closeBottom) {\n            if (makeHollow) {\n                makeHollowBottomUVs(this, this.hollowBottomEdgeVertIndices, this.hollowBottomTriagles);\n            }\n            else {\n                for (var i = 1; i < baseShapeSegmentCount; i++) {\n                    GeometryGenerationHelpers_1.GeometryGenerationHelpers.addPyramidalBaseUV3(this, i - 1, baseShapeSegmentCount);\n                    if (i + 1 == baseShapeSegmentCount) {\n                        // Close the gap on the shape\n                        GeometryGenerationHelpers_1.GeometryGenerationHelpers.addPyramidalBaseUV3(this, i - 1, baseShapeSegmentCount);\n                    }\n                }\n            }\n        }\n        // Build UV mapping for the top (closing element)\n        if (closeTop) {\n            var lastIndex = outlineSegmentCount - 1;\n            for (var i = 1; i < baseShapeSegmentCount; i++) {\n                GeometryGenerationHelpers_1.GeometryGenerationHelpers.addPyramidalBaseUV3(this, i - 1, baseShapeSegmentCount);\n                if (i + 1 == baseShapeSegmentCount) {\n                    // Close the gap on the shape\n                    GeometryGenerationHelpers_1.GeometryGenerationHelpers.addPyramidalBaseUV3(this, lastIndex, baseShapeSegmentCount);\n                }\n            }\n        }\n        this.uvsNeedUpdate = true;\n    };\n    /**\n     * Build a triangulated face4 (two face3) for the given matrix index pairs. The method will create\n     * two right-turning triangles.\n     *\n     * <pre>\n     *       (a,b)---(c,b)\n     *         |    /  |\n     *         |   /   |\n     *         |  /    |\n     *       (a,d)---(c,d)\n     * </pre>\n     *\n     * @param {number} a - The first primary index in the `vertexMatrix` array.\n     * @param {number} b - The first seconday index in the `vertexMatrix[a]` array.\n     * @param {number} c - The second primary index in the `vertexMatrix` array.\n     * @param {number} d - The second seconday index in the `vertexMatrix[c]` array.\n     * @param {boolean=false} inverseFaceDirection - If true then the face will have left winding order (instead of right which is the default).\n     */\n    DildoGeometry.prototype.addFace4ByIndices = function (a, b, c, d, inverseFaceDirection) {\n        GeometryGenerationHelpers_1.GeometryGenerationHelpers.makeFace4(this, this.vertexMatrix[a][b], this.vertexMatrix[c][b], this.vertexMatrix[a][d], this.vertexMatrix[c][d], inverseFaceDirection);\n    };\n    /**\n     * Build up the vertices in this geometry.\n     *\n     * @param {} options\n     */\n    DildoGeometry.prototype._buildVertices = function (options) {\n        var baseShape = options.baseShape;\n        var outline = options.outline;\n        var outlineSegmentCount = options.outlineSegmentCount;\n        var makeHollow = Boolean(options.makeHollow);\n        var bendAngleRad = (options.bendAngle / 180) * Math.PI;\n        var hollowStrengthX = options.hollowStrengthX; // default=15.0? // TODO: hollow strength as param\n        var twistAngle = options.twistAngle * DEG_TO_RAD;\n        var normalizePerpendiculars = Boolean(options.normalizePerpendiculars);\n        var normalsLength = typeof options.normalsLength !== \"undefined\" ? options.normalsLength : 10.0;\n        var outlineBounds = outline.getBounds();\n        var shapeHeight = outlineBounds.height;\n        var shapeBounds = baseShape.getBounds();\n        var shapeCenter = shapeBounds.getCenter();\n        var arcLength = shapeHeight;\n        var arcRadius = arcLength / bendAngleRad;\n        var isBending = options.isBending &&\n            !isNaN(arcRadius) &&\n            arcRadius !== Number.POSITIVE_INFINITY &&\n            arcRadius !== Number.NEGATIVE_INFINITY &&\n            Math.abs(bendAngleRad) > 0.01;\n        for (var s = 0; s < outlineSegmentCount; s++) {\n            var t = Math.min(1.0, Math.max(0.0, s / (outlineSegmentCount - 1)));\n            this.vertexMatrix[s] = [];\n            var outlineVert = outline.getPointAt(t);\n            var perpendicularVert = outline.getPerpendicularAt(t);\n            var heightT = (outlineBounds.max.y - outlineVert.y) / shapeHeight;\n            var outlineT = s / (outlineSegmentCount - 1);\n            this.__buildSlice(baseShape, outlineBounds, outlineVert, s, heightT, isBending, bendAngleRad, arcRadius, twistAngle * outlineT);\n            this.__buildSpine(shapeCenter, outlineBounds, outlineVert, heightT, isBending, bendAngleRad, arcRadius);\n            this.__buildPerps(baseShape, outlineBounds, outlineVert, perpendicularVert, heightT, isBending, bendAngleRad, arcRadius, normalizePerpendiculars, normalsLength);\n            // this.__buildNormals(\n            //   s,\n            //   baseShape,\n            //   outlineBounds,\n            //   outlineVert,\n            //   perpendicularVert,\n            //   heightT,\n            //   isBending,\n            //   bendAngleRad,\n            //   arcRadius,\n            //   normalizePerpendiculars,\n            //   normalsLength\n            // );\n        } // END for\n        var topVertex = this._getTopVertex(outlineBounds, isBending, bendAngleRad, arcRadius);\n        var bottomVertex = this._getBottomVertex(outlineBounds);\n        this.topIndex = this.vertices.length;\n        this.vertices.push(topVertex);\n        this.bottomIndex = this.vertices.length;\n        this.vertices.push(bottomVertex);\n        if (makeHollow) {\n            // Construct the left and the right flat bounds (used to make a casting mould)\n            this.__makeFlatSideVertices(Math.max(shapeBounds.width, shapeBounds.height) / 2.0 + hollowStrengthX);\n        }\n    };\n    DildoGeometry.prototype.__applyBumpmap = function (bumpmapTexture) {\n        var tmp = this;\n        for (var i = 0; i < this.vertexMatrix.length; i++) {\n            for (var j = 0; j < this.vertexMatrix[i].length; j++) {\n                // apply local bump map\n                // const normal = tmp.\n            }\n        }\n    };\n    return DildoGeometry;\n}(DildoBaseClass)); // END class\nexports.DildoGeometry = DildoGeometry;\n// TODO: move to helpers\nvar rotateVert = function (vert, angle, xCenter, yCenter) {\n    var axis = new THREE.Vector3(0, 0, 1);\n    vert.x -= xCenter;\n    vert.y -= yCenter;\n    vert.applyAxisAngle(axis, angle);\n    vert.x += xCenter;\n    vert.y += yCenter;\n    return vert;\n};\n/**\n * Rotate a 3d vector around the y axis (up-down-axis).\n *\n * @param {THREE.Vector3} vert\n * @param {THREE.Vector3} angle\n * @param {number} xCenter\n * @param {number} zCenter\n * @returns\n */\n// TODO: move to helpers\nvar rotateVertY = function (vert, angle, xCenter, zCenter) {\n    var axis = new THREE.Vector3(0, 1, 0);\n    vert.x -= xCenter;\n    vert.z -= zCenter;\n    vert.applyAxisAngle(axis, angle);\n    vert.x += xCenter;\n    vert.z += zCenter;\n    return vert;\n};\n// /**\n//  * Normalize a 2D vector to a given length.\n//  *\n//  * @param {XYCoords} base - The start point.\n//  * @param {XYCoords} extend - The end point.\n//  * @param {number} normalLength - The desired length\n//  */\n// // TODO: add types\n// var normalizeVectorXY = function (base, extend, normalLength) {\n//   var diff = { x: extend.x - base.x, y: extend.y - base.y }; // XYCoords\n//   var length = Math.sqrt(diff.x * diff.x + diff.y * diff.y);\n//   var ratio = normalLength / length;\n//   extend.x = base.x + diff.x * ratio;\n//   extend.y = base.y + diff.y * ratio;\n// };\n/**\n * Normalize a 2D vector to a given length.\n *\n * @param {THREE.Vector3} base - The start point.\n * @param {THREE.Vector3} extend - The end point.\n * @param {number} normalLength - The desired length\n */\n// TOTO: add types\nvar normalizeVectorXYZ = function (base, extend, normalLength) {\n    var diff = { x: extend.x - base.x, y: extend.y - base.y, z: extend.z - base.z };\n    var length = Math.sqrt(diff.x * diff.x + diff.y * diff.y + diff.z * diff.z);\n    var ratio = normalLength / length;\n    extend.x = base.x + diff.x * ratio;\n    extend.y = base.y + diff.y * ratio;\n    extend.z = base.z + diff.z * ratio;\n};\n/**\n *\n * @param {THREE.Geometry} thisGeometry\n * @param {Array<number>} containingPolygonIndices\n * @param {Array<[number,number,number]>} triangles\n */\nvar makeHollowBottomUVs = function (thisGeometry, containingPolygonIndices, triangles) {\n    // Compute polyon bounds\n    var polygonBounds = plotboilerplate_1.Bounds.computeFromVertices(containingPolygonIndices.map(function (vertIndex) {\n        return new plotboilerplate_1.Vertex(thisGeometry.vertices[vertIndex].x, thisGeometry.vertices[vertIndex].z);\n    }));\n    var getUVRatios = function (vert) {\n        // console.log((vert.x - shapeBounds.min.x) / shapeBounds.width, (vert.y - shapeBounds.min.y) / shapeBounds.height);\n        return new THREE.Vector2((vert.x - polygonBounds.min.x) / polygonBounds.width, (vert.z - polygonBounds.min.y) / polygonBounds.height);\n    };\n    // ON the x-z-plane {x, *, z}\n    for (var t = 0; t < triangles.length; t++) {\n        var vertA = thisGeometry.vertices[triangles[t][0]];\n        var vertB = thisGeometry.vertices[triangles[t][1]];\n        var vertC = thisGeometry.vertices[triangles[t][2]];\n        thisGeometry.faceVertexUvs[0].push([getUVRatios(vertA), getUVRatios(vertB), getUVRatios(vertC)]);\n    }\n};\n//# sourceMappingURL=DildoGeometry.js.map","\"use strict\";\n/**\n * A collection of materials and material making functions.\n *\n * @require THREE\n *\n * @author Ikaros Kappler\n * @date 2021-07-02\n * @modified 2021-08-04 Ported to Typescript from vanilla JS.\n * @version 1.0.1\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.DildoMaterials = void 0;\nvar THREE = require(\"three\");\nexports.DildoMaterials = (function () {\n    /**\n     * Map<string,texture>\n     */\n    var textureStore = new Map();\n    var DildoMaterials = {\n        /**\n         * Create a new mesh material from the given parameters.\n         *\n         * @param {boolean} useTextureImage - Load and use the given texture (at `textureImagePath`) if set to true.\n         * @param {boolean} wireframe - Create a wireframe material if true.\n         * @param {string} textureImagePath - The texture path to use (if useTextureImage is set to true).\n         * @param {THREE.DoubleSide|THREE.FrontSide|THREE.Backside} doubleSingleSide - Wether to display one one or both face sides.\n         * @returns\n         */\n        createMainMaterial: function (useTextureImage, wireframe, textureImagePath, doubleSingleSide) {\n            return useTextureImage\n                ? new THREE.MeshLambertMaterial({\n                    color: 0xffffff,\n                    wireframe: wireframe,\n                    //   flatShading: false,\n                    depthTest: true,\n                    opacity: 1.0,\n                    // side: THREE.DoubleSide,\n                    side: doubleSingleSide,\n                    visible: true,\n                    emissive: 0x0,\n                    reflectivity: 1.0,\n                    refractionRatio: 0.89,\n                    map: DildoMaterials.loadTextureImage(textureImagePath)\n                })\n                : new THREE.MeshPhongMaterial({\n                    color: 0x3838ff,\n                    wireframe: wireframe,\n                    flatShading: false,\n                    depthTest: true,\n                    opacity: 1.0,\n                    // side: THREE.DoubleSide,\n                    side: doubleSingleSide,\n                    visible: true,\n                    emissive: 0x0,\n                    reflectivity: 1.0,\n                    refractionRatio: 0.89,\n                    map: null\n                });\n        },\n        createSliceMaterial: function (useTextureImage, wireframe, textureImagePath) {\n            if (wireframe) {\n                return new THREE.MeshBasicMaterial({ wireframe: true });\n                // return new THREE.MeshStandardMaterial({ wireframe: true });\n            }\n            else {\n                return new THREE.MeshLambertMaterial({\n                    color: useTextureImage ? 0x888888 : 0xa1848a8,\n                    wireframe: false,\n                    // flatShading: false,\n                    depthTest: true,\n                    opacity: 1.0,\n                    side: THREE.DoubleSide,\n                    // side: doubleSingleSide,\n                    visible: true,\n                    emissive: 0x0,\n                    reflectivity: 1.0,\n                    refractionRatio: 0.89,\n                    map: useTextureImage ? DildoMaterials.loadTextureImage(textureImagePath) : null,\n                    vertexColors: false\n                });\n            }\n        },\n        /**\n         * Load a texture or get it from the internal buffer if it was already loaded before.\n         *\n         * @param {string} path - The path (absolute or relative) to the texture image to load.\n         * @returns {THREE.Texture}\n         */\n        loadTextureImage: function (path) {\n            var texture = textureStore.get(path);\n            if (!texture) {\n                // TODO: use a singleton here?\n                var loader = new THREE.TextureLoader();\n                texture = loader.load(path);\n                textureStore.set(path, texture);\n            }\n            return texture;\n        }\n    };\n    return DildoMaterials;\n})();\n//# sourceMappingURL=DildoMaterials.js.map","\"use strict\";\n/**\n * A collection of helper function used to generate dildo meshes.\n *\n * @require sliceGeometry\n *\n * @author   Ikaros Kappler\n * @date     2021-06-30\n * @modified 2021-08-29 Ported to Typescript from vanilla JS.\n * @version  0.0.1-alpha\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.GeometryGenerationHelpers = void 0;\nvar THREE = require(\"three\");\n// import { earcut } from \"./thirdparty-ported/earcut\"; // TODO: fix earcut types, convert to custum library\nvar earcut_typescript_1 = require(\"earcut-typescript\");\nvar plotboilerplate_1 = require(\"plotboilerplate\");\nvar threejs_slice_geometry_1 = require(\"./thirdparty-ported/threejs-slice-geometry\"); // TODO: convert to custom library\nvar PlaneMeshIntersection_1 = require(\"./PlaneMeshIntersection\");\nvar clearDuplicateVertices3_1 = require(\"./clearDuplicateVertices3\");\nvar UVHelpers_1 = require(\"./UVHelpers\");\nvar constants_1 = require(\"./constants\");\nexports.GeometryGenerationHelpers = {\n    /**\n     * Create a (right-turning) triangle of the three vertices at index A, B and C.\n     *\n     * The default direction (right) can be changed to left to pass `invsereFaceDirection=true`.\n     *\n     * @param {THREE.Geometry} geometry - The geometry to add the face to.\n     * @param {number} vertIndexA\n     * @param {number} vertIndexB\n     * @param {number} vertIndexC\n     * @param {boolean=false} inverseFaceDirection - If true then the face will have left winding order (instead of right which is the default).\n     */\n    makeFace3: function (geometry, vertIndexA, vertIndexB, vertIndexC, inverseFaceDirection) {\n        if (inverseFaceDirection) {\n            geometry.faces.push(new THREE.Face3(vertIndexC, vertIndexB, vertIndexA));\n        }\n        else {\n            geometry.faces.push(new THREE.Face3(vertIndexA, vertIndexB, vertIndexC));\n        }\n    },\n    /**\n     * Build a triangulated face4 (two face3) for the given vertex indices. The method will create\n     * two right-turning triangles by default, or two left-turning triangles if `inverseFaceDirection`.\n     *\n     * <pre>\n     *         A-----B\n     *         |   / |\n     *         |  /  |\n     *         | /   |\n     *         C-----D\n     * </pre>\n     *\n     * @param {THREE.Geometry} geometry - The geometry to add the face to.\n     * @param {number} vertIndexA - The first vertex index.\n     * @param {number} vertIndexB - The second vertex index.\n     * @param {number} vertIndexC - The third vertex index.\n     * @param {number} vertIndexD - The fourth vertex index.\n     * @param {boolean=false} inverseFaceDirection - If true then the face will have left winding order (instead of right which is the default).\n     */\n    makeFace4: function (geometry, vertIndexA, vertIndexB, vertIndexC, vertIndexD, inverseFaceDirection) {\n        if (inverseFaceDirection) {\n            // Just inverse the winding order of both face3 elements\n            exports.GeometryGenerationHelpers.makeFace3(geometry, vertIndexA, vertIndexC, vertIndexB, false);\n            exports.GeometryGenerationHelpers.makeFace3(geometry, vertIndexC, vertIndexD, vertIndexB, false);\n        }\n        else {\n            exports.GeometryGenerationHelpers.makeFace3(geometry, vertIndexA, vertIndexB, vertIndexC, false);\n            exports.GeometryGenerationHelpers.makeFace3(geometry, vertIndexB, vertIndexD, vertIndexC, false);\n        }\n    },\n    /**\n     * Create texture UV coordinates for the rectangular two  triangles at matrix indices a, b, c and d.\n     *\n     * @param {THREE.Geometry} geometry - The geometry to add the face to.\n     * @param {number} a - The first face-4 vertex index.\n     * @param {number} b - The second face-4 vertex index.\n     * @param {number} c - The third face-4 vertex index.\n     * @param {number} d - The fourth face-4 vertex index.\n     * @param {number} outlineSegmentCount - The total number of segments on the outline.\n     * @param {number} baseShapeSegmentCount - The total number of segments on the base shape.\n     * @param {boolean=false} inverseFaceDirection - If true then the UV mapping is applied in left winding order (instead of right which is the default).\n     */\n    addCylindricUV4: function (geometry, a, b, c, d, outlineSegmentCount, baseShapeSegmentCount, inverseFaceDirection) {\n        if (inverseFaceDirection) {\n            // change: abc -> acb\n            // change: bdc -> cdb\n            geometry.faceVertexUvs[0].push([\n                new THREE.Vector2(a / outlineSegmentCount, b / baseShapeSegmentCount),\n                new THREE.Vector2(a / outlineSegmentCount, d / baseShapeSegmentCount),\n                new THREE.Vector2(c / outlineSegmentCount, b / baseShapeSegmentCount)\n            ]);\n            geometry.faceVertexUvs[0].push([\n                new THREE.Vector2(a / outlineSegmentCount, d / baseShapeSegmentCount),\n                new THREE.Vector2(c / outlineSegmentCount, d / baseShapeSegmentCount),\n                new THREE.Vector2(c / outlineSegmentCount, b / baseShapeSegmentCount)\n            ]);\n        }\n        else {\n            geometry.faceVertexUvs[0].push([\n                new THREE.Vector2(a / outlineSegmentCount, b / baseShapeSegmentCount),\n                new THREE.Vector2(c / outlineSegmentCount, b / baseShapeSegmentCount),\n                new THREE.Vector2(a / outlineSegmentCount, d / baseShapeSegmentCount)\n            ]);\n            geometry.faceVertexUvs[0].push([\n                new THREE.Vector2(c / outlineSegmentCount, b / baseShapeSegmentCount),\n                new THREE.Vector2(c / outlineSegmentCount, d / baseShapeSegmentCount),\n                new THREE.Vector2(a / outlineSegmentCount, d / baseShapeSegmentCount)\n            ]);\n        }\n    },\n    /**\n     * Create texture UV coordinates for the triangle at matrix indices a, b and c.\n     *\n     * @param {THREE.Geometry} geometry - The geometry to add the new faces to.\n     * @param {number} a - The current base shape segment index, must be inside [0,baseShapeSegmentCount-1].\n     * @param {number} baseShapeSegmentCount - The total number of base shape segments.\n     */\n    addPyramidalBaseUV3: function (geometry, a, baseShapeSegmentCount) {\n        // Create a mirrored texture to avoid hard visual cuts\n        var ratioA = 1.0 - Math.abs(0.5 - a / baseShapeSegmentCount) * 2;\n        var ratioB = 1.0 - Math.abs(0.5 - (a + 1) / baseShapeSegmentCount) * 2;\n        geometry.faceVertexUvs[0].push([new THREE.Vector2(ratioA, 0), new THREE.Vector2(0.5, 1), new THREE.Vector2(ratioB, 0)]);\n    },\n    /**\n     * Flatten an array of 2d vertices into a flat array of coordinates.\n     * (required by the earcut algorithm for example).\n     *\n     * @param {Array<XYCoords>} vertices2d\n     * @returns {Array<number>}\n     */\n    flattenVert2dArray: function (vertices2d) {\n        // Array<number>\n        var coordinates = [];\n        for (var i = 0; i < vertices2d.length; i++) {\n            coordinates.push(vertices2d[i].x, vertices2d[i].y);\n        }\n        return coordinates;\n    },\n    /**\n     * A helper function to create (discrete) circular 2d shapes.\n     *\n     * @param {number} radius - The radius of the circle.\n     * @param {number} pointCount - The number of vertices to construct the circle with.\n     * @param {number=1.0} excentricity - To create ellipses (default is 1.0).\n     * @returns {Polygon}\n     */\n    mkCircularPolygon: function (radius, pointCount, excentricity) {\n        if (typeof excentricity === \"undefined\") {\n            excentricity = 1.0;\n        }\n        var vertices = [];\n        var phi;\n        for (var i = 0; i < pointCount; i++) {\n            phi = Math.PI * 2 * (i / pointCount);\n            vertices.push(new plotboilerplate_1.Vertex(Math.cos(phi) * radius * excentricity, Math.sin(phi) * radius));\n        }\n        return new plotboilerplate_1.Polygon(vertices, false);\n    },\n    /**\n     * Slice a geometry at the given plane and add the remaining part(s).\n     *\n     * Note that only the right half (on the positive z axis) is kept. To obtain both you\n     * need to run the algorithm twice with two flipped planes.\n     *\n     * Note also that the mesh is open at the cut plane.\n     *\n     * @param {THREE.Geometry} unbufferedGeometry - The geometry to slice.\n     * @param {THREE.Plane} plane PlaneGeometry???\n     * @return {THREE.Geometry}\n     */\n    makeSlice: function (unbufferedGeometry, plane) {\n        // Slice mesh into two\n        // See https://github.com/tdhooper/threejs-slice-geometry\n        var closeHoles = false; // This might be configurable in a later version.\n        // TODO: cc\n        // var sliceMaterial = DildoMaterials.createSliceMaterial(wireframe);\n        // var slicedGeometry = sliceGeometry(unbufferedGeometry, plane, closeHoles);\n        var slicedGeometry = (0, threejs_slice_geometry_1.sliceGeometry)(unbufferedGeometry, plane, closeHoles);\n        // Now note that it's possible that the result might contain multiple vertices\n        // at the same position, which makes further calculations quite difficult.\n        // -> Merge multiple vertices into one\n        slicedGeometry.mergeVertices();\n        // And don't forget to compute the normals.\n        slicedGeometry.computeFaceNormals();\n        // var slicedMesh = new THREE.Mesh(slicedGeometry, sliceMaterial);\n        // var slicedMesh = new THREE.Mesh(new THREE.BufferGeometry().fromGeometry(slicedGeometry), sliceMaterial);\n        //   slicedMesh.position.y = -100;\n        //   slicedMesh.position.z = zOffset;\n        //   slicedMesh.userData[\"isExportable\"] = true;\n        //   thisGenerator.addMesh(slicedMesh);\n        return slicedGeometry;\n    },\n    /**\n     * This function creates the cut intersection elements to fill the (open) slice meshes.\n     *\n     * @param {DildoGeneration} thisGenerator\n     * @param {THREE.Mesh} mesh\n     * @param {IDildoGeometry} unbufferedGeometry\n     * @param {THREE.Plane} planeGeometry\n     * @returns\n     */\n    makeAndAddPlaneIntersection: function (thisGenerator, mesh, unbufferedGeometry, // THREE.Geometry,\n    planeGeometry, // THREE.Plane, // THREE.PlaneGeometry, // THREE.Plane ???\n    planeGeometryReal, \n    // TODO: use a proper global interface here\n    options // { showSplitShape?: boolean }\n    ) {\n        // Find the cut path\n        var planeMeshIntersection = new PlaneMeshIntersection_1.PlaneMeshIntersection();\n        // Array<THREE.Vector3>  (compatible with XYCoords :)\n        var intersectionPoints = planeMeshIntersection.getIntersectionPoints(mesh, unbufferedGeometry, planeGeometry, planeGeometryReal);\n        var EPS = 0.000001;\n        var uniqueIntersectionPoints = (0, clearDuplicateVertices3_1.clearDuplicateVertices3)(intersectionPoints, EPS);\n        var pointGeometry = new THREE.Geometry();\n        pointGeometry.vertices = uniqueIntersectionPoints;\n        var pointsMaterial = new THREE.PointsMaterial({\n            size: 1.4,\n            color: 0x00ffff\n        });\n        var pointsMesh = new THREE.Points(pointGeometry, pointsMaterial);\n        if (options.showSplitShape) {\n            pointsMesh.position.y = -100;\n            pointsMesh.position.z = -50;\n            thisGenerator.addMesh(pointsMesh);\n        }\n        // TODO: convert point set to path\n        // Test: make a triangulation to see what the path looks like\n        var polygonData = exports.GeometryGenerationHelpers.flattenVert2dArray(uniqueIntersectionPoints);\n        // Run Earcut\n        var triangleIndices = (0, earcut_typescript_1.earcut)(polygonData);\n        // Process the earcut result;\n        //         add the retrieved triangles as geometry faces.\n        var triangleGeometry = new THREE.Geometry();\n        for (var i = 0; i < uniqueIntersectionPoints.length; i++) {\n            triangleGeometry.vertices.push(uniqueIntersectionPoints[i].clone());\n        }\n        for (var i = 0; i + 2 < triangleIndices.length; i += 3) {\n            var a = triangleIndices[i];\n            var b = triangleIndices[i + 1];\n            var c = triangleIndices[i + 2];\n            exports.GeometryGenerationHelpers.makeFace3(triangleGeometry, a, b, c);\n        }\n        if (options.addRawIntersectionTriangleMesh) {\n            // This is more a quick experimental preview feature.\n            // The data is often faulty and too unprecise.\n            var triangleMesh = new THREE.Mesh(triangleGeometry, new THREE.LineBasicMaterial({\n                color: 0xff8800\n            }));\n            triangleMesh.position.y = -100;\n            triangleMesh.position.z = -50;\n            thisGenerator.addMesh(triangleMesh);\n        }\n        // Make the actual models\n        // CURRENTLY NOT IN USE. THE UNDERLYING MODEL IS A NON-TWISTED ONE.\n        if (options.addPrecalculatedMassiveFaces) {\n            exports.GeometryGenerationHelpers.makeAndAddMassivePlaneIntersection(thisGenerator, unbufferedGeometry);\n        }\n        if (options.addPrecalculatedHollowFaces) {\n            exports.GeometryGenerationHelpers.makeAndAddHollowPlaneIntersection(thisGenerator, unbufferedGeometry);\n        }\n        return uniqueIntersectionPoints;\n    },\n    // CURRENTLY NOT REALLY IN USE. THE UNDERLYING MODEL IS A NON-TWISTED ONE.\n    makeAndAddMassivePlaneIntersection: function (thisGenerator, unbufferedGeometry) {\n        var intersectionPoints = unbufferedGeometry.getPerpendicularPathVertices(true, true); // includeBottom=true, getInner=true\n        var pointGeometry = new THREE.Geometry();\n        pointGeometry.vertices = intersectionPoints;\n        var pointsMaterial = new THREE.MeshBasicMaterial({\n            wireframe: false,\n            color: 0xff0000,\n            opacity: 0.5,\n            side: THREE.DoubleSide,\n            transparent: true\n        });\n        // Array<number,number,number,...>\n        var polygonData = exports.GeometryGenerationHelpers.flattenVert2dArray(intersectionPoints);\n        // Step 3: run Earcut\n        var triangleIndices = (0, earcut_typescript_1.earcut)(polygonData);\n        // Step 4: process the earcut result;\n        //         add the retrieved triangles as geometry faces.\n        for (var i = 0; i + 2 < triangleIndices.length; i += 3) {\n            var a = triangleIndices[i];\n            var b = triangleIndices[i + 1];\n            var c = triangleIndices[i + 2];\n            exports.GeometryGenerationHelpers.makeFace3(pointGeometry, a, b, c);\n        }\n        var pointsMesh = new THREE.Mesh(pointGeometry, pointsMaterial);\n        pointsMesh.position.y = -100;\n        pointsMesh.position.z = 50;\n        pointsMesh.userData[\"isExportable\"] = false;\n        thisGenerator.addMesh(pointsMesh);\n    },\n    // CURRENTLY NOT REALLY IN USE. THE UNDERLYING MODEL IS A NON-TWISTED ONE.\n    makeAndAddHollowPlaneIntersection: function (thisGenerator, unbufferedGeometry) {\n        var pointGeometry = new THREE.Geometry();\n        var perpLines = unbufferedGeometry.getPerpendicularHullLines();\n        for (var i = 0; i < perpLines.length; i++) {\n            var innerPoint = perpLines[i].start;\n            var outerPoint = perpLines[i].end;\n            pointGeometry.vertices.push(innerPoint, outerPoint);\n            var vertIndex = pointGeometry.vertices.length;\n            if (i > 0) {\n                pointGeometry.faces.push(new THREE.Face3(vertIndex - 4, vertIndex - 2, vertIndex - 3));\n                pointGeometry.faces.push(new THREE.Face3(vertIndex - 3, vertIndex - 2, vertIndex - 1));\n            }\n        }\n        var pointsMaterial = new THREE.MeshBasicMaterial({\n            wireframe: false,\n            color: 0xff0000,\n            opacity: 0.5,\n            side: THREE.DoubleSide,\n            transparent: true\n        });\n        var pointsMesh = new THREE.Mesh(pointGeometry, pointsMaterial);\n        pointsMesh.position.y = -100;\n        pointsMesh.position.z = -50;\n        pointsMesh.userData[\"isExportable\"] = false;\n        thisGenerator.addMesh(pointsMesh);\n    },\n    /**\n     * Add an orange colored line mesh from a spine geometry..\n     *\n     * @param {DildoGeneration} thisGenerator - The generator to add the new mesh to.\n     * @param {THREE.Geometry} spineGeometry - The spine geometry itself.\n     */\n    addSpine: function (thisGenerator, spineGeometry) {\n        var spineMesh = new THREE.LineSegments(spineGeometry, new THREE.LineBasicMaterial({\n            color: 0xff8800\n        }));\n        spineMesh.position.y = -100;\n        thisGenerator.addMesh(spineMesh);\n    },\n    /**\n     * This function creates two line-meshes in red and green indicating the perpendicular cut\n     * path along the geometry to be sliced.\n     *\n     * @param {DildoGeneration} thisGenerator - The generator to add the new two meshes to.\n     * @param {DildoGeometry} unbufferedDildoGeometry - The dildo geometry to retrieve the perpendicular path from.\n     */\n    addPerpendicularPaths: function (thisGenerator, unbufferedDildoGeometry) {\n        exports.GeometryGenerationHelpers.addPerpendicularPath(thisGenerator, unbufferedDildoGeometry.outerPerpLines, 0xff0000);\n        exports.GeometryGenerationHelpers.addPerpendicularPath(thisGenerator, unbufferedDildoGeometry.innerPerpLines, 0x00ff00);\n    },\n    /**\n     * Add the given array of perpendicular lines (perpendicular to the mesh surface along the cut path)\n     * as a THREE.LineSegments geometry.\n     *\n     * @param {DildoGeneration} thisGenerator - The generator to add the created line mesh to.\n     * @param {Array<THREE.Line3>} perpLines - The lines to\n     * @param {number} materialColor - A color for the material to use (like 0xff0000 for red).\n     */\n    addPerpendicularPath: function (thisGenerator, perpLines, materialColor) {\n        var outerPerpGeometry = new THREE.Geometry();\n        perpLines.forEach(function (perpLine) {\n            outerPerpGeometry.vertices.push(perpLine.start.clone());\n            outerPerpGeometry.vertices.push(perpLine.end.clone());\n        });\n        var outerPerpMesh = new THREE.LineSegments(outerPerpGeometry, new THREE.LineBasicMaterial({\n            color: materialColor\n        }));\n        outerPerpMesh.position.y = -100;\n        thisGenerator.addMesh(outerPerpMesh);\n    },\n    // TODO: add to global helper functions\n    /**\n     * Make a triangulation of the given path specified by the verted indices.\n     *\n     * @param {Array<number>} connectedPath - An array of vertex indices.\n     * @return {THREE.Geometry} trianglesMesh\n     */\n    makePlaneTriangulation: function (generator, sliceGeometry, connectedPath, options) {\n        // Convert the connected paths indices to [x, y, x, y, x, y, ...] coordinates (requied by earcut)\n        var currentPathXYData = connectedPath.reduce(function (earcutInput, vertIndex) {\n            var vert = sliceGeometry.vertices[vertIndex];\n            earcutInput.push(vert.x, vert.y);\n            return earcutInput;\n        }, []);\n        // Array<number> : triplets of vertex indices in the plain XY array\n        var triangles = (0, earcut_typescript_1.earcut)(currentPathXYData);\n        // Convert triangle indices back to a geometry\n        var trianglesGeometry = new THREE.Geometry();\n        // We will merge the geometries in the end which will create clones of the vertices.\n        // No need to clone here.\n        // trianglesGeometry.vertices = leftSliceGeometry.vertices;\n        trianglesGeometry.vertices = connectedPath.map(function (geometryVertexIndex) {\n            return sliceGeometry.vertices[geometryVertexIndex];\n        });\n        // Array<{x,y}> is compatible with Array<{x,y,z}> here :)\n        var flatSideBounds = plotboilerplate_1.Bounds.computeFromVertices(trianglesGeometry.vertices.map(function (vector3) { return new plotboilerplate_1.Vertex(vector3.x, vector3.y); }));\n        for (var t = 0; t < triangles.length; t += 3) {\n            var a = triangles[t];\n            var b = triangles[t + 1];\n            var c = triangles[t + 2];\n            trianglesGeometry.faces.push(new THREE.Face3(a, b, c));\n            // Add UVs\n            UVHelpers_1.UVHelpers.makeFlatTriangleUVs(trianglesGeometry, flatSideBounds, a, b, c);\n        }\n        trianglesGeometry.uvsNeedUpdate = true;\n        // TODO: check if this is still required\n        trianglesGeometry.buffersNeedUpdate = true;\n        trianglesGeometry.computeVertexNormals();\n        var trianglesMesh = new THREE.Mesh(trianglesGeometry, new THREE.MeshBasicMaterial({\n            color: 0x0048ff,\n            transparent: true,\n            opacity: 0.55,\n            side: THREE.DoubleSide\n        }));\n        trianglesMesh.position.y = -100;\n        // trianglesMesh.position.z += 1.0; // Avoid Moiré with plane mesh?\n        trianglesMesh.userData[\"isExportable\"] = false;\n        generator.partialResults[constants_1.KEY_PLANE_INTERSECTION_TRIANGULATION] = trianglesGeometry;\n        if (options.showSplitShapeTriangulation) {\n            generator.addMesh(trianglesMesh);\n        }\n        return trianglesGeometry;\n    },\n    /**\n     * Normalize a 2D vector to a given length.\n     *\n     * @param {XYCoords} base - The start point.\n     * @param {XYCoords} extend - The end point.\n     * @param {number} normalLength - The desired length\n     */\n    // TODO: add types\n    normalizeVectorXY: function (base, extend, normalLength) {\n        var diff = { x: extend.x - base.x, y: extend.y - base.y }; // XYCoords\n        var length = Math.sqrt(diff.x * diff.x + diff.y * diff.y);\n        var ratio = normalLength / length;\n        extend.x = base.x + diff.x * ratio;\n        extend.y = base.y + diff.y * ratio;\n    },\n    /**\n     * Normalize a 2D vector to a given length.\n     *\n     * @param {XYCoords} base - The start point.\n     * @param {XYCoords} extend - The end point.\n     * @param {number} normalLength - The desired length\n     */\n    // TODO: add types\n    normalizeVectorXYZ: function (base, extend, normalLength) {\n        var diff = { x: extend.x - base.x, y: extend.y - base.y, z: extend.z - base.z };\n        var length = Math.sqrt(diff.x * diff.x + diff.y * diff.y + diff.z * diff.z);\n        var ratio = normalLength / length;\n        extend.x = base.x + diff.x * ratio;\n        extend.y = base.y + diff.y * ratio;\n        extend.z = base.z + diff.z * ratio;\n    },\n    /**\n     * A helper function to clear all child nodes from the given HTML DOM node.\n     *\n     * @param {HTMLElement} rootNoode\n     */\n    removeAllChildNodes: function (rootNode) {\n        while (rootNode.lastChild) {\n            rootNode.removeChild(rootNode.lastChild);\n        }\n    },\n    /**\n     * Clamp the given number into the passed min-max interval.\n     *\n     * @param {number} n\n     * @param {number} min\n     * @param {number} max\n     * @returns\n     */\n    clamp: function (n, min, max) {\n        return Math.max(Math.min(n, max), min);\n    }\n};\n//# sourceMappingURL=GeometryGenerationHelpers.js.map","\"use strict\";\n/**\n * @author  Ikaros Kappler\n * @date    2021-09-02\n * @version 1.0.0\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.ImageStore = void 0;\nexports.ImageStore = (function () {\n    var imageMap = new Map();\n    var Store = {\n        getImage: function (path, onComplete) {\n            // Try to find in store\n            var image = imageMap.get(path);\n            if (!image) {\n                image = document.createElement(\"img\"); // as HTMLImageElement;\n                imageMap.set(path, image);\n                image.onload = function () {\n                    onComplete(image);\n                };\n                image.setAttribute(\"src\", path);\n            }\n            return image;\n        },\n        isImageLoaded: function (image) {\n            return image.complete && image.naturalHeight !== 0 && image.naturalHeight !== undefined;\n        }\n    };\n    return Store;\n})();\n//# sourceMappingURL=ImageStore.js.map","\"use strict\";\n/**\n * The PathFinger tool will find the connected path on a mesh surface, given by a set\n * of vertices that lay on the geometry's surface.\n *\n * Each vertex in the path elements array must be at some gometry vertex position. The position\n * does not necessarily need to be exact, some epsilon is used (default epsilon is 0.000001).\n *\n * @author   Ikaros Kappler\n * @modified 2021-08-29 Ported to Typescript from vanilla JS.\n * @date     2021-07-06\n * @version  1.0.0\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.PathFinder = void 0;\n// var EPS = 0.000001;\nvar constants_1 = require(\"./constants\");\nvar PathFinder = /** @class */ (function () {\n    /**\n     * Construct a new PathFinder.\n     *\n     * @param {number=0.000001} epsilon - (optional) Specity any custom epsilon here if the default epsilon is too large/small. Must be >= 0.\n     */\n    function PathFinder(epsilon) {\n        this.visitedVertices = new Set();\n        this.unvisitedVertIndices = new Set(); // <number>\n        this.numVisitedVertices = 0;\n        this.epsilon = typeof epsilon !== \"undefined\" && epsilon >= 0 ? epsilon : constants_1.EPS;\n    }\n    /**\n     * Find all connected paths specified by the path vertex array, that lay on the geometry's surface.\n     *\n     * If the vertices depict more than one path, then the returned array will contain\n     * multiple paths, too.\n     *\n     * The pathVertices array must not contain duplicates.\n     *\n     * @param {THREE.Geometry} unbufferedGeometry - The geometry itself containing the path vertices.\n     * @param {THREE.Vector3[]} pathVertices - The unsorted vertices (must form a connected path on the geometry).\n     * @return {Array<number[]>} An array of paths; each path consists of an array of path vertex indices in the `pathVertices` param.\n     */\n    PathFinder.prototype.findAllPathsOnMesh = function (unbufferedGeometry, pathVertices) {\n        var collectedPaths = []; // Array<number[]>\n        this.visitedVertices.clear();\n        this.unvisitedVertIndices.clear();\n        // Map path vertices to vertices in the geometry.\n        //\n        // Please note that the index array might be shorter than the vertex array itself, if some vertices could\n        // not be located in the geometry.\n        //\n        var pathVertIndices = mapVerticesToGeometryIndices(unbufferedGeometry, pathVertices, this.epsilon);\n        var n = pathVertIndices.length;\n        // Initially build up an array of path vertices, marking them all as unvisited.\n        this.unvisitedVertIndices = new Set(pathVertIndices.map(function (_pathVert, index) {\n            return index;\n        }));\n        // As long as there are path vertices unvisited, there are sill portions of the path(s)\n        // to be processed.\n        while (this.numVisitedVertices < n) {\n            var nextUnvisitedIndex = this.unvisitedVertIndices.values().next().value;\n            // Array<number>\n            var path = this.findUnvisitedPaths(unbufferedGeometry, pathVertIndices, nextUnvisitedIndex);\n            collectedPaths.push(path);\n        }\n        // Try to find adjacent paths to connect them.\n        return this.combineAdjacentPaths(collectedPaths, unbufferedGeometry);\n    };\n    /**\n     * Find the next sequence unvisited path (indices) of vertices that are directly connected\n     * via some faces on the geometry's surface.\n     *\n     * Be aware that path detection only works in one direction, so you will probably end up\n     * in several paths that can still be connected, if you start with some random vertex\n     * index.\n     *\n     * @param {THREE.Geometry} unbufferedGeometry - The geometry to use to find connected vertices (use it's faces).\n     * @param {Array<number>} pathVertIndices - The indices of all vertices that form the path(s). Each index must match a vertex in the geometry's `vertices` array.\n     * @param {number} unvisitedIndex - The path vertex (index) to start with. This can be picked randomly.\n     * @returns {Array<number>} The indices of the found path in an array (index sequence).\n     */\n    PathFinder.prototype.findUnvisitedPaths = function (unbufferedGeometry, pathVertIndices, unvisitedIndex) {\n        var path = [unvisitedIndex]; // which elements?\n        this.visitedVertices.add(unvisitedIndex);\n        this.unvisitedVertIndices.delete(unvisitedIndex);\n        this.numVisitedVertices++;\n        // Find the the face for this vertex's index\n        // var faceAndVertIndex; // { faceIndex: number, vertIndex: number }\n        var adjacentVertIndex;\n        while ((adjacentVertIndex = this.findAdjacentFace(unbufferedGeometry, pathVertIndices, unvisitedIndex)) !== -1) {\n            // Retrieved face/vertex tuple represents the next element on the path\n            path.push(adjacentVertIndex);\n            this.visitedVertices.add(adjacentVertIndex);\n            this.unvisitedVertIndices.delete(adjacentVertIndex);\n            this.numVisitedVertices++;\n            unvisitedIndex = adjacentVertIndex;\n        }\n        return path;\n    };\n    /**\n     * Find the next unvisited vertex index that connects the given (unvisited) vertex\n     * index of the path.\n     *\n     * To find that the geometry's faces will be used.\n     *\n     * @param {THREE.Geometry} unbufferedGeometry\n     * @param {Array<number>} pathVertIndices\n     * @param {number} unvisitedIndex\n     * @returns {number} The next adjacent face index or -1 if none can be found.\n     */\n    PathFinder.prototype.findAdjacentFace = function (unbufferedGeometry, pathVertIndices, unvisitedIndex) {\n        var faceCount = unbufferedGeometry.faces.length;\n        for (var f = 0; f < faceCount; f++) {\n            if (faceHasVertIndex(unbufferedGeometry, f, unvisitedIndex)) {\n                // Face is a canditate to extend the path.\n                // Check if there is a second un-visited path vertex\n                for (var i = 0; i < pathVertIndices.length; i++) {\n                    var pathVertIndex = pathVertIndices[i];\n                    if (pathVertIndex === unvisitedIndex) {\n                        continue;\n                    }\n                    if (this.isVisited(pathVertIndex)) {\n                        continue;\n                    }\n                    if (!this.isVisited(pathVertIndex) && faceHasVertIndex(unbufferedGeometry, f, pathVertIndex)) {\n                        return pathVertIndex;\n                    }\n                    if (faceHasVertIndex(unbufferedGeometry, f, pathVertIndex)) {\n                        return pathVertIndex;\n                    }\n                } // END for\n            } // END if\n        } // END for\n        // At this point no matching face was found\n        return -1;\n    };\n    /**\n     * Checks if the given vertex index (one of the path vertices) was already\n     * marked as being visited.\n     *\n     * @param {number} vertIndex\n     * @returns {boolean}\n     */\n    PathFinder.prototype.isVisited = function (vertIndex) {\n        return this.visitedVertices.has(vertIndex);\n    };\n    /**\n     * Find adjacent paths and connect them.\n     *\n     * @param {Array<number[]>} collectedPaths\n     * @param {THREE.Geometry} unbufferedGeometry\n     * @param {THREE.Vector3[]} pathVertices\n     * @return {Array<number[]>} A new sequence of paths (a path is an array of vertex indices).\n     */\n    PathFinder.prototype.combineAdjacentPaths = function (collectedPaths, unbufferedGeometry) {\n        var resultPaths = [];\n        // First build up an unvisited path set (set of path indices)\n        var unvisitedPathIndexSet = new Set(collectedPaths.map(function (_path, index) {\n            return index;\n        }));\n        while (unvisitedPathIndexSet.size > 0) {\n            var currentPathIndex = unvisitedPathIndexSet.values().next().value;\n            unvisitedPathIndexSet.delete(currentPathIndex);\n            var currentPath = collectedPaths[currentPathIndex];\n            var nextPath = null; // TODO: type?\n            do {\n                nextPath = findAdjacentPath(collectedPaths, currentPath[currentPath.length - 1], unvisitedPathIndexSet, unbufferedGeometry);\n                if (!nextPath && currentPath.length > 1) {\n                    // If path's end point has no connection try reversed path\n                    currentPath = currentPath.reverse();\n                    nextPath = findAdjacentPath(collectedPaths, currentPath[currentPath.length - 1], unvisitedPathIndexSet, unbufferedGeometry);\n                }\n                if (nextPath) {\n                    currentPath = currentPath.concat(nextPath);\n                }\n            } while (nextPath);\n            // All adjacent paths found and connected.\n            resultPaths.push(currentPath);\n        }\n        return resultPaths;\n    };\n    return PathFinder;\n}()); // END class\nexports.PathFinder = PathFinder;\n/**\n * A simple check to determine if a face of the geometry (given by the face index)\n * is adjacent to the given vertex index (a vertex index in the geometry.).\n *\n * @param {THREE.Geometry} unbufferedGeometry\n * @param {number} faceIndex\n * @param {number} geometryVertexIndex\n * @returns\n */\nvar faceHasVertIndex = function (unbufferedGeometry, faceIndex, geometryVertexIndex) {\n    var face = unbufferedGeometry.faces[faceIndex];\n    return face.a === geometryVertexIndex || face.b === geometryVertexIndex || face.c === geometryVertexIndex;\n};\n/**\n * Get an array of vertex indices inside the geometry that represent the given path vertices,\n *\n * If no equivalent geometry vertex can be found (for a path vertex) then the path vertex\n * will be skipped.\n * So the returned array might be shorter than the path – and thus, have gaps.\n *\n * @param {THREE.Geometry} unbufferedGeometry - The Three.js geometry to use.\n * @param {Array<THREE.Vector3>} pathVertices - The acual mesh vertices of the current path.\n * @param {number} epsilon - Is required here (just pass through).\n * @returns\n */\nvar mapVerticesToGeometryIndices = function (unbufferedGeometry, pathVertices, epsilon) {\n    var pathVertIndices = [];\n    for (var i = 0; i < pathVertices.length; i++) {\n        var pathVert = pathVertices[i];\n        var foundIndex = -1;\n        var foundDist = epsilon;\n        for (var j = 0; j < unbufferedGeometry.vertices.length; j++) {\n            var curDist = unbufferedGeometry.vertices[j].distanceTo(pathVert);\n            if (curDist <= foundDist) {\n                // Remember geometry index if closest to path vertex\n                if (foundIndex === -1 ||\n                    // By convention use smalled vertex index if multiple found\n                    (foundIndex !== -1 && unbufferedGeometry.vertices[foundIndex].distanceTo(pathVert) >= curDist && foundIndex > j)) {\n                    foundIndex = j;\n                    foundDist = curDist;\n                }\n            }\n        }\n        if (foundIndex === -1) {\n            console.warn(\"PathFinder.mapVerticesToGeometryIndices could not find a matching geometry vertex for path point \" +\n                i +\n                \". The final result might be locally broken.\");\n        }\n        else {\n            // Note: it may be possible that NO MATCHING GEOMETRY VERT was found (foundIndex = -1).\n            pathVertIndices.push(foundIndex);\n        }\n    } // END for i\n    return pathVertIndices;\n};\n/**\n * This is a helper function to find adjacent sub paths and connect them.\n * It expects basic path segments already to be found and that they are\n * somehow connected. Unconnected paths – which are possible in non-convex\n * geometries – will stay unconnected.\n *\n * It locates the next path that connects to the given (current) path\n * and returns the acual path indices in the correct order. Forward paths\n * and backward paths are detected here and being brought into the correct\n * order.\n *\n * Example: if a path connects with it's end vertex to the end of the given\n * path, then it will be reversed.\n *\n * @param {Array<number[]>} collectedPaths - The array of paths (array of array)\n * @param {number} currentVertIndex - The vertex index in the geometry to find the next adjacent path for.\n * @param {Set<number>} unvisitedPathIndexSet - A set to keep track of unvisited vertex indices. Will be updated.\n * @param {THREE.Geometry} unbufferedGeometry - The geometry to find the path on.\n * @returns\n */\nvar findAdjacentPath = function (collectedPaths, currentVertIndex, unvisitedPathIndexSet, unbufferedGeometry) {\n    for (var f = 0; f < unbufferedGeometry.faces.length; f++) {\n        if (faceHasVertIndex(unbufferedGeometry, f, currentVertIndex)) {\n            // Now find any unvisited path (first or last point) that connects here.\n            for (var p = 0; p < collectedPaths.length; p++) {\n                if (!unvisitedPathIndexSet.has(p)) {\n                    // Path already visited\n                    continue;\n                }\n                var nextPath = collectedPaths[p];\n                if (faceHasVertIndex(unbufferedGeometry, f, nextPath[0])) {\n                    // Concat forwards\n                    unvisitedPathIndexSet.delete(p);\n                    return nextPath;\n                }\n                else if (faceHasVertIndex(unbufferedGeometry, f, nextPath[nextPath.length - 1])) {\n                    // Concat backwards\n                    unvisitedPathIndexSet.delete(p);\n                    return nextPath.reverse();\n                }\n            }\n        }\n    }\n};\n//# sourceMappingURL=PathFinder.js.map","\"use strict\";\n/**\n * Compute the intersection of a mesh and a plane.\n *\n * Inspired by\n *    https://stackoverflow.com/questions/42348495/three-js-find-all-points-where-a-mesh-intersects-a-plane\n *    https://jsfiddle.net/prisoner849/8uxw667m/\n *\n * @co-author Ikaros Kappler\n * @date 2021-06-11\n * @modified 2021-08-29 Ported to Typescript from vanilla JS.\n * @version 1.0.0\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.PlaneMeshIntersection = void 0;\nvar THREE = require(\"three\");\nvar PlaneMeshIntersection = /** @class */ (function () {\n    /**\n     * Constructor.\n     */\n    function PlaneMeshIntersection() {\n        var _this = this;\n        /**\n         *\n         * @param {THREE.Mesh} mesh\n         * @param {THREE.Geometry} geometry\n         * @param {THREE.Mesh} plane {THREE.PlaneGeometry ???\n         * @returns {Array<THREE.Vector3>}\n         */\n        // TODO: plane type???\n        this.getIntersectionPoints = function (mesh, geometry, plane, planeGeometryReal) {\n            // Note: this could also work with a directly passed Mesh.Plane object instead a THREE.PlaneGeometry.\n            _this.pointsOfIntersection = [];\n            var mathPlane = new THREE.Plane();\n            // var planeGeometry : THREE.Geometry = (plane as unknown).geometry;\n            // plane.localToWorld(this.planePointA.copy(plane.geometry.vertices[plane.geometry.faces[0].a]));\n            // plane.localToWorld(this.planePointB.copy(plane.geometry.vertices[plane.geometry.faces[0].b]));\n            // plane.localToWorld(this.planePointC.copy(plane.geometry.vertices[plane.geometry.faces[0].c]));\n            plane.localToWorld(_this.planePointA.copy(planeGeometryReal.vertices[planeGeometryReal.faces[0].a]));\n            plane.localToWorld(_this.planePointB.copy(planeGeometryReal.vertices[planeGeometryReal.faces[0].b]));\n            plane.localToWorld(_this.planePointC.copy(planeGeometryReal.vertices[planeGeometryReal.faces[0].c]));\n            mathPlane.setFromCoplanarPoints(_this.planePointA, _this.planePointB, _this.planePointC);\n            var _self = _this;\n            geometry.faces.forEach(function (face) {\n                mesh.localToWorld(_self.a.copy(geometry.vertices[face.a]));\n                mesh.localToWorld(_self.b.copy(geometry.vertices[face.b]));\n                mesh.localToWorld(_self.c.copy(geometry.vertices[face.c]));\n                _self.lineAB = new THREE.Line3(_self.a, _self.b);\n                _self.lineBC = new THREE.Line3(_self.b, _self.c);\n                _self.lineCA = new THREE.Line3(_self.c, _self.a);\n                _self.__setPointOfIntersection(_self.lineAB, mathPlane);\n                _self.__setPointOfIntersection(_self.lineBC, mathPlane);\n                _self.__setPointOfIntersection(_self.lineCA, mathPlane);\n            });\n            return _this.pointsOfIntersection;\n        };\n        this.__setPointOfIntersection = function (line, plane) {\n            var intersectionPoint = plane.intersectLine(line, this.pointOfIntersection);\n            if (intersectionPoint) {\n                this.pointsOfIntersection.push(intersectionPoint.clone());\n            }\n        };\n        //   Vector3[]\n        this.pointsOfIntersection = [];\n        this.a = new THREE.Vector3();\n        this.b = new THREE.Vector3();\n        this.c = new THREE.Vector3();\n        this.planePointA = new THREE.Vector3();\n        this.planePointB = new THREE.Vector3();\n        this.planePointC = new THREE.Vector3();\n        this.lineAB = new THREE.Line3();\n        this.lineBC = new THREE.Line3();\n        this.lineCA = new THREE.Line3();\n        this.pointOfIntersection = new THREE.Vector3();\n    }\n    return PlaneMeshIntersection;\n}());\nexports.PlaneMeshIntersection = PlaneMeshIntersection;\n//# sourceMappingURL=PlaneMeshIntersection.js.map","\"use strict\";\n/**\n * @author   Ikaros Kappler\n * @date     2021-08-03\n * @modified 2021-08-04 Ported to Typsescript from vanilla JS.\n * @version  1.0.1\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.UVHelpers = void 0;\nvar THREE = require(\"three\");\nexports.UVHelpers = {\n    /**\n     * Helper function to create triangular UV Mappings for a triangle.\n     *\n     * @param {THREE.Geometry} thisGeometry\n     * @param {Bounds} shapeBounds\n     * @param {number} vertIndexA - The index in the geometry's vertices array.\n     * @param {number} vertIndexB - ...\n     * @param {number} vertIndexC - ...\n     */\n    makeFlatTriangleUVs: function (thisGeometry, // THREE.Geometry does not longer exist since r125 and will be replaced by BufferGeometry\n    shapeBounds, vertIndexA, vertIndexB, vertIndexC) {\n        var vertA = thisGeometry.vertices[vertIndexA];\n        var vertB = thisGeometry.vertices[vertIndexB];\n        var vertC = thisGeometry.vertices[vertIndexC];\n        // Convert a position vertex { x, y, * } to UV coordinates { u, v }\n        var getUVRatios = function (vert) {\n            return new THREE.Vector2((vert.x - shapeBounds.min.x) / shapeBounds.width, (vert.y - shapeBounds.min.y) / shapeBounds.height);\n        };\n        thisGeometry.faceVertexUvs[0].push([getUVRatios(vertA), getUVRatios(vertB), getUVRatios(vertC)]);\n    }\n};\n//# sourceMappingURL=UVHelpers.js.map","\"use strict\";\n/**\n * @author   Ikaros Kappler\n * @date     2021-07-13\n * @modified 2021-08-04 Ported to Typescript from vainlla JS.\n * @version  1.0.1\n **/\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.clearDuplicateVertices3 = void 0;\nvar EPS = 0.000001;\n/**\n * Filter the array and clear all duplicates.\n *\n * The original array is left unchanged. The vertices in the array are not cloned.\n *\n * @param {THREE.Vector3[]} vertices\n * @param {number=EPS} epsilon\n * @return {THREE.Vector3[]}\n */\nvar clearDuplicateVertices3 = function (vertices, epsilon) {\n    if (typeof epsilon === \"undefined\") {\n        epsilon = EPS;\n    }\n    var result = [];\n    for (var i = 0; i < vertices.length; i++) {\n        if (!containsElementFrom(vertices, vertices[i], i + 1, epsilon)) {\n            result.push(vertices[i]);\n        }\n    }\n    return result;\n};\nexports.clearDuplicateVertices3 = clearDuplicateVertices3;\n/**\n * A distance checker: check if the passed to vertices are no more than 'eps' units apart.\n *\n * @param {THREE.Vector3} vertA\n * @param {THREE.Vector3} vertB\n * @param {number} eps\n * @returns {boolean}\n */\nvar isCloseTo = function (vertA, vertB, eps) {\n    return vertA.distanceTo(vertB) < eps;\n};\n/**\n * Try to find an element in the given vertex array, starting at a given position (inclusive).\n *\n * @param {THREE.Vector3[]} vertices\n * @param {THREE.Vector3} vertex\n * @param {number} fromIndex\n * @param {number} epsilon\n * @returns {boolan}\n */\nvar containsElementFrom = function (vertices, vertex, fromIndex, epsilon) {\n    for (var i = fromIndex; i < vertices.length; i++) {\n        if (isCloseTo(vertices[i], vertex, epsilon)) {\n            return true;\n        }\n    }\n    return false;\n};\n//# sourceMappingURL=clearDuplicateVertices3.js.map","\"use strict\";\n/**\n * Calculate the vertex normals of a mesh from the pre-calculated face normals.\n *\n * jkmott writing about this challenge:\n *   >> If you have a large complex mesh with small faces you can get away with\n *   >> computing the vertex normals by taking the average of the face normals\n *   >> that surround it, and that’s a fine strategy.\n *\n * https://meshola.wordpress.com/2016/07/24/three-js-vertex-normals/\n *\n * @author  Ikaros Kappler\n * @date    2021-08-31\n * @version 1.0.0\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.computeVertexNormals = void 0;\nvar THREE = require(\"three\");\n/**\n * Compute the vertex normals of a base geometry and its buffered counterpart (both parts are required here).\n *\n * Note that unbufferedGeometry.computeVertexNormals() must have been called for this to work.\n *\n * @param {THREE.Geometry} unbufferedGeometry - The base geometry.\n * @param {THREE.BufferedGeometry} bufferedGeometry - The buffered geometry.\n * @returns\n */\nvar computeVertexNormals = function (unbufferedGeometry, bufferedGeometry) {\n    // Fetch the face normals from the buffers.\n    var vertexNormals = bufferedGeometry.getAttribute(\"normal\");\n    //   console.log(\"normals\", vertexNormals);\n    //   console.log(\n    //     \"unbufferedGeometry.vertices.length\",\n    //     unbufferedGeometry.vertices.length,\n    //     \"unbufferedGeometry.faces.length\",\n    //     unbufferedGeometry.faces.length,\n    //     \"vertexNormals.array.length/3\",\n    //     vertexNormals.array.length / 3\n    //   );\n    var collectedFaceNormals = Array(unbufferedGeometry.faces.length);\n    // For each face get the three face normals, each of which consists of 3 float values itself.\n    // So each face consumes 9 floats from the array buffer.\n    for (var f = 0; f < unbufferedGeometry.faces.length; f++) {\n        var face = unbufferedGeometry.faces[f];\n        var faceNormalA = new THREE.Vector3(vertexNormals.array[f * 9 + 0], vertexNormals.array[f * 9 + 1], vertexNormals.array[f * 9 + 2]);\n        var faceNormalB = new THREE.Vector3(vertexNormals.array[f * 9 + 3], vertexNormals.array[f * 9 + 4], vertexNormals.array[f * 9 + 5]);\n        var faceNormalC = new THREE.Vector3(vertexNormals.array[f * 9 + 6], vertexNormals.array[f * 9 + 7], vertexNormals.array[f * 9 + 8]);\n        addVertexNormal(collectedFaceNormals, face.a, faceNormalA);\n        addVertexNormal(collectedFaceNormals, face.b, faceNormalB);\n        addVertexNormal(collectedFaceNormals, face.c, faceNormalC);\n    } // END for\n    //   console.log(\"collectedFaceNormals\", collectedFaceNormals);\n    var normals = new Array(unbufferedGeometry.vertices.length);\n    for (var i = 0; i < unbufferedGeometry.vertices.length; i++) {\n        var averageNormal = computeAverageVector(collectedFaceNormals[i]);\n        averageNormal.add(unbufferedGeometry.vertices[i]);\n        normals[i] = new THREE.Line3(unbufferedGeometry.vertices[i], averageNormal);\n    }\n    return normals;\n};\nexports.computeVertexNormals = computeVertexNormals;\n/**\n * Add the computed face normal to the given vertex normal buffer.\n *\n * Each vertex normal buffer ends up with multiple face normals associated with it (from the\n * adjacent faces). The aim is to calculate the average vector from all.\n *\n * @param {Array<THREE.Vector3[]>} buffer\n * @param {number} vertIndex\n * @param {THREE.Vector3} vertexNormal\n */\nvar addVertexNormal = function (buffer, vertIndex, vertexNormal) {\n    if (vertIndex >= buffer.length || typeof buffer[vertIndex] === \"undefined\") {\n        buffer[vertIndex] = [];\n    }\n    buffer[vertIndex].push(vertexNormal);\n};\n/**\n * Compute the average vector from a sequence of (nromal) vectors.\n *\n * @param {Array<THREE.Vector3>} vectors - The vectors to get the average vector for.\n * @returns {THREE.Vector3} The average vector from all given.\n */\nvar computeAverageVector = function (vectors) {\n    var avg = new THREE.Vector3(0, 0, 0);\n    if (vectors) {\n        vectors.forEach(function (nrml) {\n            avg.add(nrml);\n        });\n        avg.divideScalar(vectors.length);\n    }\n    return avg;\n};\n//# sourceMappingURL=computeVertexNormals.js.map","\"use strict\";\n/**\n * @author  Ikaros Kappler\n * @version 1.0.0\n * @date    2021-08-30\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.KEY_SPLIT_TRIANGULATION_GEOMETRIES = exports.KEY_PLANE_INTERSECTION_TRIANGULATION = exports.KEY_PLANE_INTERSECTION_POINTS = exports.KEY_SPLIT_PANE_MESH = exports.KEY_RIGHT_SLICE_PLANE = exports.KEY_LEFT_SLICE_PLANE = exports.KEY_RIGHT_SLICE_GEOMETRY = exports.KEY_LEFT_SLICE_GEOMETRY = exports.DEG_TO_RAD = exports.EPS = void 0;\nexports.EPS = 0.000001;\nexports.DEG_TO_RAD = Math.PI / 180.0;\nexports.KEY_LEFT_SLICE_GEOMETRY = \"KEY_LEFT_SLICE_GEOMETRY\"; // THREE.Geometry\nexports.KEY_RIGHT_SLICE_GEOMETRY = \"KEY_RIGHT_SLICE_GEOMETRY\"; // THREE.Geometry\nexports.KEY_LEFT_SLICE_PLANE = \"KEY_LEFT_SLICE_PLANE\"; // THREE.Plane\nexports.KEY_RIGHT_SLICE_PLANE = \"KEY_RIGHT_SLICE_PLANE\"; // THREE.Plane\nexports.KEY_SPLIT_PANE_MESH = \"KEY_SPLIT_PANE_MESH\"; // THREE.Mesh\nexports.KEY_PLANE_INTERSECTION_POINTS = \"KEY_PLANE_INTERSECTION_POINTS\"; // Array<Vector3>\nexports.KEY_PLANE_INTERSECTION_TRIANGULATION = \"KEY_PLANE_INTERSECTION_TRIANGULATION\"; // THREE.Geometry\nexports.KEY_SPLIT_TRIANGULATION_GEOMETRIES = \"KEY_SPLIT_TRIANGULATION_GEOMETRIES\"; // Array<THREE.Geometry>\n//# sourceMappingURL=constants.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.DEFAULT_BEZIER_JSON = void 0;\n// Refactored from dildo-generator\nexports.DEFAULT_BEZIER_JSON = \n//'[ { \"startPoint\" : [-122,77.80736634304651], \"endPoint\" : [-65.59022229786551,21.46778533702511], \"startControlPoint\": [-121.62058129515852,25.08908859418696], \"endControlPoint\" : [-79.33419353770395,48.71529293460728] }, { \"startPoint\" : [-65.59022229786551,21.46778533702511], \"endPoint\" : [-65.66917273472913,-149.23537680826058], \"startControlPoint\": [-52.448492057756646,-4.585775770903305], \"endControlPoint\" : [-86.1618869001374,-62.11613821618976] }, { \"startPoint\" : [-65.66917273472913,-149.23537680826058], \"endPoint\" : [-61.86203591980055,-243.8368165606738], \"startControlPoint\": [-53.701578771473564,-200.1123697454778], \"endControlPoint\" : [-69.80704300441666,-205.36451303641783] }, { \"startPoint\" : [-61.86203591980055,-243.8368165606738], \"endPoint\" : [-21.108966092052256,-323], \"startControlPoint\": [-54.08681426887413,-281.486963896856], \"endControlPoint\" : [-53.05779349623559,-323] } ]';\n\"\\n  [\\n    {\\n       \\\"startPoint\\\":[\\n          -122,\\n          77.80736634304651\\n       ],\\n       \\\"endPoint\\\":[\\n          -65.59022229786551,\\n          21.46778533702511\\n       ],\\n       \\\"startControlPoint\\\":[\\n          -121.62058129515852,\\n          25.08908859418696\\n       ],\\n       \\\"endControlPoint\\\":[\\n          -79.33419353770395,\\n          48.71529293460728\\n       ]\\n    },\\n    {\\n       \\\"startPoint\\\":[\\n          -65.59022229786551,\\n          21.46778533702511\\n       ],\\n       \\\"endPoint\\\":[\\n          -65.66917273472913,\\n          -149.23537680826058\\n       ],\\n       \\\"startControlPoint\\\":[\\n          -52.448492057756646,\\n          -4.585775770903305\\n       ],\\n       \\\"endControlPoint\\\":[\\n          -86.1618869001374,\\n          -62.11613821618976\\n       ]\\n    },\\n    {\\n       \\\"startPoint\\\":[\\n          -65.66917273472913,\\n          -149.23537680826058\\n       ],\\n       \\\"endPoint\\\":[\\n          -61.86203591980055,\\n          -243.8368165606738\\n       ],\\n       \\\"startControlPoint\\\":[\\n          -53.701578771473564,\\n          -200.1123697454778\\n       ],\\n       \\\"endControlPoint\\\":[\\n          -69.80704300441666,\\n          -205.36451303641783\\n       ]\\n    },\\n    {\\n       \\\"startPoint\\\":[\\n          -61.86203591980055,\\n          -243.8368165606738\\n       ],\\n       \\\"endPoint\\\":[\\n          -21.108966092052256,\\n          -323\\n       ],\\n       \\\"startControlPoint\\\":[\\n          -54.08681426887413,\\n          -281.486963896856\\n       ],\\n       \\\"endControlPoint\\\":[\\n          -53.05779349623559,\\n          -323\\n       ]\\n    }\\n ]\\n  \";\n//# sourceMappingURL=defaults.js.map","\"use strict\";\n\n// Export the library to the global scope:\nglobalThis.ngdg = require(\"./ngdg\").ngdg;\n","\"use strict\";\n/**\n * @author   Ikaros Kappler\n * @date     2021-07-26\n * @modified 2021-08-04 Ported to Typescript from vanilla JS.\n * @version  1.0.1\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.locateVertexInArray = void 0;\n/**\n * Find that vertex in the array that is closest to the given vertex.\n *\n * The epsilon is not optional.\n *\n * @param {Array<THREE.Vector3>} vertArray\n * @param {THREE.Vector3} vertex\n * @param {number} epsilon\n * @returns {number} The index of the found vertex or -1 if not found.\n */\nvar locateVertexInArray = function (vertArray, vertex, epsilon) {\n    var closestDist = Number.POSITIVE_INFINITY;\n    var closestIndex = -1;\n    for (var i = 0; i < vertArray.length; i++) {\n        var dist = vertArray[i].distanceTo(vertex);\n        if (closestIndex === -1 && dist < closestDist && dist < epsilon) {\n            closestIndex = i;\n            closestDist = dist;\n        }\n    }\n    return closestIndex;\n};\nexports.locateVertexInArray = locateVertexInArray;\n//# sourceMappingURL=locateVertexInArray.js.map","\"use strict\";\n/**\n * Merge one geometry (all vertices and faces) into the other.\n *\n * @require locateVertexInArray\n *\n * @author   Ikaros Kappler\n * @date     2021-07-26\n * @modified 2021-08-04 Ported to Typescript from vanilla JS.\n * @version  1.0.0\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.mergeAndMapVertices = exports.mergeGeometries = void 0;\nvar THREE = require(\"three\");\n// import { Geometry, Face3 } from \"three/examples/jsm/deprecated/Geometry\";\nvar locateVertexInArray_1 = require(\"./locateVertexInArray\");\nvar EPS = 0.000001;\n// import { EPS } from \"./constants\";\n/**\n * This function tries to merge the 'mergeGeometry' into the 'baseGeometry'.\n * It assumes that both geometries are somehow connected, so it will try to\n * local equal vertices first instead of just copying all 'mergeGeometry' vertices\n * into the other one.\n *\n * The merged vertices will be cloned.\n *\n * @param {THREE.Geometry} baseGeometry\n * @param {THREE.Geometry} mergeGeometry\n */\nvar mergeGeometries = function (baseGeometry, mergeGeometry, epsilon) {\n    if (typeof epsilon === \"undefined\") {\n        epsilon = EPS;\n    }\n    var vertexMap = (0, exports.mergeAndMapVertices)(baseGeometry, mergeGeometry, epsilon);\n    for (var f = 0; f < mergeGeometry.faces.length; f++) {\n        var face = mergeGeometry.faces[f];\n        var a = vertexMap[face.a];\n        var b = vertexMap[face.b];\n        var c = vertexMap[face.c];\n        // baseGeometry.faces.push(new THREE.Face3(a, b, c));\n        // TODO: how to use this here?\n        // Face3 is not a constructor!!! Just a type!!!\n        baseGeometry.faces.push(new THREE.Face3(a, b, c));\n        if (mergeGeometry.faceVertexUvs.length > 0 && f < mergeGeometry.faceVertexUvs[0].length) {\n            var uvData = mergeGeometry.faceVertexUvs[0][f]; // [Vector2,Vector2,Vector2]\n            baseGeometry.faceVertexUvs[0].push([uvData[0].clone(), uvData[1].clone(), uvData[2].clone()]);\n        }\n        else {\n            baseGeometry.faceVertexUvs[0].push([new THREE.Vector2(0.0, 0.0), new THREE.Vector2(0.0, 1.0), new THREE.Vector2(1.0, 0.5)]);\n        }\n    }\n};\nexports.mergeGeometries = mergeGeometries;\n/**\n * This function merges the vertices from a given geometry into a base geometry.\n * It will ty to locate existing vertices within an epsilon range and keep those. Vertices that\n * have no close existing counterpart in the base geometry will be added.\n *\n * The function returns a mapping of new/merged vertices inside the base geometry, showing\n * which vertex (index) was mapped whereto.\n *\n * @param {THREE-Geometry} baseGeometry\n * @param {THREE-Geometry} mergeGeometry\n * @param {number} epsilon\n * @returns Array<number>\n */\nvar mergeAndMapVertices = function (baseGeometry, mergeGeometry, epsilon) {\n    var vertexMap = [];\n    for (var v = 0; v < mergeGeometry.vertices.length; v++) {\n        var mergeVert = mergeGeometry.vertices[v];\n        var indexInBase = (0, locateVertexInArray_1.locateVertexInArray)(baseGeometry.vertices, mergeVert, epsilon);\n        if (indexInBase === -1) {\n            // The current vertex cannot be found in the base geometry.\n            //  -> add to geometry and remember new index.\n            vertexMap.push(baseGeometry.vertices.length);\n            baseGeometry.vertices.push(mergeVert.clone());\n        }\n        else {\n            vertexMap.push(indexInBase);\n        }\n    }\n    return vertexMap;\n};\nexports.mergeAndMapVertices = mergeAndMapVertices;\n//# sourceMappingURL=mergeGeometries.js.map","\"use strict\";\n/**\n * This defines the globally exported wrapper library.\n *\n * See ./src/cjs/entry.js\n *\n * @author  Ikaros Kappler\n * @version 1.0.0\n * @date    2021-09-27\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.ngdg = void 0;\nvar defaults_1 = require(\"./defaults\");\nvar ImageStore_1 = require(\"./ImageStore\");\nvar DildoGeneration_1 = require(\"./DildoGeneration\");\nexports.ngdg = {\n    DEFAULT_BEZIER_JSON: defaults_1.DEFAULT_BEZIER_JSON,\n    DildoGeneration: DildoGeneration_1.DildoGeneration,\n    ImageStore: ImageStore_1.ImageStore\n};\n//# sourceMappingURL=ngdg.js.map","\"use strict\";\n/**\n * Refactored from some older code from 2020.\n *\n * @requires WebColors\n * @requires WebColorsMalachite\n * @requires WebColorsContrast\n *\n * @author   Ikaros Kappler\n * @date     2021-07-14\n * @modified 2021-08-29 Ported to Typescript from vanilla Js.\n * @version  1.0.1\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.randomWebColor = void 0;\nvar WebColorsMalachite_1 = require(\"plotboilerplate/src/esm/utils/WebColorsMalachite\");\nvar WebColorsContrast_1 = require(\"plotboilerplate/src/esm/utils/WebColorsContrast\");\nvar WebColors_1 = require(\"plotboilerplate/src/esm/utils/WebColors\");\n/**\n * Pick a color from the WebColors array.\n *\n * All params are optional.\n *\n * @param {number=undefined} index\n * @param {\"Malachite\"|\"Mixed\"|\"WebColors\"} colorSet\n **/\nvar randomWebColor = function (index, colorSet) {\n    if (typeof index === \"undefined\") {\n        var maxLen = Math.max(typeof WebColorsMalachite_1.WebColorsMalachite !== \"undefined\" ? WebColorsMalachite_1.WebColorsMalachite.length : 0, typeof WebColorsContrast_1.WebColorsContrast !== \"undefined\" ? WebColorsContrast_1.WebColorsContrast.length : 0, typeof WebColors_1.WebColors !== \"undefined\" ? WebColors_1.WebColors.length : 0);\n        index = Math.round(Math.random() * maxLen);\n    }\n    switch (colorSet) {\n        case \"Malachite\":\n            if (typeof WebColorsMalachite_1.WebColorsMalachite !== \"undefined\") {\n                return WebColorsMalachite_1.WebColorsMalachite[index % WebColorsMalachite_1.WebColorsMalachite.length].cssRGB();\n            }\n            else {\n                console.warn(\"You decided to use the 'WebColorsMalachite' color palette but it is not installed. Falling back.\");\n            }\n        case \"Mixed\":\n            if (typeof WebColorsContrast_1.WebColorsContrast !== \"undefined\") {\n                return WebColorsContrast_1.WebColorsContrast[index % WebColorsContrast_1.WebColorsContrast.length].cssRGB();\n            }\n            else {\n                console.warn(\"You decided to use the 'WebColorsContrast' color palette but it is not installed. Falling back.\");\n            }\n        case \"WebColors\":\n        default:\n            return WebColors_1.WebColors[index % WebColors_1.WebColors.length].cssRGB();\n    }\n};\nexports.randomWebColor = randomWebColor;\n//# sourceMappingURL=randomWebColor.js.map","\"use strict\";\n/**\n * This is a typescript port for the threejs-slice-geometry/faces-from-edges.js script.\n *\n * https://github.com/tdhooper/threejs-slice-geometry/blob/master/src/faces-from-edges.js\n *\n * @co-author Ikaros Kappler\n * @date 2021-08-29\n * @version 1.0.0\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.facesFromEdges = void 0;\n// TODO: port this into a separate typescript-port-package\nfunction facesFromEdges(edges) {\n    var chains = joinEdges(edges).filter(validFace);\n    var faces = chains.map(function (chain) {\n        return chain.map(function (edge) {\n            return edge[0];\n        });\n    });\n    return faces;\n}\nexports.facesFromEdges = facesFromEdges;\nfunction joinEdges(edges) {\n    var changes = true;\n    var chains = edges.map(function (edge) {\n        return [edge];\n    });\n    while (changes) {\n        changes = connectChains(chains);\n    }\n    chains = chains.filter(function (chain) {\n        return chain.length;\n    });\n    return chains;\n}\nfunction connectChains(chains) {\n    chains.forEach(function (chainA, i) {\n        chains.forEach(function (chainB, j) {\n            var merged = mergeChains(chainA, chainB);\n            if (merged) {\n                delete chains[j];\n                return true;\n            }\n        });\n    });\n    return false;\n}\nfunction mergeChains(chainA, chainB) {\n    if (chainA === chainB) {\n        return false;\n    }\n    if (chainStart(chainA) === chainEnd(chainB)) {\n        chainA.unshift.apply(chainA, chainB);\n        return true;\n    }\n    if (chainStart(chainA) === chainStart(chainB)) {\n        reverseChain(chainB);\n        chainA.unshift.apply(chainA, chainB);\n        return true;\n    }\n    if (chainEnd(chainA) === chainStart(chainB)) {\n        chainA.push.apply(chainA, chainB);\n        return true;\n    }\n    if (chainEnd(chainA) === chainEnd(chainB)) {\n        reverseChain(chainB);\n        chainA.push.apply(chainA, chainB);\n        return true;\n    }\n    return false;\n}\nfunction chainStart(chain) {\n    return chain[0][0];\n}\nfunction chainEnd(chain) {\n    return chain[chain.length - 1][1];\n}\nfunction reverseChain(chain) {\n    chain.reverse();\n    chain.forEach(function (edge) {\n        edge.reverse();\n    });\n}\nfunction validFace(chain) {\n    return chainStart(chain) === chainEnd(chain) ? 1 : 0;\n}\n// module.exports = facesFromEdges;\n//# sourceMappingURL=faces-from-edges.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.sliceGeometry = void 0;\nvar slice_1 = require(\"./slice\");\nObject.defineProperty(exports, \"sliceGeometry\", { enumerable: true, get: function () { return slice_1.sliceGeometry; } });\n//# sourceMappingURL=index.js.map","\"use strict\";\n/**\n * This is a typescript port for the threejs-slice-geometry/slice.js script.\n *\n * https://github.com/tdhooper/threejs-slice-geometry/blob/master/src/slice.js\n *\n * @co-author Ikaros Kappler\n * @date 2021-08-29\n * @version 1.0.0\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.sliceGeometry = void 0;\n// TODO: add proper types\n// TODO: port to separated library\n// var facesFromEdges = require('./faces-from-edges.js');\nvar faces_from_edges_1 = require(\"./faces-from-edges\");\nvar THREE = require(\"three\");\n// module.exports = function (THREE) {\n//   \"use strict\";\nvar FRONT = \"front\";\nvar BACK = \"back\";\nvar ON = \"on\";\nvar FACE_KEYS = [\"a\", \"b\", \"c\"];\nvar sliceGeometry = function (geometry, plane, closeHoles) {\n    var sliced = new THREE.Geometry();\n    var builder = new GeometryBuilder(geometry, sliced, plane);\n    var distances = [];\n    var positions = [];\n    geometry.vertices.forEach(function (vertex) {\n        var distance = findDistance(vertex, plane);\n        var position = distanceAsPosition(distance);\n        distances.push(distance);\n        positions.push(position);\n    });\n    geometry.faces.forEach(function (face, faceIndex) {\n        var facePositions = FACE_KEYS.map(function (key) {\n            return positions[face[key]];\n        });\n        if (facePositions.indexOf(FRONT) === -1 && facePositions.indexOf(BACK) !== -1) {\n            return;\n        }\n        builder.startFace(faceIndex);\n        var lastKey = FACE_KEYS[FACE_KEYS.length - 1];\n        var lastIndex = face[lastKey];\n        var lastDistance = distances[lastIndex];\n        var lastPosition = positions[lastIndex];\n        FACE_KEYS.map(function (key) {\n            var index = face[key];\n            var distance = distances[index];\n            var position = positions[index];\n            if (position === FRONT) {\n                if (lastPosition === BACK) {\n                    builder.addIntersection(lastKey, key, lastDistance, distance);\n                    builder.addVertex(key);\n                }\n                else {\n                    builder.addVertex(key);\n                }\n            }\n            if (position === ON) {\n                builder.addVertex(key);\n            }\n            if (position === BACK && lastPosition === FRONT) {\n                builder.addIntersection(lastKey, key, lastDistance, distance);\n            }\n            lastKey = key;\n            lastIndex = index;\n            lastPosition = position;\n            lastDistance = distance;\n        });\n        builder.endFace();\n    });\n    if (closeHoles) {\n        builder.closeHoles();\n    }\n    return sliced;\n};\nexports.sliceGeometry = sliceGeometry;\nvar distanceAsPosition = function (distance) {\n    if (distance < 0) {\n        return BACK;\n    }\n    if (distance > 0) {\n        return FRONT;\n    }\n    return ON;\n};\nvar findDistance = function (vertex, plane) {\n    return plane.distanceToPoint(vertex);\n};\nvar GeometryBuilder = function (sourceGeometry, targetGeometry, slicePlane) {\n    this.sourceGeometry = sourceGeometry;\n    this.targetGeometry = targetGeometry;\n    this.slicePlane = slicePlane;\n    this.addedVertices = [];\n    this.addedIntersections = [];\n    this.newEdges = [[]];\n};\nGeometryBuilder.prototype.startFace = function (sourceFaceIndex) {\n    this.sourceFaceIndex = sourceFaceIndex;\n    this.sourceFace = this.sourceGeometry.faces[sourceFaceIndex];\n    this.sourceFaceUvs = this.sourceGeometry.faceVertexUvs[0][sourceFaceIndex];\n    this.faceIndices = [];\n    this.faceNormals = [];\n    this.faceUvs = [];\n};\nGeometryBuilder.prototype.endFace = function () {\n    var indices = this.faceIndices.map(function (index, i) {\n        return i;\n    });\n    this.addFace(indices);\n};\nGeometryBuilder.prototype.closeHoles = function () {\n    if (!this.newEdges[0].length) {\n        return;\n    }\n    (0, faces_from_edges_1.facesFromEdges)(this.newEdges).forEach(function (faceIndices) {\n        var normal = this.faceNormal(faceIndices);\n        if (normal.dot(this.slicePlane.normal) > 0.5) {\n            faceIndices.reverse();\n        }\n        this.startFace();\n        this.faceIndices = faceIndices;\n        this.endFace();\n    }, this);\n};\nGeometryBuilder.prototype.addVertex = function (key) {\n    this.addUv(key);\n    this.addNormal(key);\n    var index = this.sourceFace[key];\n    var newIndex;\n    if (this.addedVertices.hasOwnProperty(index)) {\n        newIndex = this.addedVertices[index];\n    }\n    else {\n        var vertex = this.sourceGeometry.vertices[index];\n        this.targetGeometry.vertices.push(vertex);\n        newIndex = this.targetGeometry.vertices.length - 1;\n        this.addedVertices[index] = newIndex;\n    }\n    this.faceIndices.push(newIndex);\n};\nGeometryBuilder.prototype.addIntersection = function (keyA, keyB, distanceA, distanceB) {\n    var t = Math.abs(distanceA) / (Math.abs(distanceA) + Math.abs(distanceB));\n    this.addIntersectionUv(keyA, keyB, t);\n    this.addIntersectionNormal(keyA, keyB, t);\n    var indexA = this.sourceFace[keyA];\n    var indexB = this.sourceFace[keyB];\n    var id = this.intersectionId(indexA, indexB);\n    var index;\n    if (this.addedIntersections.hasOwnProperty(id)) {\n        index = this.addedIntersections[id];\n    }\n    else {\n        var vertexA = this.sourceGeometry.vertices[indexA];\n        var vertexB = this.sourceGeometry.vertices[indexB];\n        var newVertex = vertexA.clone().lerp(vertexB, t);\n        this.targetGeometry.vertices.push(newVertex);\n        index = this.targetGeometry.vertices.length - 1;\n        this.addedIntersections[id] = index;\n    }\n    this.faceIndices.push(index);\n    this.updateNewEdges(index);\n};\nGeometryBuilder.prototype.addUv = function (key) {\n    if (!this.sourceFaceUvs) {\n        return;\n    }\n    var index = this.keyIndex(key);\n    var uv = this.sourceFaceUvs[index];\n    this.faceUvs.push(uv);\n};\nGeometryBuilder.prototype.addIntersectionUv = function (keyA, keyB, t) {\n    if (!this.sourceFaceUvs) {\n        return;\n    }\n    var indexA = this.keyIndex(keyA);\n    var indexB = this.keyIndex(keyB);\n    var uvA = this.sourceFaceUvs[indexA];\n    var uvB = this.sourceFaceUvs[indexB];\n    var uv = uvA.clone().lerp(uvB, t);\n    this.faceUvs.push(uv);\n};\nGeometryBuilder.prototype.addNormal = function (key) {\n    if (!this.sourceFace.vertexNormals.length) {\n        return;\n    }\n    var index = this.keyIndex(key);\n    var normal = this.sourceFace.vertexNormals[index];\n    this.faceNormals.push(normal);\n};\nGeometryBuilder.prototype.addIntersectionNormal = function (keyA, keyB, t) {\n    if (!this.sourceFace.vertexNormals.length) {\n        return;\n    }\n    var indexA = this.keyIndex(keyA);\n    var indexB = this.keyIndex(keyB);\n    var normalA = this.sourceFace.vertexNormals[indexA];\n    var normalB = this.sourceFace.vertexNormals[indexB];\n    var normal = normalA.clone().lerp(normalB, t).normalize();\n    this.faceNormals.push(normal);\n};\nGeometryBuilder.prototype.addFace = function (indices) {\n    if (indices.length === 3) {\n        this.addFacePart(indices[0], indices[1], indices[2]);\n        return;\n    }\n    var pairs = [];\n    for (var i = 0; i < indices.length; i++) {\n        for (var j = i + 1; j < indices.length; j++) {\n            var diff = Math.abs(i - j);\n            if (diff > 1 && diff < indices.length - 1) {\n                pairs.push([indices[i], indices[j]]);\n            }\n        }\n    }\n    pairs.sort(function (pairA, pairB) {\n        var lengthA = this.faceEdgeLength(pairA[0], pairA[1]);\n        var lengthB = this.faceEdgeLength(pairB[0], pairB[1]);\n        return lengthA - lengthB;\n    }.bind(this));\n    var a = indices.indexOf(pairs[0][0]);\n    indices = indices.slice(a).concat(indices.slice(0, a));\n    var b = indices.indexOf(pairs[0][1]);\n    var indicesA = indices.slice(0, b + 1);\n    var indicesB = indices.slice(b).concat(indices.slice(0, 1));\n    this.addFace(indicesA);\n    this.addFace(indicesB);\n};\nGeometryBuilder.prototype.addFacePart = function (a, b, c) {\n    var normals = null;\n    if (this.faceNormals.length) {\n        normals = [this.faceNormals[a], this.faceNormals[b], this.faceNormals[c]];\n    }\n    var face = new THREE.Face3(this.faceIndices[a], this.faceIndices[b], this.faceIndices[c], normals);\n    this.targetGeometry.faces.push(face);\n    if (!this.sourceFaceUvs) {\n        return;\n    }\n    this.targetGeometry.faceVertexUvs[0].push([this.faceUvs[a], this.faceUvs[b], this.faceUvs[c]]);\n};\nGeometryBuilder.prototype.faceEdgeLength = function (a, b) {\n    var indexA = this.faceIndices[a];\n    var indexB = this.faceIndices[b];\n    var vertexA = this.targetGeometry.vertices[indexA];\n    var vertexB = this.targetGeometry.vertices[indexB];\n    return vertexA.distanceToSquared(vertexB);\n};\nGeometryBuilder.prototype.intersectionId = function (indexA, indexB) {\n    return [indexA, indexB].sort().join(\",\");\n};\nGeometryBuilder.prototype.keyIndex = function (key) {\n    return FACE_KEYS.indexOf(key);\n};\nGeometryBuilder.prototype.updateNewEdges = function (index) {\n    var edgeIndex = this.newEdges.length - 1;\n    var edge = this.newEdges[edgeIndex];\n    if (edge.length < 2) {\n        edge.push(index);\n    }\n    else {\n        this.newEdges.push([index]);\n    }\n};\nGeometryBuilder.prototype.faceNormal = function (faceIndices) {\n    var vertices = faceIndices.map(function (index) {\n        return this.targetGeometry.vertices[index];\n    }.bind(this));\n    var edgeA = vertices[0].clone().sub(vertices[1]);\n    var edgeB = vertices[0].clone().sub(vertices[2]);\n    return edgeA.cross(edgeB).normalize();\n};\n//   return sliceGeometry;\n// };\n//# sourceMappingURL=slice.js.map","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n// expose the modules object (__webpack_modules__)\n__webpack_require__.m = __webpack_modules__;\n\n","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","// no baseURI\n\n// object to store loaded and loading chunks\n// undefined = chunk not loaded, null = chunk preloaded/prefetched\n// [resolve, reject, Promise] = chunk loading, 0 = chunk loaded\nvar installedChunks = {\n\t179: 0\n};\n\n// no chunk on demand loading\n\n// no prefetching\n\n// no preloaded\n\n// no HMR\n\n// no HMR manifest\n\n__webpack_require__.O.j = (chunkId) => (installedChunks[chunkId] === 0);\n\n// install a JSONP callback for chunk loading\nvar webpackJsonpCallback = (parentChunkLoadingFunction, data) => {\n\tvar [chunkIds, moreModules, runtime] = data;\n\t// add \"moreModules\" to the modules object,\n\t// then flag all \"chunkIds\" as loaded and fire callback\n\tvar moduleId, chunkId, i = 0;\n\tif(chunkIds.some((id) => (installedChunks[id] !== 0))) {\n\t\tfor(moduleId in moreModules) {\n\t\t\tif(__webpack_require__.o(moreModules, moduleId)) {\n\t\t\t\t__webpack_require__.m[moduleId] = moreModules[moduleId];\n\t\t\t}\n\t\t}\n\t\tif(runtime) var result = runtime(__webpack_require__);\n\t}\n\tif(parentChunkLoadingFunction) parentChunkLoadingFunction(data);\n\tfor(;i < chunkIds.length; i++) {\n\t\tchunkId = chunkIds[i];\n\t\tif(__webpack_require__.o(installedChunks, chunkId) && installedChunks[chunkId]) {\n\t\t\tinstalledChunks[chunkId][0]();\n\t\t}\n\t\tinstalledChunks[chunkIds[i]] = 0;\n\t}\n\treturn __webpack_require__.O(result);\n}\n\nvar chunkLoadingGlobal = self[\"webpackChunkngdg\"] = self[\"webpackChunkngdg\"] || [];\nchunkLoadingGlobal.forEach(webpackJsonpCallback.bind(null, 0));\nchunkLoadingGlobal.push = webpackJsonpCallback.bind(null, chunkLoadingGlobal.push.bind(chunkLoadingGlobal));","// startup\n// Load entry module and return exports\n// This entry module depends on other loaded chunks and execution need to be delayed\nvar __webpack_exports__ = __webpack_require__.O(undefined, [736], () => (__webpack_require__(333)))\n__webpack_exports__ = __webpack_require__.O(__webpack_exports__);\n"],"names":["deferred","Node","linkedList","filterPoints","earcutLinked","isEar","isEarHashed","cureLocalIntersections","splitEarcut","eliminateHoles","compareX","eliminateHole","findHoleBridge","sectorContainsSector","indexCurve","sortLinked","zOrder","getLeftmost","pointInTriangle","isValidDiagonal","area","equals","intersects","onSegment","sign","intersectsPolygon","locallyInside","middleInside","splitPolygon","insertNode","removeNode","signedArea","Object","defineProperty","exports","value","earcut","i","x","y","this","prev","next","z","prevZ","nextZ","steiner","data","start","end","dim","clockwise","last","p","again","ear","triangles","minX","minY","invSize","pass","stop","push","a","b","c","minTX","minTY","maxTX","maxTY","minZ","maxZ","n","holeIndices","outerNode","list","queue","len","length","sort","hole","bridge","bridgeReverse","filteredBridge","m","hx","hy","qx","tan","mx","my","tanMin","Infinity","Math","abs","q","e","tail","numMerges","pSize","qSize","inSize","leftmost","ax","ay","bx","by","cx","cy","px","py","r","p1","p2","q1","q2","o1","o2","o3","o4","max","min","num","inside","a2","b2","an","bp","sum","j","maxX","maxY","hasHoles","outerLen","BumpMapper","THREE","computeVertexNormals_1","GeometryGenerationHelpers_1","applyBumpmap","dildoGeometry","bufferedGeometry","bumpmap","material","options","collectedVertexNormals","computeVertexNormals","dildoNormalGeometry","Geometry","vertices","map","normalLine","endPoint","clone","GeometryGenerationHelpers","normalizeVectorXYZ","bumpmapStrength","dildoNormalsMesh","Points","PointsMaterial","size","color","dildoMesh","console","log","useBumpmap","vertexMatrix","vertIndex","vertex","yRatio","xRatio","lerpFactor","getHeightAt","lerpTarget","lerp","BufferGeometry","fromGeometry","Mesh","DildoGeneration","VertexNormalsHelper_1","DildoGeometry_1","DildoMaterials_1","mergeGeometries_1","PathFinder_1","randomWebColor_1","constants_1","BumpMapper_1","canvasId","canvas","document","getElementById","parent","parentElement","scene","Scene","camera","PerspectiveCamera","window","innerWidth","innerHeight","position","ambientLightA","AmbientLight","set","multiplyScalar","lightDistanceFactor","add","ambientLightB","PointLight","intensityFactor","directionalLightA","DirectionalLight","target","directionalLightB","renderer","WebGLRenderer","preserveDrawingBuffer","antialias","controls","makeOrbitControls","domElement","update","geometries","partialResults","_self","addEventListener","resizeCanvas","animate","requestAnimationFrame","render","prototype","width","documentElement","clientWidth","body","height","clientHeight","style","setAttribute","setSize","setViewOffset","rebuild","removeCachedGeometries","baseRadius","outline","getBounds","baseShape","mkCircularPolygon","shapeSegmentCount","baseShapeExcentricity","DildoGeometry","assign","useTextureImage","textureImagePath","doubleSingleSide","renderFaces","DoubleSide","BackSide","FrontSide","wireframe","DildoMaterials","createMainMaterial","lookAt","Vector3","spineGeometry","spineVertices","forEach","spineVert","addSpine","showBasicPerpendiculars","addPerpendicularPaths","_a","bumpmappedDildoMesh","showBumpmapTargets","addMesh","performSlice","__performPlaneSlice","userData","showNormals","vnHelper","VertexNormalsHelper","normalsLength","latheMesh","latheUnbufferedGeometry","leftPlane","Plane","leftSliceGeometry","makeSlice","rightPlane","rightSliceGeometry","sliceMaterial","createSliceMaterial","planeGeom","PlaneGeometry","planeMesh","MeshBasicMaterial","transparent","opacity","side","rotation","PI","KEY_SPLIT_PANE_MESH","showSplitPane","planeIntersectionPoints","makeAndAddPlaneIntersection","connectedPaths","PathFinder","findAllPathsOnMesh","geometry","geometryVertexIndex","linesMesh_1","Line","LineBasicMaterial","randomWebColor","addPrecalculatedShapeOutlines","pointGeometry","linesMesh","triangulatedGeometries","triangulationGeometry","makePlaneTriangulation","closeCutAreas","mergeGeometries","EPS","showLeftSplit","uvsNeedUpdate","buffersNeedUpdate","slicedMeshLeft","showRightSplit","slicedMeshRight","KEY_LEFT_SLICE_PLANE","KEY_LEFT_SLICE_GEOMETRY","KEY_RIGHT_SLICE_PLANE","KEY_RIGHT_SLICE_GEOMETRY","KEY_PLANE_INTERSECTION_POINTS","KEY_SPLIT_TRIANGULATION_GEOMETRIES","mesh","old","remove","dispose","generateSTL","exporter","stlBuffer","stlData","parse","onComplete","join","warn","extendStatics","__extends","d","setPrototypeOf","__proto__","Array","hasOwnProperty","call","TypeError","String","__","constructor","create","DildoBaseClass","plotboilerplate_1","earcut_typescript_1","UVHelpers_1","DEG_TO_RAD","faces","faceVertexUvs","_super","_this","topIndex","bottomIndex","outerPerpLines","innerPerpLines","flatSidePolygon","leftFlatIndices","rightFlatIndices","leftFlatTriangleIndices","rightFlatTriangleIndices","flatSideBounds","hollowBottomEdgeVertIndices","hollowBottomTriagles","dildoNormals","_buildVertices","_buildFaces","_buildUVMapping","bumpmapTexture","__applyBumpmap","__buildSlice","outlineBounds","outlineVert","sliceIndex","heightT","isBending","bendAngle","arcRadius","shapeTwistAngle","outlineXPct","shapeVert","vert","rotateVertY","_bendVertex","__buildSpine","shapeCenter","__buildPerps","perpendicularVert","normalizePerpendiculars","halfIndices","floor","perpDifference","endVert","rotateVert","outerPerpVert","normalizeVectorXY","Line3","__makeFlatSideVertices","shapeRadius","Polygon","getPerpendicularPathVertices","nextIndex","__makeFlatSideFaces","polygonVertices","flatSideIndex","polygonData","flattenVert2dArray","triangleIndices","makeFace3","includeBottomVert","getInner","getPerpendicularHullLines","perpLines","_getTopVertex","topPoint","_getBottomVertex","axis","angle","applyAxisAngle","applyBumpMap","bumpMapTexture","outlineSegmentCount","closeTop","Boolean","closeBottom","makeHollow","baseShapeSegmentCount","s","addFace4ByIndices","__makeBackFrontFaces","_buildHollowBottomFaces","_buildEndFaces","edgeVertices","edgeVertIndex","findClosestEdgeIndex","tmpDist","index","distance","Number","MAX_VALUE","tmpIndex","distanceTo","lastIndex","curIndex","Face3","endVertexIndex","shapeIndex","inverseFaceDirection","makeFace4","addCylindricUV4","leftA","leftB","leftC","UVHelpers","makeFlatTriangleUVs","rightA","rightB","rightC","ratioI","ratioJ","Vector2","makeHollowBottomUVs","addPyramidalBaseUV3","bendAngleRad","hollowStrengthX","twistAngle","shapeHeight","shapeBounds","getCenter","isNaN","POSITIVE_INFINITY","NEGATIVE_INFINITY","t","getPointAt","getPerpendicularAt","outlineT","topVertex","bottomVertex","xCenter","yCenter","zCenter","thisGeometry","containingPolygonIndices","polygonBounds","Bounds","computeFromVertices","Vertex","getUVRatios","vertA","vertB","vertC","textureStore","Map","MeshLambertMaterial","depthTest","visible","emissive","reflectivity","refractionRatio","loadTextureImage","MeshPhongMaterial","flatShading","vertexColors","path","texture","get","TextureLoader","load","threejs_slice_geometry_1","PlaneMeshIntersection_1","clearDuplicateVertices3_1","vertIndexA","vertIndexB","vertIndexC","vertIndexD","ratioA","ratioB","vertices2d","coordinates","radius","pointCount","excentricity","phi","cos","sin","unbufferedGeometry","plane","slicedGeometry","sliceGeometry","mergeVertices","computeFaceNormals","thisGenerator","planeGeometry","planeGeometryReal","intersectionPoints","PlaneMeshIntersection","getIntersectionPoints","uniqueIntersectionPoints","clearDuplicateVertices3","pointsMaterial","pointsMesh","showSplitShape","triangleGeometry","addRawIntersectionTriangleMesh","triangleMesh","addPrecalculatedMassiveFaces","makeAndAddMassivePlaneIntersection","addPrecalculatedHollowFaces","makeAndAddHollowPlaneIntersection","innerPoint","outerPoint","spineMesh","LineSegments","unbufferedDildoGeometry","addPerpendicularPath","materialColor","outerPerpGeometry","perpLine","outerPerpMesh","generator","connectedPath","currentPathXYData","reduce","earcutInput","trianglesGeometry","vector3","trianglesMesh","KEY_PLANE_INTERSECTION_TRIANGULATION","showSplitShapeTriangulation","base","extend","normalLength","diff","ratio","sqrt","removeAllChildNodes","rootNode","lastChild","removeChild","clamp","imageMap","ImageStore","getImage","image","createElement","onload","isImageLoaded","complete","naturalHeight","undefined","epsilon","visitedVertices","Set","unvisitedVertIndices","numVisitedVertices","pathVertices","collectedPaths","clear","pathVertIndices","mapVerticesToGeometryIndices","_pathVert","nextUnvisitedIndex","values","findUnvisitedPaths","combineAdjacentPaths","unvisitedIndex","adjacentVertIndex","delete","findAdjacentFace","faceCount","f","faceHasVertIndex","pathVertIndex","isVisited","has","resultPaths","unvisitedPathIndexSet","_path","currentPathIndex","currentPath","nextPath","findAdjacentPath","reverse","concat","faceIndex","face","pathVert","foundIndex","foundDist","curDist","currentVertIndex","pointsOfIntersection","mathPlane","localToWorld","planePointA","copy","planePointB","planePointC","setFromCoplanarPoints","lineAB","lineBC","lineCA","__setPointOfIntersection","line","intersectionPoint","intersectLine","pointOfIntersection","result","containsElementFrom","fromIndex","eps","vertexNormals","getAttribute","collectedFaceNormals","faceNormalA","array","faceNormalB","faceNormalC","addVertexNormal","normals","averageNormal","computeAverageVector","buffer","vertexNormal","vectors","avg","nrml","divideScalar","DEFAULT_BEZIER_JSON","globalThis","ngdg","locateVertexInArray","vertArray","closestDist","closestIndex","dist","mergeAndMapVertices","locateVertexInArray_1","baseGeometry","mergeGeometry","vertexMap","uvData","v","mergeVert","indexInBase","defaults_1","ImageStore_1","DildoGeneration_1","WebColorsMalachite_1","WebColorsContrast_1","WebColors_1","colorSet","maxLen","WebColorsMalachite","WebColorsContrast","WebColors","round","random","cssRGB","connectChains","chains","chainA","chainB","merged","chainStart","chainEnd","unshift","apply","reverseChain","mergeChains","chain","edge","validFace","facesFromEdges","edges","changes","filter","joinEdges","slice_1","enumerable","faces_from_edges_1","FRONT","BACK","FACE_KEYS","closeHoles","sliced","builder","GeometryBuilder","distances","positions","findDistance","distanceAsPosition","facePositions","key","indexOf","startFace","lastKey","lastDistance","lastPosition","addIntersection","addVertex","endFace","distanceToPoint","sourceGeometry","targetGeometry","slicePlane","addedVertices","addedIntersections","newEdges","sourceFaceIndex","sourceFace","sourceFaceUvs","faceIndices","faceNormals","faceUvs","indices","addFace","faceNormal","dot","normal","addUv","addNormal","newIndex","keyA","keyB","distanceA","distanceB","addIntersectionUv","addIntersectionNormal","indexA","indexB","id","intersectionId","vertexA","vertexB","newVertex","updateNewEdges","keyIndex","uv","uvA","uvB","normalA","normalB","normalize","pairs","pairA","pairB","faceEdgeLength","bind","slice","indicesA","indicesB","addFacePart","distanceToSquared","edgeIndex","edgeA","sub","edgeB","cross","__webpack_module_cache__","__webpack_require__","moduleId","cachedModule","module","__webpack_modules__","O","chunkIds","fn","priority","notFulfilled","fulfilled","keys","every","splice","definition","o","obj","prop","Symbol","toStringTag","installedChunks","chunkId","webpackJsonpCallback","parentChunkLoadingFunction","moreModules","runtime","some","chunkLoadingGlobal","self","__webpack_exports__"],"sourceRoot":""}