{"version":3,"file":"ngdg-main.min.js","mappings":"uBAAIA,E,iBCSJC,OAAOC,eAAeC,EAAS,aAAc,CAAEC,OAAO,IACtDD,EAAQE,gBAAa,EACrB,IAAIC,EAAQ,EAAQ,KAChBC,EAAyB,EAAQ,KACjCC,EAA8B,EAAQ,KACtCC,EAA2B,EAAQ,KACvCN,EAAQE,WAAa,CACjBK,aAAc,SAAUC,EAAeC,EAAkBC,EAASC,EAAUC,GACxE,IAAIC,GAAyB,EAAIT,EAAuBU,sBAAsBN,EAAeC,GACzFM,EAAsB,IAAIT,EAAyBU,OACvDD,EAAoBE,SAAWJ,EAAuBK,KAAI,SAAUC,GAChE,IAAIC,EAAWD,EAAWE,IAAIC,QAE9B,OADAjB,EAA4BkB,0BAA0BC,mBAAmBL,EAAWM,MAAOL,EAAUR,EAAQc,iBACtGN,KAEX,IAAIO,EAAmB,IAAIxB,EAAMyB,OAAOb,EAAoBc,mBAAoB,IAAI1B,EAAM2B,eAAe,CACrGC,KAAM,IACNC,MAAO,SAMPC,EAAY,KAGhB,GAFAC,QAAQC,IAAI,qBAAsBvB,EAAQwB,WAAY,UAAW1B,GAE7DE,EAAQwB,YAAc1B,EAAS,CAC/B,IAAK,IAAI2B,EAAI,EAAGA,EAAI7B,EAAc8B,aAAaC,OAAQF,IACnD,IAAK,IAAIG,EAAI,EAAGA,EAAIhC,EAAc8B,aAAaD,GAAGE,OAAQC,IAAK,CAC3D,IAAIC,EAAYjC,EAAc8B,aAAaD,GAAGG,GAC1CE,EAASlC,EAAcS,SAASwB,GAChCE,EAAS,EAAMN,GAAK7B,EAAc8B,aAAaC,OAAS,GACxDK,EAASJ,GAAKhC,EAAc8B,aAAaD,GAAGE,OAAS,GACrDM,EAAanC,EAAQoC,YAAYF,EAAQD,GACzCI,EAAahC,EAAoBE,SAASwB,GAC9CC,EAAOM,KAAKD,EAAYF,IAehCpC,EAAmBD,EAAcqB,oBAChBf,uBAEjBmB,EAAY,IAAI9B,EAAM8C,KAAKxC,EAAkBE,GAEjD,MAAO,CAAEsB,UAAWA,EAAWN,iBAAkBA,M,cCnDzD7B,OAAOC,eAAeC,EAAS,aAAc,CAAEC,OAAO,IACtDD,EAAQkD,qBAAkB,EAC1B,IAAI/C,EAAQ,EAAQ,KAChBgD,EAAwB,EAAQ,KAChCC,EAAkB,EAAQ,KAC1BC,EAAmB,EAAQ,KAC3BhD,EAA8B,EAAQ,KACtCiD,EAAoB,EAAQ,KAC5BC,EAAe,EAAQ,IACvBC,EAAmB,EAAQ,KAC3BC,EAAc,EAAQ,KACtBC,EAAe,EAAQ,KACvBpD,EAA2B,EAAQ,KACnC4C,EAAiC,WACjC,SAASA,EAAgBS,EAAU/C,GAC/BgD,KAAKC,OAASC,SAASC,eAAeJ,GACtCC,KAAKI,OAASJ,KAAKC,OAAOI,cAC1BL,KAAKM,MAAQ,IAAI/D,EAAMgE,MACvBP,KAAKQ,OAAS,IAAIjE,EAAMkE,kBAAkB,GAAIC,OAAOC,WAAaD,OAAOE,YAAa,GAAK,KAC3FZ,KAAKQ,OAAOK,SAASC,EAAI,IAGzBd,KAAKe,cAAgB,IAAIxE,EAAMyE,aAAa,SAC5ChB,KAAKe,cAAcF,SAASI,IAAI,IAAK,GAAI,KAAKC,eAAeC,IAG7DnB,KAAKM,MAAMc,IAAIpB,KAAKe,eACpBf,KAAKqB,cAAgB,IAAI9E,EAAM+E,WAAW,SAAUC,EAAuB,KAA6B,IACxGvB,KAAKqB,cAAcR,SAASI,KAAK,IAAK,EAAG,KAAKC,eARpB,IAS1BlB,KAAKM,MAAMc,IAAIpB,KAAKqB,eACpBrB,KAAKwB,kBAAoB,IAAIjF,EAAMkF,iBAAiB,SAAUF,GAE9DvB,KAAKwB,kBAAkBX,SAASI,IAAI,IAAK,IAAK,KAAKC,eAZzB,IAa1BlB,KAAKM,MAAMc,IAAIpB,KAAKwB,mBACpBxB,KAAKM,MAAMc,IAAIpB,KAAKwB,kBAAkBE,QACtC1B,KAAK2B,kBAAoB,IAAIpF,EAAMkF,iBAAiB,SAAUF,GAC9DvB,KAAK2B,kBAAkBd,SAASI,KAAK,KAAM,KAAM,IAAIC,eAhB3B,IAiB1BlB,KAAKM,MAAMc,IAAIpB,KAAK2B,mBACpB3B,KAAK4B,SAAW,IAAIrF,EAAMsF,cAAc,CACpC5B,OAAQD,KAAKC,OACb6B,uBAAuB,EACvBC,WAAW,IAIf/B,KAAKgC,SAAWhF,EAAQiF,kBAAkBjC,KAAKQ,OAAQR,KAAK4B,SAASM,YACrElC,KAAKgC,SAASG,SAEdnC,KAAKoC,WAAa,GAGlBpC,KAAKqC,eAAiB,GAEtBrC,KAAKsC,aAAe,GACpB,IAAIC,EAAQvC,KACZU,OAAO8B,iBAAiB,UAAU,WAC9BD,EAAME,kBAEVzC,KAAKyC,eACL,IAAIC,EAAU,WACVC,sBAAsBD,GACtBH,EAAMP,SAASG,SACfI,EAAMX,SAASgB,OAAOL,EAAMjC,MAAOiC,EAAM/B,SAE7CkC,IAwYJ,OAnYApD,EAAgBuD,UAAUJ,aAAe,WACrC,IAAIK,EAAQpC,OAAOC,YAAcT,SAAS6C,gBAAgBC,aAAe9C,SAAS+C,KAAKD,YACnFE,EAASxC,OAAOE,aAAeV,SAAS6C,gBAAgBI,cAAgBjD,SAAS+C,KAAKE,aAC1FnD,KAAKC,OAAO6C,MAAQA,EACpB9C,KAAKC,OAAOiD,OAASA,EACrBlD,KAAKC,OAAOmD,MAAMN,MAAaA,EAAQ,KACvC9C,KAAKC,OAAOmD,MAAMF,OAAcA,EAAS,KACzClD,KAAKC,OAAOoD,aAAa,QAAcP,EAAQ,MAC/C9C,KAAKC,OAAOoD,aAAa,SAAUH,EAAS,MAC5ClD,KAAK4B,SAAS0B,QAAQR,EAAOI,GAE7BlD,KAAKQ,OAAO+C,cAAcT,EAAOI,EAAQJ,EAAQ,EAAGI,EAAS,GAAIJ,EAAOI,IAgB5E5D,EAAgBuD,UAAUW,QAAU,SAAUxG,GAC1CgD,KAAKyD,yBACLzD,KAAK0D,eACL,IAAIC,EAAa3G,EAAQ4G,QAAQC,YAAYf,MACzCgB,EAAYrH,EAA4BkB,0BAA0BoG,kBAAkBJ,EAAY3G,EAAQgH,kBAAmBhH,EAAQiH,uBAInInH,OAH2C,IAAvBE,EAAQwB,YAA6BxB,EAAQwB,YAGzCxB,EAAQF,QAAUE,EAAQF,QAAU,KAC5DF,EAAgB,IAAI4C,EAAgB0E,cAAchI,OAAOiI,OAAO,CAAEL,UAAWA,GAAmD9G,IAChIoH,EAAkBpH,EAAQoH,sBAAuD,IAA7BpH,EAAQqH,iBAC5DA,OAAuD,IAA7BrH,EAAQqH,iBAAmCrH,EAAQqH,iBAAmB,KAChGC,EAA2C,WAAxBtH,EAAQuH,YAA2BhI,EAAMiI,WAAqC,SAAxBxH,EAAQuH,YAAyBhI,EAAMkI,SAAWlI,EAAMmI,UACjIC,OAAyC,IAAtB3H,EAAQ2H,WAA4B3H,EAAQ2H,UAC/D5H,EAAW0C,EAAiBmF,eAAeC,mBAAmBT,EAAiBO,EAAWN,EAAkBC,GAM5GzH,EAAmBD,EAAcqB,mBACrCpB,EAAiBK,uBAEjB,IAAImB,EAAY,IAAI9B,EAAM8C,KAAKxC,EAAkBE,GACjDiD,KAAKQ,OAAOsE,OAAO,IAAIvI,EAAMwI,QAAQ,GAAI,EAAG,MAC5C/E,KAAKQ,OAAOsE,OAAOzG,EAAUwC,UAC7B,IAAImE,EAAgB,IAAItI,EAAyBU,OAajD,GAZAR,EAAcqI,cAAcC,SAAQ,SAAUC,GAC1CH,EAAc3H,SAAS+H,KAAKD,EAAUzH,YAEtCV,EAAQqI,UACR5I,EAA4BkB,0BAA0B0H,SAASrF,KAAMgF,GAGrEhI,EAAQsI,yBACR7I,EAA4BkB,0BAA0B4H,sBAAsBvF,KAAMpD,GAIlFI,EAAQwB,WAAY,CA0CpB,IAAIgH,EAAK1F,EAAaxD,WAAWK,aAAaC,EAAeC,EAAkBC,EAASC,EAAUC,GAAUyI,EAAsBD,EAAGnH,UAAWN,EAAmByH,EAAGzH,iBACtKM,EAAYoH,EACRzI,EAAQ0I,qBAER3H,EAAiB8C,SAASpC,EAAIoB,EAAY8F,kBAAkBlH,EAC5DuB,KAAK4F,QAAQ7H,IAGrB,GAAIf,EAAQ6I,aACR7F,KAAK8F,oBAAoBzH,EAAWzB,EAAe+H,EAAWP,EAAiBC,EAAkBrH,QASjG,GAHAqB,EAAUwC,SAASpC,EAAIoB,EAAY8F,kBAAkBlH,EACrDJ,EAAU0H,SAAuB,cAAI,EACrC/F,KAAK4F,QAAQvH,GACTrB,EAAQgJ,YAAa,CACrB,IAAIC,EAAW,IAAI1G,EAAsB2G,oBAAoB7H,EAAWrB,EAAQmJ,cAAe,OAE/FnG,KAAKM,MAAMc,IAAI6E,GACfjG,KAAKoC,WAAWgD,KAAKa,KAoBjC3G,EAAgBuD,UAAUiD,oBAAsB,SAAUM,EAAWC,EAAyB1B,EAAWP,EAAiBC,EAAkBrH,GAExI,IAAIsJ,EAAY,IAAI/J,EAAMgK,MAAM,IAAIhK,EAAMwI,QAAQ,EAAG,EAAG,GAAI,GACxDyB,EAAoB/J,EAA4BkB,0BAA0B8I,UAAUJ,EAAyBC,GAC7GI,EAAa,IAAInK,EAAMgK,MAAM,IAAIhK,EAAMwI,QAAQ,EAAG,GAAI,GAAI,GAC1D4B,EAAqBlK,EAA4BkB,0BAA0B8I,UAAUJ,EAAyBK,GAC9GE,EAAgBnH,EAAiBmF,eAAeiC,oBAAoBzC,EAAiBO,EAAWN,GAEhGyC,EAAY,IAAIvK,EAAMwK,cAAc,IAAK,KACzCC,EAAY,IAAIzK,EAAM8C,KAAKyH,EAAW,IAAIvK,EAAM0K,kBAAkB,CAClE7I,MAAO,QACP8I,aAAa,EACbC,QAAS,IACTC,KAAM7K,EAAMiI,cAEhBwC,EAAUK,SAASzI,EAAI0I,KAAKC,GAAK,EACjCvH,KAAKqC,eAAexC,EAAY2H,qBAAuBR,EACnDhK,EAAQyK,gBACRT,EAAUnG,SAASC,EAAI,GACvBd,KAAK4F,QAAQoB,IAUjB,IARA,IAAIU,EAA0BjL,EAA4BkB,0BAA0BgK,4BAA4B3H,KAAMoG,EAAWC,EAAyBW,EAAWF,EAAW9J,GAK5K4K,GAAiB,IAAIjI,EAAakI,YAAaC,mBAAmBtB,EAAmBkB,GAGhFK,EAAI,EAAGA,EAAIH,EAAejJ,OAAQoJ,IAAK,CAM5C,IAAI1K,EAAWuK,EAAeG,GAAGzK,KAAI,SAAU0K,GAC3C,OAAOxB,EAAkBnJ,SAAS2K,MAElCC,EAAWxL,EAA4BkB,0BAA0BuK,yBAAyB7K,GAC1F8K,EAAc,IAAI5L,EAAM6L,KAAKH,EACjC,IAAI1L,EAAM8L,kBAAkB,CACxBjK,OAAO,EAAIwB,EAAiB0I,gBAAgBC,EAAG,YAGnDJ,EAAYtH,SAASpC,EAAIoB,EAAY8F,kBAAkBlH,EAEvDuB,KAAK4F,QAAQuC,GAEjB,GAAInL,EAAQwL,8BAA+B,CAEvC,IAAIC,EAAgB,IAAI/L,EAAyBU,OACjDqL,EAAcpL,SAAWqK,EACzB,IAAIgB,EAAY,IAAInM,EAAM6L,KAAKK,EAAcxK,mBAAoB,IAAI1B,EAAM8L,kBAAkB,CACzFjK,MAAO,WAIXsK,EAAU7H,SAASpC,EAAIoB,EAAY8F,kBAAkBlH,EACrDiK,EAAU7H,SAASC,EAAIjB,EAAY8F,kBAAkB7E,EACrDd,KAAK4F,QAAQ8C,GAIjB,IADA,IAAIC,EAAyB,GACpBJ,EAAI,EAAGA,EAAIX,EAAejJ,OAAQ4J,IAAK,CAC5C,IAAIK,EAAwBnM,EAA4BkB,0BAA0BkL,uBAAuB7I,KAAMwG,EAAmBoB,EAAeW,GAAIvL,GACrJ2L,EAAuBvD,KAAKwD,GAGxB5L,EAAQ8L,iBACR,EAAIpJ,EAAkBqJ,iBAAiBvC,EAAmBoC,EAAuB/I,EAAYmJ,MAC7F,EAAItJ,EAAkBqJ,iBAAiBpC,EAAoBiC,EAAuB/I,EAAYmJ,MAItG,GAAIhM,EAAQiM,cAAe,CACvBzC,EAAkB0C,eAAgB,EAElC1C,EAAkB2C,mBAAoB,EACtC3C,EAAkBtJ,uBAClB,IAAIkM,EAAiB,IAAI7M,EAAM8C,KAAKmH,EAAkBvI,mBAAoB2I,GAa1E,GAVAwC,EAAevI,SAASpC,EAAIoB,EAAY8F,kBAAkBlH,EAC1D2K,EAAevI,SAASC,EAAIjB,EAAY8F,kBAAkB7E,EAM1DsI,EAAerD,SAAuB,cAAI,EAC1C/F,KAAK4F,QAAQwD,GACbpJ,KAAKsC,aAAazC,EAAYwJ,sBAAwBD,EAClDpM,EAAQgJ,YAAa,CACrB,IAAIC,EAAW,IAAI1G,EAAsB2G,oBAAoBkD,EAAgBpM,EAAQmJ,cAAe,OACpGnG,KAAKM,MAAMc,IAAI6E,GACfjG,KAAKoC,WAAWgD,KAAKa,IAG7B,GAAIjJ,EAAQsM,eAAgB,CACxB3C,EAAmBuC,eAAgB,EAEnCvC,EAAmBwC,mBAAoB,EACvCxC,EAAmBzJ,uBACnB,IAAIqM,EAAkB,IAAIhN,EAAM8C,KAAKsH,EAAmB1I,mBAAoB2I,GAQ5E,GALA2C,EAAgB1I,SAASpC,EAAIoB,EAAY8F,kBAAkBlH,EAC3D8K,EAAgB1I,SAASC,GAAKjB,EAAY8F,kBAAkB7E,EAC5DyI,EAAgBxD,SAAuB,cAAI,EAC3C/F,KAAK4F,QAAQ2D,GACbvJ,KAAKsC,aAAazC,EAAY2J,uBAAyBD,EACnDvM,EAAQgJ,YAAa,CACjBC,EAAW,IAAI1G,EAAsB2G,oBAAoBqD,EAAiBvM,EAAQmJ,cAAe,OACrGnG,KAAKM,MAAMc,IAAI6E,GACfjG,KAAKoC,WAAWgD,KAAKa,IAI7BjG,KAAKqC,eAAexC,EAAY4J,sBAAwBnD,EACxDtG,KAAKqC,eAAexC,EAAY6J,yBAA2BlD,EAC3DxG,KAAKqC,eAAexC,EAAY8J,uBAAyBjD,EACzD1G,KAAKqC,eAAexC,EAAY+J,0BAA4BjD,EAC5D3G,KAAKqC,eAAexC,EAAYgK,+BAAiCnC,EACjE1H,KAAKqC,eAAexC,EAAYiK,oCAAsCnB,GA8D1ErJ,EAAgBuD,UAAU+C,QAAU,SAAUmE,GAC1CA,EAAK1C,SAASzI,EAAI0I,KAAKC,GACvBvH,KAAKM,MAAMc,IAAI2I,GACf/J,KAAKoC,WAAWgD,KAAK2E,IAEzBzK,EAAgBuD,UAAUY,uBAAyB,WAC/C,IAAK,IAAI8E,EAAI,EAAGA,EAAIvI,KAAKoC,WAAWzD,OAAQ4J,IAAK,CAC7C,IAAIyB,EAAMhK,KAAKoC,WAAWmG,GAG1BvI,KAAKM,MAAM2J,OAAOD,GAGdA,aAAezN,EAAM8C,OACrB2K,EAAI/B,SAASiC,UACbF,EAAIjN,SAASmN,WAGrBlK,KAAKoC,WAAa,IAEtB9C,EAAgBuD,UAAUa,aAAe,WACrC1D,KAAKsC,aAAazC,EAAY2J,uBAAyB,KACvDxJ,KAAKsC,aAAazC,EAAYwJ,sBAAwB,KACtDrJ,KAAKqC,eAAexC,EAAY4J,sBAAwB,KACxDzJ,KAAKqC,eAAexC,EAAY6J,yBAA2B,KAC3D1J,KAAKqC,eAAexC,EAAY8J,uBAAyB,KACzD3J,KAAKqC,eAAexC,EAAY+J,0BAA4B,KAC5D5J,KAAKqC,eAAexC,EAAYgK,+BAAiC,KACjE7J,KAAKqC,eAAexC,EAAYiK,oCAAsC,MAO1ExK,EAAgBuD,UAAUsH,YAAc,SAAUnN,EAASoN,GAEvD,IAAIC,EAAY,GAEhB,IAAK,IAAI9B,KAAKvI,KAAKoC,WACf,IAAoD,IAAhDpC,KAAKoC,WAAWmG,GAAGxC,SAAuB,aAAY,CACtD,IAAIuE,EAAUF,EAASG,MAAMvK,KAAKoC,WAAWmG,IAC7C8B,EAAUjF,KAAKkF,GAGW,mBAAvBtN,EAAQwN,WACfxN,EAAQwN,WAAWH,EAAUI,KAAK,SAGlCnM,QAAQoM,KAAK,qEAGdpL,EA3byB,GA6bpClD,EAAQkD,gBAAkBA,G,oBC5c1B,IACQqL,EADJC,EAAa5K,MAAQA,KAAK4K,YACtBD,EAAgB,SAAUE,EAAGC,GAI7B,OAHAH,EAAgBzO,OAAO6O,gBAClB,CAAEC,UAAW,cAAgBC,OAAS,SAAUJ,EAAGC,GAAKD,EAAEG,UAAYF,IACvE,SAAUD,EAAGC,GAAK,IAAK,IAAI/C,KAAK+C,EAAO5O,OAAO2G,UAAUqI,eAAeC,KAAKL,EAAG/C,KAAI8C,EAAE9C,GAAK+C,EAAE/C,KACzF4C,EAAcE,EAAGC,IAErB,SAAUD,EAAGC,GAChB,GAAiB,mBAANA,GAA0B,OAANA,EAC3B,MAAM,IAAIM,UAAU,uBAAyBC,OAAOP,GAAK,iCAE7D,SAASQ,IAAOtL,KAAKuL,YAAcV,EADnCF,EAAcE,EAAGC,GAEjBD,EAAEhI,UAAkB,OAANiI,EAAa5O,OAAOsP,OAAOV,IAAMQ,EAAGzI,UAAYiI,EAAEjI,UAAW,IAAIyI,KAGvFpP,OAAOC,eAAeC,EAAS,aAAc,CAAEC,OAAO,IACtDD,EAAQ8H,mBAAgB,EAOxB,IAAIuH,EAAoB,EAAQ,KAC5BlP,EAAQ,EAAQ,KAChBE,EAA8B,EAAQ,KACtCiP,EAAsB,EAAQ,IAC9BC,EAAc,EAAQ,KACtBC,EAAQ,EAAQ,KAChBC,EAAavE,KAAKC,GAAK,IAoBvBrD,EAA+B,SAAU4H,GAYzC,SAAS5H,EAAclH,GACnB,IAAI+O,EAAQD,EAAOX,KAAKnL,OAASA,KAoCjC,OAjCA4L,EAAMxO,OAAO+N,KAAKY,GAClBA,EAAMrN,aAAe,GACrBqN,EAAMC,UAAY,EAClBD,EAAME,aAAe,EACrBF,EAAM9G,cAAgB,GACtB8G,EAAMG,eAAiB,GACvBH,EAAMI,eAAiB,GACvBJ,EAAMK,gBAAkB,KACxBL,EAAMM,gBAAkB,GACxBN,EAAMO,iBAAmB,GACzBP,EAAMQ,wBAA0B,GAChCR,EAAMS,yBAA2B,GACjCT,EAAMU,eAAiB,KAEvBV,EAAMW,4BAA8B,GACpCX,EAAMY,qBAAuB,GAC7BZ,EAAMa,aAAe,GACrBb,EAAMc,eAAe7P,GACrB+O,EAAMe,YAAY9P,GAClB+O,EAAMgB,gBAAgB/P,GAMlBA,EAAQwB,aACJxB,EAAQgQ,eACRjB,EAAMkB,eAAejQ,EAAQgQ,gBAG7B1O,QAAQoM,KAAK,uFAGdqB,EA2uBX,OA3xBAnB,EAAU1G,EAAe4H,GAkEzB5H,EAAcrB,UAAUqK,aAAe,SAAUpJ,EAAWqJ,EAAeC,EAAaC,EAAYC,EAASC,EAAWC,EAAWC,EAAWC,GAI1I,IAHA,IAAIC,GAAeR,EAAcS,IAAIhP,EAAIwO,EAAYxO,GAAKuO,EAAcrK,MAG/DyF,EAAI,EAAGA,EAAIzE,EAAUzG,SAASsB,OAAQ4J,IAAK,CAChD,IAAIsF,EAAY/J,EAAUzG,SAASkL,GACnC,GAAIgF,EAAW,CACX,IAAIO,EAAO,IAAIvR,EAAMwI,QAAQ8I,EAAUjP,EAAI+O,EAAa,EAAGE,EAAUpP,EAAIkP,GAEzEI,EAAYD,EAAMJ,EAAiB,EAAG,GACtC1N,KAAKgO,YAAYF,EAAMN,EAAWC,EAAWH,GAC7CQ,EAAKrP,GAAK0O,EAAcS,IAAInP,MAE3B,CACGqP,EAAO,IAAIvR,EAAMwI,QAAQ8I,EAAUjP,EAAI+O,EAAaP,EAAY3O,EAAGoP,EAAUpP,EAAIkP,GAErFI,EAAYD,EAAMJ,EAAiB,EAAG,GAE1C1N,KAAKtB,aAAa2O,GAAY9E,GAAKvI,KAAK3C,SAASsB,OACjDqB,KAAK3C,SAAS+H,KAAK0I,GACD,GAAdT,IACS,GAAL9E,GACOuF,EAAKrP,EACZ8J,EAAI,GAAKzE,EAAUzG,SAASsB,QACrBmP,EAAKrP,KAmB5ByF,EAAcrB,UAAUoL,aAAe,SAAUC,EAAaf,EAAeC,EAAaE,EAASC,EAAWC,EAAWC,GACrH,IAAIE,GAAeR,EAAcS,IAAIhP,EAAIwO,EAAYxO,GAAKuO,EAAcrK,MAEpEqC,EAAY+I,EAAYxQ,QAC5B,GAAI6P,EAAW,CACX,IAAIO,EAAO,IAAIvR,EAAMwI,QAAQI,EAAUvG,EAAI+O,EAAa,EAAGxI,EAAU1G,EAAIkP,GACzE3N,KAAKgO,YAAYF,EAAMN,EAAWC,EAAWH,GAC7CQ,EAAKrP,GAAK0O,EAAcS,IAAInP,OAGxBqP,EAAO,IAAIvR,EAAMwI,QAAQI,EAAUvG,EAAI+O,EAAaP,EAAY3O,EAAG0G,EAAU1G,EAAIkP,GAEzF3N,KAAKiF,cAAcG,KAAK0I,IAgB5B5J,EAAcrB,UAAUsL,aAAe,SAAUrK,EAAWqJ,EAAeC,EAC3EgB,EAAmBd,EAASC,EAAWC,EAAWC,EAAWY,EAAyBlI,GAGlF,IAFA,IAAIwH,GAAeR,EAAcS,IAAIhP,EAAIwO,EAAYxO,GAAKuO,EAAcrK,MACpEwL,EAAc,CAAC,EAAGhH,KAAKiH,MAAMzK,EAAUzG,SAASsB,OAAS,IACpD6P,EAAI,EAAGA,EAAIF,EAAY3P,OAAQ6P,IAAK,CACzC,IAAIjG,EAAI+F,EAAYE,GAChBX,EAAY/J,EAAUzG,SAASkL,GACnC,GAAIgF,EAAW,CACX,IAAIO,EAAO,IAAIvR,EAAMwI,QAAQ8I,EAAUjP,EAAI+O,EAAa,EAAGE,EAAUpP,EAAIkP,GACzE3N,KAAKgO,YAAYF,EAAMN,EAAWC,EAAWH,GAC7CQ,EAAKrP,GAAK0O,EAAcS,IAAInP,OAGxBqP,EAAO,IAAIvR,EAAMwI,QAAQ8I,EAAUjP,EAAI+O,EAAaP,EAAY3O,EAAGoP,EAAUpP,EAAIkP,GAEzF,IAAIc,EAAiB,IAAIlS,EAAMwI,QAAQqI,EAAYxO,EAAIwP,EAAkBxP,EAAGwO,EAAY3O,EAAI2P,EAAkB3P,EAAG,GAEjH,GAAS,GAAL8J,EACA,IAAImG,EAAU,IAAInS,EAAMwI,QAAQ+I,EAAKlP,EAAIwP,EAAkBxP,EAAGkP,EAAKrP,EAAI2P,EAAkB3P,EAAG,QAExFiQ,EAAU,IAAInS,EAAMwI,QAAQ+I,EAAKlP,EAAIwP,EAAkBxP,EAAGkP,EAAKrP,EAAI2P,EAAkB3P,EAAG,GAChGkQ,EAAWD,EAASlB,EAAYF,EAASQ,EAAKlP,EAAGkP,EAAKrP,GACtD,IAAImQ,EAAgBd,EAAKpQ,QACzBkR,EAAchQ,GAAK6P,EAAe7P,EAClCgQ,EAAcnQ,GAAKgQ,EAAehQ,EAClCmQ,EAAc9N,GAAK2N,EAAe3N,EAC9BuN,GACA5R,EAA4BkB,0BAA0BkR,kBAAkBf,EAAMY,EAASvI,GAElF,GAALoC,EACAvI,KAAKkM,eAAe9G,KAAK,IAAI7I,EAAMuS,MAAMhB,EAAMY,IAG/C1O,KAAKmM,eAAe/G,KAAK,IAAI7I,EAAMuS,MAAMhB,EAAMY,MA0H3DxK,EAAcrB,UAAUkM,uBAAyB,SAAUC,GASvDhP,KAAKoM,gBAAkB,IAAIX,EAAkBwD,QAAQjP,KAAKkP,8BAA6B,IAAO,GAC9FlP,KAAKyM,eAAiBzM,KAAKoM,gBAAgBvI,YAE3C,IAAK,IAAI0E,EAAI,EAAGA,EAAIvI,KAAKoM,gBAAgB/O,SAASsB,OAAQ4J,IAAK,CAC3D,IAAI4G,EAAYnP,KAAK3C,SAASsB,OAC9BqB,KAAKqM,gBAAgBjH,KAAK+J,GAC1BnP,KAAK3C,SAAS+H,KAAK,IAAI7I,EAAMwI,QAAQ/E,KAAKoM,gBAAgB/O,SAASkL,GAAG3J,EAAGoB,KAAKoM,gBAAgB/O,SAASkL,GAAG9J,EAAGuQ,IACnG,IAANzG,GAAWA,EAAI,IAAMvI,KAAKoM,gBAAgB/O,SAASsB,QAAU4J,EAAI,IAAMvI,KAAKoM,gBAAgB/O,SAASsB,QAErGqB,KAAK0M,4BAA4BtH,KAAK+J,GAG9C,IAAS5G,EAAI,EAAGA,EAAIvI,KAAKoM,gBAAgB/O,SAASsB,OAAQ4J,IAAK,CACvD4G,EAAYnP,KAAK3C,SAASsB,OAC9BqB,KAAKsM,iBAAiBlH,KAAK+J,GAC3BnP,KAAK3C,SAAS+H,KAAK,IAAI7I,EAAMwI,QAAQ/E,KAAKoM,gBAAgB/O,SAASkL,GAAG3J,EAAGoB,KAAKoM,gBAAgB/O,SAASkL,GAAG9J,GAAIuQ,IACpG,IAANzG,GAAWA,EAAI,IAAMvI,KAAKoM,gBAAgB/O,SAASsB,QAAU4J,EAAI,IAAMvI,KAAKoM,gBAAgB/O,SAASsB,QAErGqB,KAAK0M,4BAA4BtH,KAAK+J,KAWlDjL,EAAcrB,UAAUuM,oBAAsB,WAiB1C,IAVA,IAAI7M,EAAQvC,KAERqP,EAAkBrP,KAAKqM,gBAAgB/O,KAAI,SAAUgS,GACrD,OAAO/M,EAAMlF,SAASiS,MAEtBC,EAAc9S,EAA4BkB,0BAA0B6R,mBAAmBH,GAEvFI,GAAkB,EAAI/D,EAAoBgE,QAAQH,GAG7ChH,EAAI,EAAGA,EAAI,EAAIkH,EAAgB9Q,OAAQ4J,GAAK,EAAG,CACpD,IAAIoH,EAAIF,EAAgBlH,GACpBuC,EAAI2E,EAAgBlH,EAAI,GACxBqH,EAAIH,EAAgBlH,EAAI,GAC5B9L,EAA4BkB,0BAA0BkS,UAAU7P,KAAMA,KAAKqM,gBAAgBsD,GAAI3P,KAAKqM,gBAAgBvB,GAAI9K,KAAKqM,gBAAgBuD,IAC7I5P,KAAKuM,wBAAwBnH,KAAK,CAACpF,KAAKqM,gBAAgBsD,GAAI3P,KAAKqM,gBAAgBvB,GAAI9K,KAAKqM,gBAAgBuD,KAE9G,IAASrH,EAAI,EAAGA,EAAI,EAAIkH,EAAgB9Q,OAAQ4J,GAAK,EAAG,CAChDoH,EAAIF,EAAgBlH,GACpBuC,EAAI2E,EAAgBlH,EAAI,GACxBqH,EAAIH,EAAgBlH,EAAI,GAC5B9L,EAA4BkB,0BAA0BkS,UAAU7P,KAAMA,KAAKsM,iBAAiBqD,GAAI3P,KAAKsM,iBAAiBsD,GAAI5P,KAAKsM,iBAAiBxB,IAChJ9K,KAAKwM,yBAAyBpH,KAAK,CAACpF,KAAKsM,iBAAiBqD,GAAI3P,KAAKsM,iBAAiBxB,GAAI9K,KAAKsM,iBAAiBsD,OAGtH1L,EAAcrB,UAAUqM,6BAA+B,SAAUY,EAAmBC,GAGhF,IADA,IAAIV,EAAkB,GACb9G,EAAI,EAAGA,EAAIvI,KAAKmM,eAAexN,OAAQ4J,IAC5C8G,EAAgBjK,KAAK2K,EAAW/P,KAAKmM,eAAe5D,GAAG1K,MAAQmC,KAAKmM,eAAe5D,GAAG9K,KAG1F,IAAS8K,EAAIvI,KAAKkM,eAAevN,OAAS,EAAG4J,GAAK,EAAGA,IACjD8G,EAAgBjK,KAAK2K,EAAW/P,KAAKkM,eAAe3D,GAAG1K,MAAQmC,KAAKkM,eAAe3D,GAAG9K,KAM1F,OAHIqS,GACAT,EAAgBjK,KAAKpF,KAAK3C,SAAS2C,KAAKiM,cAErCoD,GAEXnL,EAAcrB,UAAUmN,0BAA4B,WAGhD,IADA,IAAIC,EAAY,GACP1H,EAAI,EAAGA,EAAIvI,KAAKmM,eAAexN,OAAQ4J,IAC5C0H,EAAU7K,KAAKpF,KAAKmM,eAAe5D,IAGvC,IAASA,EAAIvI,KAAKkM,eAAevN,OAAS,EAAG4J,GAAK,EAAGA,IACjD0H,EAAU7K,KAAKpF,KAAKkM,eAAe3D,IAEvC,OAAO0H,GAWX/L,EAAcrB,UAAUqN,cAAgB,SAAU/C,EAAeI,EAAWC,EAAWC,GACnF,GAAIF,EAAW,CACX,IAAI4C,EAAW,IAAI5T,EAAMwI,QAAQ,EAAG,EAAG,GAGvC,OAFA/E,KAAKgO,YAAYmC,EAAU3C,EAAWC,EAAW,GACjD0C,EAAS1R,GAAK0O,EAAcS,IAAInP,EACzB0R,EAGP,OAAO,IAAI5T,EAAMwI,QAAQ,EAAGoI,EAAciD,IAAI3R,EAAG,IAUzDyF,EAAcrB,UAAUwN,iBAAmB,SAAUlD,GAMjD,OALkB,IAAI5Q,EAAMwI,QAAQ,EAAGoI,EAAcS,IAAInP,EAAG,IAehEyF,EAAcrB,UAAUmL,YAAc,SAAUF,EAAMN,EAAWC,EAAWH,GACxE,IAAIgD,EAAO,IAAI/T,EAAMwI,QAAQ,EAAG,EAAG,GAC/BwL,EAAQ/C,EAAYF,EAGxBQ,EAAKlP,GAAK6O,EACVK,EAAK0C,eAAeF,EAAMC,GAC1BzC,EAAKlP,GAAK6O,GA4DdvJ,EAAcrB,UAAU4N,aAAe,SAAUC,GAE7C,IAAK,IAAInI,EAAI,EAAGA,EAAIvI,KAAKtB,aAAaC,OAAQ4J,IAC1C,IAAK,IAAIiG,EAAI,EAAGA,EAAIxO,KAAKtB,aAAa6J,GAAG5J,OAAQ6P,IAC7C,KAAI3P,EAAYmB,KAAKtB,aAAa6J,GAAGiG,GACxBxO,KAAK3C,SAASwB,KASvCqF,EAAcrB,UAAUiK,YAAc,SAAU9P,GAC5C,IAAI8G,EAAY9G,EAAQ8G,UACpB6M,EAAsB3T,EAAQ2T,oBAC9BC,EAAWC,QAAQ7T,EAAQ4T,UAC3BE,EAAcD,QAAQ7T,EAAQ8T,aAC9BC,EAAaF,QAAQ7T,EAAQ+T,YAC7BC,EAAwBlN,EAAUzG,SAASsB,OAC/CqB,KAAKiR,cAAc,GAAK,GACxB,IAAK,IAAIC,EAAI,EAAGA,EAAIP,EAAqBO,IACrC,IAAK,IAAI3I,EAAI,EAAGA,EAAIyI,EAAuBzI,IACnC2I,EAAI,GACA3I,EAAI,IACJvI,KAAKmR,kBAAkBD,EAAG3I,EAAI,EAAG2I,EAAI,EAAG3I,EAAGwI,GACvCxI,EAAI,GAAKzE,EAAUzG,SAASsB,QAE5BqB,KAAKmR,kBAAkBD,EAAG3I,EAAG2I,EAAI,EAAG,EAAGH,IAMvDA,IACA/Q,KAAKoP,sBACLpP,KAAKoR,wBAELN,IACIC,EACA/Q,KAAKqR,0BAELrR,KAAKsR,eAAetR,KAAKiM,YAAa,EAAG+E,GAAuB,IAEpEJ,GACA5Q,KAAKsR,eAAetR,KAAKgM,SAAUhM,KAAKtB,aAAaC,OAAS,EAAGqS,EAAuBD,IAGhG7M,EAAcrB,UAAUwO,wBAA0B,WAwB9C,IAvBA,IAqBI5B,EArBAlN,EAAQvC,KACRuR,EAAevR,KAAK0M,4BAA4BpP,KAAI,SAAUkU,GAC9D,OAAOjP,EAAMlF,SAASmU,MAEtBC,EAAuB,SAAU3D,GAKjC,IAHA,IAEI4D,EAFAC,EAAQ,EACRC,EAAWC,OAAOC,UAEbvJ,EAAI,EAAGA,EAAIgJ,EAAa5S,OAAQ4J,IAAK,CAC1C,IAAIwJ,EAAWxP,EAAMmK,4BAA4BnE,IAC5CmJ,EAAUH,EAAahJ,GAAGyJ,WAAWlE,IAAS8D,IAC/CD,EAAQI,EACRH,EAAWF,GAGnB,OAAOC,GAGPM,EAAIjS,KAAKtB,aAAa,GAAGC,OACzBuT,EAAYT,EAAqBzR,KAAK3C,SAAS4U,EAAI,IAG9C1J,EAAI,EAAGA,EAAI0J,EAAG1J,IAAK,CACxB,IAAI4J,EAAWV,EAAqBzR,KAAK3C,SAAS2C,KAAKtB,aAAa,GAAG6J,KAEvEkH,EAAkB,CAACyC,EAAWlS,KAAKtB,aAAa,GAAQ,GAAL6J,EAAS0J,EAAI,EAAI1J,EAAI,GAAIvI,KAAKtB,aAAa,GAAG6J,IACjGvI,KAAKoS,MAAMhN,KAAK,IAAIwG,EAAMyG,MAAM5C,EAAgB,GAAIA,EAAgB,GAAIA,EAAgB,KACxFzP,KAAK2M,qBAAqBvH,KAAKqK,GAC3ByC,IAAcC,IAEd1C,EAAkB,CAAC0C,EAAUD,EAAWlS,KAAKtB,aAAa,GAAG6J,IAC7DvI,KAAKoS,MAAMhN,KAAK,IAAIwG,EAAMyG,MAAM5C,EAAgB,GAAIA,EAAgB,GAAIA,EAAgB,KACxFzP,KAAK2M,qBAAqBvH,KAAKqK,IAEnCyC,EAAYC,IAYpBjO,EAAcrB,UAAUyO,eAAiB,SAAUgB,EAAgBC,EAAYvB,EAAuBwB,GAElG,IAAK,IAAIjK,EAAI,EAAGA,EAAIyI,EAAuBzI,IACvC9L,EAA4BkB,0BAA0BkS,UAAU7P,KAAMA,KAAKtB,aAAa6T,GAAYhK,EAAI,GAAI+J,EAAgBtS,KAAKtB,aAAa6T,GAAYhK,GAAIiK,GAC1JjK,EAAI,GAAKyI,GACTvU,EAA4BkB,0BAA0BkS,UAAU7P,KAAMA,KAAKtB,aAAa6T,GAAYhK,GAAI+J,EAAgBtS,KAAKtB,aAAa6T,GAAY,GAAIC,IAStKtO,EAAcrB,UAAUuO,qBAAuB,WAE3C,IAAK,IAAI7I,EAAI,EAAGA,EAAI,EAAIvI,KAAKoM,gBAAgB/O,SAASsB,OAAQ4J,IAC1D9L,EAA4BkB,0BAA0B8U,UAAUzS,KAAMA,KAAKqM,gBAAgB9D,GAAIvI,KAAKqM,gBAAgB9D,EAAI,GAAIvI,KAAKsM,iBAAiB/D,GAAIvI,KAAKsM,iBAAiB/D,EAAI,KAWxLrE,EAAcrB,UAAUkK,gBAAkB,SAAU/P,GAQhD,IAPA,IAAI8G,EAAY9G,EAAQ8G,UACpB6M,EAAsB3T,EAAQ2T,oBAC9BK,EAAwBlN,EAAUzG,SAASsB,OAC3CiS,EAAWC,QAAQ7T,EAAQ4T,UAC3BE,EAAcD,QAAQ7T,EAAQ8T,aAC9BC,EAAaF,QAAQ7T,EAAQ+T,YAExBG,EAAI,EAAGA,EAAIP,EAAqBO,IACrC,IAAK,IAAI3I,EAAI,EAAGA,EAAIzE,EAAUzG,SAASsB,OAAQ4J,IAC3C9L,EAA4BkB,0BAA0B+U,gBAAgB1S,KAAMkR,EAAG3I,EAAI,EAAG2I,EAAI,EAAG3I,EAAGoI,EAAqBK,EAAuBD,GACxIxI,EAAI,GAAKzE,EAAUzG,SAASsB,QAE5BlC,EAA4BkB,0BAA0B+U,gBAAgB1S,KAAMkR,EAAG3I,EAAI,EAAG2I,EAAI,EAAG3I,EAAGoI,EAAqBK,EAAuBD,GAIxJ,GAAIA,EAAY,CAGZ,IAASxI,EAAI,EAAGA,EAAIvI,KAAKuM,wBAAwB5N,OAAQ4J,IAAK,CAC1D,IAAIoK,EAAQ3S,KAAKuM,wBAAwBhE,GAAG,GACxCqK,EAAQ5S,KAAKuM,wBAAwBhE,GAAG,GACxCsK,EAAQ7S,KAAKuM,wBAAwBhE,GAAG,GAC5CoD,EAAYmH,UAAUC,oBAAoB/S,KAAMA,KAAKyM,eAAgBkG,EAAOC,EAAOC,GAGvF,IAAStK,EAAI,EAAGA,EAAIvI,KAAKwM,yBAAyB7N,OAAQ4J,IAAK,CAG3D,IAAIyK,EAAShT,KAAKwM,yBAAyBjE,GAAG,GAC1C0K,EAASjT,KAAKwM,yBAAyBjE,GAAG,GAC1C2K,EAASlT,KAAKwM,yBAAyBjE,GAAG,GAC9CoD,EAAYmH,UAAUC,oBAAoB/S,KAAMA,KAAKyM,eAAgBuG,EAAQC,EAAQC,GAGzF,IAAS3K,EAAI,EAAGA,EAAI,EAAIvI,KAAKoM,gBAAgB/O,SAASsB,OAAQ4J,IAAK,CAC/D,IAAI4K,GAAU5K,EAAI,IAAMvI,KAAKoM,gBAAgB/O,SAASsB,OAAS,GAC3DyU,EAAS7K,GAAKvI,KAAKoM,gBAAgB/O,SAASsB,OAAS,GACzDqB,KAAKiR,cAAc,GAAG7L,KAAK,CACvB,IAAI7I,EAAM8W,QAAQ,EAAKD,GACvB,IAAI7W,EAAM8W,QAAQ,EAAKF,GACvB,IAAI5W,EAAM8W,QAAQ,EAAKD,KAE3BpT,KAAKiR,cAAc,GAAG7L,KAAK,CACvB,IAAI7I,EAAM8W,QAAQ,EAAKF,GACvB,IAAI5W,EAAM8W,QAAQ,EAAKF,GACvB,IAAI5W,EAAM8W,QAAQ,EAAKD,MAKnC,GAAItC,EACA,GAAIC,EACAuC,EAAoBtT,KAAMA,KAAK0M,4BAA6B1M,KAAK2M,2BAGjE,IAASpE,EAAI,EAAGA,EAAIyI,EAAuBzI,IACvC9L,EAA4BkB,0BAA0B4V,oBAAoBvT,KAAMuI,EAAI,EAAGyI,GACnFzI,EAAI,GAAKyI,GAETvU,EAA4BkB,0BAA0B4V,oBAAoBvT,KAAMuI,EAAI,EAAGyI,GAMvG,GAAIJ,EACA,KAAIsB,EAAYvB,EAAsB,EACtC,IAASpI,EAAI,EAAGA,EAAIyI,EAAuBzI,IACvC9L,EAA4BkB,0BAA0B4V,oBAAoBvT,KAAMuI,EAAI,EAAGyI,GACnFzI,EAAI,GAAKyI,GAETvU,EAA4BkB,0BAA0B4V,oBAAoBvT,KAAMkS,EAAWlB,GAIvGhR,KAAKkJ,eAAgB,GAoBzBhF,EAAcrB,UAAUsO,kBAAoB,SAAUxB,EAAG7E,EAAG8E,EAAG/E,EAAG2H,GAC9D/V,EAA4BkB,0BAA0B8U,UAAUzS,KAAMA,KAAKtB,aAAaiR,GAAG7E,GAAI9K,KAAKtB,aAAakR,GAAG9E,GAAI9K,KAAKtB,aAAaiR,GAAG9E,GAAI7K,KAAKtB,aAAakR,GAAG/E,GAAI2H,IAO9KtO,EAAcrB,UAAUgK,eAAiB,SAAU7P,GAqB/C,IApBA,IAAI8G,EAAY9G,EAAQ8G,UACpBF,EAAU5G,EAAQ4G,QAClB+M,EAAsB3T,EAAQ2T,oBAC9BI,EAAaF,QAAQ7T,EAAQ+T,YAC7ByC,EAAgBxW,EAAQwQ,UAAY,IAAOlG,KAAKC,GAChDkM,EAAkBzW,EAAQyW,gBAC1BC,EAAa1W,EAAQ0W,WAAa7H,EAClCwC,EAA0BwC,QAAQ7T,EAAQqR,yBAC1ClI,OAAiD,IAA1BnJ,EAAQmJ,cAAgCnJ,EAAQmJ,cAAgB,GACvFgH,EAAgBvJ,EAAQC,YACxB8P,EAAcxG,EAAcjK,OAC5B0Q,EAAc9P,EAAUD,YACxBqK,EAAc0F,EAAYC,YAE1BpG,EADYkG,EACYH,EACxBjG,EAAYvQ,EAAQuQ,YACnBuG,MAAMrG,IACPA,IAAcoE,OAAOkC,mBACrBtG,IAAcoE,OAAOmC,mBACrB1M,KAAK2M,IAAIT,GAAgB,IACpBtC,EAAI,EAAGA,EAAIP,EAAqBO,IAAK,CAC1C,IAAIgD,EAAI5M,KAAK8I,IAAI,EAAK9I,KAAKsG,IAAI,EAAKsD,GAAKP,EAAsB,KAC/D3Q,KAAKtB,aAAawS,GAAK,GACvB,IAAI9D,EAAcxJ,EAAQuQ,WAAWD,GACjC9F,EAAoBxK,EAAQwQ,mBAAmBF,GAC/C5G,GAAWH,EAAcS,IAAInP,EAAI2O,EAAY3O,GAAKkV,EAClDU,EAAWnD,GAAKP,EAAsB,GAC1C3Q,KAAKkN,aAAapJ,EAAWqJ,EAAeC,EAAa8D,EAAG5D,EAASC,EAAWiG,EAAc/F,EAAWiG,EAAaW,GACtHrU,KAAKiO,aAAaC,EAAaf,EAAeC,EAAaE,EAASC,EAAWiG,EAAc/F,GAC7FzN,KAAKmO,aAAarK,EAAWqJ,EAAeC,EAAagB,EAAmBd,EAASC,EAAWiG,EAAc/F,EAAWY,EAAyBlI,GAetJ,IAAImO,EAAYtU,KAAKkQ,cAAc/C,EAAeI,EAAWiG,EAAc/F,GACvE8G,EAAevU,KAAKqQ,iBAAiBlD,GACzCnN,KAAKgM,SAAWhM,KAAK3C,SAASsB,OAC9BqB,KAAK3C,SAAS+H,KAAKkP,GACnBtU,KAAKiM,YAAcjM,KAAK3C,SAASsB,OACjCqB,KAAK3C,SAAS+H,KAAKmP,GACfxD,GAEA/Q,KAAK+O,uBAAuBzH,KAAKsG,IAAIgG,EAAY9Q,MAAO8Q,EAAY1Q,QAAU,EAAMuQ,IAG5FvP,EAAcrB,UAAUoK,eAAiB,SAAUD,GAE/C,IADA,IACSzE,EAAI,EAAGA,EAAIvI,KAAKtB,aAAaC,OAAQ4J,IAC1C,IAAK,IAAIiG,EAAI,EAAGA,EAAIxO,KAAKtB,aAAa6J,GAAG5J,OAAQ6P,OAMlDtK,EA5xBuB,CA6xBhC0H,EAAMxO,QACRhB,EAAQ8H,cAAgBA,EAExB,IAAIyK,EAAa,SAAUb,EAAMyC,EAAOiE,EAASC,GAC7C,IAAInE,EAAO,IAAI/T,EAAMwI,QAAQ,EAAG,EAAG,GAMnC,OALA+I,EAAKlP,GAAK4V,EACV1G,EAAKrP,GAAKgW,EACV3G,EAAK0C,eAAeF,EAAMC,GAC1BzC,EAAKlP,GAAK4V,EACV1G,EAAKrP,GAAKgW,EACH3G,GAYPC,EAAc,SAAUD,EAAMyC,EAAOiE,EAASE,GAC9C,IAAIpE,EAAO,IAAI/T,EAAMwI,QAAQ,EAAG,EAAG,GAMnC,OALA+I,EAAKlP,GAAK4V,EACV1G,EAAKhN,GAAK4T,EACV5G,EAAK0C,eAAeF,EAAMC,GAC1BzC,EAAKlP,GAAK4V,EACV1G,EAAKhN,GAAK4T,EACH5G,GAuCPwF,EAAsB,SAAUqB,EAAcC,EAA0BC,GAUxE,IARA,IAAIC,EAAgBrJ,EAAkBsJ,OAAOC,oBAAoBJ,EAAyBtX,KAAI,SAAUuB,GACpG,OAAO,IAAI4M,EAAkBwJ,OAAON,EAAatX,SAASwB,GAAWD,EAAG+V,EAAatX,SAASwB,GAAWiC,OAEzGoU,EAAc,SAAUpH,GAExB,OAAO,IAAIvR,EAAM8W,SAASvF,EAAKlP,EAAIkW,EAAc1E,IAAIxR,GAAKkW,EAAchS,OAAQgL,EAAKhN,EAAIgU,EAAc1E,IAAI3R,GAAKqW,EAAc5R,SAGzHgR,EAAI,EAAGA,EAAIW,EAAUlW,OAAQuV,IAAK,CACvC,IAAIiB,EAAQR,EAAatX,SAASwX,EAAUX,GAAG,IAC3CkB,EAAQT,EAAatX,SAASwX,EAAUX,GAAG,IAC3CmB,EAAQV,EAAatX,SAASwX,EAAUX,GAAG,IAC/CS,EAAa1D,cAAc,GAAG7L,KAAK,CAAC8P,EAAYC,GAAQD,EAAYE,GAAQF,EAAYG,Q,cCh6BhGnZ,OAAOC,eAAeC,EAAS,aAAc,CAAEC,OAAO,IACtDD,EAAQwI,oBAAiB,EACzB,IAKQ0Q,EACA1Q,EANJrI,EAAQ,EAAQ,KACpBH,EAAQwI,gBAIA0Q,EAAe,IAAIC,IACnB3Q,EAAiB,CAUjBC,mBAAoB,SAAUT,EAAiBO,EAAWN,EAAkBC,GACxE,OAAOF,EACD,IAAI7H,EAAMiZ,oBAAoB,CAC5BpX,MAAO,SACPuG,UAAWA,EAEX8Q,WAAW,EACXtO,QAAS,EAETC,KAAM9C,EACNoR,SAAS,EACTC,SAAU,EACVC,aAAc,EACdC,gBAAiB,IACjBvY,IAAKsH,EAAekR,iBAAiBzR,KAEvC,IAAI9H,EAAMwZ,kBAAkB,CAC1B3X,MAAO,QACPuG,UAAWA,EACXqR,aAAa,EACbP,WAAW,EACXtO,QAAS,EAETC,KAAM9C,EACNoR,SAAS,EACTC,SAAU,EACVC,aAAc,EACdC,gBAAiB,IACjBvY,IAAK,QAGjBuJ,oBAAqB,SAAUzC,EAAiBO,EAAWN,GACvD,OAAIM,EACO,IAAIpI,EAAM0K,kBAAkB,CAAEtC,WAAW,IAIzC,IAAIpI,EAAMiZ,oBAAoB,CACjCpX,MAAOgG,EAAkB,QAAW,UACpCO,WAAW,EAEX8Q,WAAW,EACXtO,QAAS,EACTC,KAAM7K,EAAMiI,WAEZkR,SAAS,EACTC,SAAU,EACVC,aAAc,EACdC,gBAAiB,IACjBvY,IAAK8G,EAAkBQ,EAAekR,iBAAiBzR,GAAoB,KAC3E4R,cAAc,KAU1BH,iBAAkB,SAAUI,GACxB,IAAIC,EAAUb,EAAac,IAAIF,GAO/B,OANKC,IAGDA,GADa,IAAI5Z,EAAM8Z,eACNC,KAAKJ,GACtBZ,EAAarU,IAAIiV,EAAMC,IAEpBA,M,cCrFnBja,OAAOC,eAAeC,EAAS,aAAc,CAAEC,OAAO,IACtDD,EAAQuB,+BAA4B,EACpC,IAAIpB,EAAQ,EAAQ,KAChBmP,EAAsB,EAAQ,IAC9BD,EAAoB,EAAQ,KAC5B8K,EAAsC,EAAQ,KAC9CC,EAA0B,EAAQ,KAClCC,EAA4B,EAAQ,KACpC/Z,EAA2B,EAAQ,KACnCiP,EAAc,EAAQ,KACtB9L,EAAc,EAAQ,KAC1BzD,EAAQuB,0BAA4B,CAYhCkS,UAAW,SAAU5H,EAAUyO,EAAYC,EAAYC,EAAYpE,GAC3DA,EACAvK,EAASmK,MAAMhN,KAAK,IAAI1I,EAAyB2V,MAAMuE,EAAYD,EAAYD,IAG/EzO,EAASmK,MAAMhN,KAAK,IAAI1I,EAAyB2V,MAAMqE,EAAYC,EAAYC,KAsBvFnE,UAAW,SAAUxK,EAAUyO,EAAYC,EAAYC,EAAYC,EAAYrE,GACvEA,GAEApW,EAAQuB,0BAA0BkS,UAAU5H,EAAUyO,EAAYE,EAAYD,GAAY,GAC1Fva,EAAQuB,0BAA0BkS,UAAU5H,EAAU2O,EAAYC,EAAYF,GAAY,KAG1Fva,EAAQuB,0BAA0BkS,UAAU5H,EAAUyO,EAAYC,EAAYC,GAAY,GAC1Fxa,EAAQuB,0BAA0BkS,UAAU5H,EAAU0O,EAAYE,EAAYD,GAAY,KAelGlE,gBAAiB,SAAUzK,EAAU0H,EAAG7E,EAAG8E,EAAG/E,EAAG8F,EAAqBK,EAAuBwB,GACrFA,GAGAvK,EAASgJ,cAAc,GAAG7L,KAAK,CAC3B,IAAI7I,EAAM8W,QAAQ1D,EAAIgB,EAAqB7F,EAAIkG,GAC/C,IAAIzU,EAAM8W,QAAQ1D,EAAIgB,EAAqB9F,EAAImG,GAC/C,IAAIzU,EAAM8W,QAAQzD,EAAIe,EAAqB7F,EAAIkG,KAEnD/I,EAASgJ,cAAc,GAAG7L,KAAK,CAC3B,IAAI7I,EAAM8W,QAAQ1D,EAAIgB,EAAqB9F,EAAImG,GAC/C,IAAIzU,EAAM8W,QAAQzD,EAAIe,EAAqB9F,EAAImG,GAC/C,IAAIzU,EAAM8W,QAAQzD,EAAIe,EAAqB7F,EAAIkG,OAInD/I,EAASgJ,cAAc,GAAG7L,KAAK,CAC3B,IAAI7I,EAAM8W,QAAQ1D,EAAIgB,EAAqB7F,EAAIkG,GAC/C,IAAIzU,EAAM8W,QAAQzD,EAAIe,EAAqB7F,EAAIkG,GAC/C,IAAIzU,EAAM8W,QAAQ1D,EAAIgB,EAAqB9F,EAAImG,KAEnD/I,EAASgJ,cAAc,GAAG7L,KAAK,CAC3B,IAAI7I,EAAM8W,QAAQzD,EAAIe,EAAqB7F,EAAIkG,GAC/C,IAAIzU,EAAM8W,QAAQzD,EAAIe,EAAqB9F,EAAImG,GAC/C,IAAIzU,EAAM8W,QAAQ1D,EAAIgB,EAAqB9F,EAAImG,OAW3DuC,oBAAqB,SAAUtL,EAAU0H,EAAGqB,GAExC,IAAI8F,EAAS,EAAkD,EAA5CxP,KAAK2M,IAAI,GAAMtE,EAAIqB,GAClC+F,EAAS,EAAwD,EAAlDzP,KAAK2M,IAAI,IAAOtE,EAAI,GAAKqB,GAC5C/I,EAASgJ,cAAc,GAAG7L,KAAK,CAAC,IAAI7I,EAAM8W,QAAQyD,EAAQ,GAAI,IAAIva,EAAM8W,QAAQ,GAAK,GAAI,IAAI9W,EAAM8W,QAAQ0D,EAAQ,MASvHvH,mBAAoB,SAAUwH,GAG1B,IADA,IAAIC,EAAc,GACT1O,EAAI,EAAGA,EAAIyO,EAAWrY,OAAQ4J,IACnC0O,EAAY7R,KAAK4R,EAAWzO,GAAG3J,EAAGoY,EAAWzO,GAAG9J,GAEpD,OAAOwY,GAUXlT,kBAAmB,SAAUmT,EAAQC,EAAYC,QACjB,IAAjBA,IACPA,EAAe,GAInB,IAFA,IACIC,EADAha,EAAW,GAENkL,EAAI,EAAGA,EAAI4O,EAAY5O,IAC5B8O,EAAgB,EAAV/P,KAAKC,IAAUgB,EAAI4O,GACzB9Z,EAAS+H,KAAK,IAAIqG,EAAkBwJ,OAAO3N,KAAKgQ,IAAID,GAAOH,EAASE,EAAc9P,KAAKiQ,IAAIF,GAAOH,IAEtG,OAAO,IAAIzL,EAAkBwD,QAAQ5R,GAAU,IAcnDoJ,UAAW,SAAU+Q,EAAoBC,GAGrC,IAGIC,GAAiB,EAAInB,EAAoCoB,eAAeH,EAAoBC,GAH/E,GAUjB,OAHAC,EAAeE,gBAEfF,EAAeG,qBACRH,GAWX/P,4BAA6B,SAAUmQ,EAAe/N,EAAMyN,EAC5DO,EACAC,EAEAhb,GAGI,IAEIib,GAFwB,IAAIzB,EAAwB0B,uBAETC,sBAAsBpO,EAAMyN,EAAoBO,EAAeC,GAE1GI,GAA2B,EAAI3B,EAA0B4B,yBAAyBJ,EAD5E,MAKNxP,EAAgBrM,EAAQuB,0BAA0BuK,yBAAyBkQ,GAC3EE,EAAiB,IAAI/b,EAAM2B,eAAe,CAC1CC,KAAM,IACNC,MAAO,QAIPma,EAAa,IAAIhc,EAAMyB,OAAOyK,EAAe6P,GAC7Ctb,EAAQwb,iBACRD,EAAW1X,SAASpC,GAAK,IACzB8Z,EAAW1X,SAASC,GAAK,GACzBgX,EAAclS,QAAQ2S,IAU1B,IANA,IAAIhJ,EAAcnT,EAAQuB,0BAA0B6R,mBAAmB4I,GAEnE3I,GAAkB,EAAI/D,EAAoBgE,QAAQH,GAGlDkJ,EAAmB,IAAI/b,EAAyBU,OAC3CmL,EAAI,EAAGA,EAAI6P,EAAyBzZ,OAAQ4J,IACjDkQ,EAAiBpb,SAAS+H,KAAKgT,EAAyB7P,GAAG7K,SAE/D,IAAS6K,EAAI,EAAGA,EAAI,EAAIkH,EAAgB9Q,OAAQ4J,GAAK,EAAG,CACpD,IAAIoH,EAAIF,EAAgBlH,GACpBuC,EAAI2E,EAAgBlH,EAAI,GACxBqH,EAAIH,EAAgBlH,EAAI,GAC5BnM,EAAQuB,0BAA0BkS,UAAU4I,EAAkB9I,EAAG7E,EAAG8E,GAExE,GAAI5S,EAAQ0b,+BAAgC,CAGxC,IAAIC,EAAe,IAAIpc,EAAM8C,KAAKoZ,EAAiBxa,mBAAoB,IAAI1B,EAAM8L,kBAAkB,CAC/FjK,MAAO,YAEXua,EAAa9X,SAASpC,GAAK,IAC3Bka,EAAa9X,SAASC,GAAK,GAC3BgX,EAAclS,QAAQ+S,GAU1B,OANI3b,EAAQ4b,8BACRxc,EAAQuB,0BAA0Bkb,mCAAmCf,EAAeN,GAEpFxa,EAAQ8b,6BACR1c,EAAQuB,0BAA0Bob,kCAAkCjB,EAAeN,GAEhFY,GAGXS,mCAAoC,SAAUf,EAAeN,GACzD,IAAIS,EAAqBT,EAAmBtI,8BAA6B,GAAM,GAC3EzG,EAAgB,IAAI/L,EAAyBU,OACjDqL,EAAcpL,SAAW4a,EAczB,IAbA,IAAIK,EAAiB,IAAI/b,EAAM0K,kBAAkB,CAC7CtC,WAAW,EACXvG,MAAO,SACP+I,QAAS,GACTC,KAAM7K,EAAMiI,WACZ0C,aAAa,IAGbqI,EAAcnT,EAAQuB,0BAA0B6R,mBAAmByI,GAEnExI,GAAkB,EAAI/D,EAAoBgE,QAAQH,GAG7ChH,EAAI,EAAGA,EAAI,EAAIkH,EAAgB9Q,OAAQ4J,GAAK,EAAG,CACpD,IAAIoH,EAAIF,EAAgBlH,GACpBuC,EAAI2E,EAAgBlH,EAAI,GACxBqH,EAAIH,EAAgBlH,EAAI,GAC5BnM,EAAQuB,0BAA0BkS,UAAUpH,EAAekH,EAAG7E,EAAG8E,GAErE,IAAI2I,EAAa,IAAIhc,EAAM8C,KAAKoJ,EAAcxK,mBAAoBqa,GAClEC,EAAW1X,SAASpC,GAAK,IACzB8Z,EAAW1X,SAASC,EAAI,GACxByX,EAAWxS,SAAuB,cAAI,EACtC+R,EAAclS,QAAQ2S,IAG1BQ,kCAAmC,SAAUjB,EAAeN,GAGxD,IAFA,IAAI/O,EAAgB,IAAI/L,EAAyBU,OAC7C6S,EAAYuH,EAAmBxH,4BAC1BzH,EAAI,EAAGA,EAAI0H,EAAUtR,OAAQ4J,IAAK,CACvC,IAAIyQ,EAAa/I,EAAU1H,GAAG1K,MAC1Bob,EAAahJ,EAAU1H,GAAG9K,IAC9BgL,EAAcpL,SAAS+H,KAAK4T,EAAYC,GACxC,IAAIpa,EAAY4J,EAAcpL,SAASsB,OACnC4J,EAAI,IACJE,EAAc2J,MAAMhN,KAAK,IAAI1I,EAAyB2V,MAAMxT,EAAY,EAAGA,EAAY,EAAGA,EAAY,IACtG4J,EAAc2J,MAAMhN,KAAK,IAAI1I,EAAyB2V,MAAMxT,EAAY,EAAGA,EAAY,EAAGA,EAAY,KAG9G,IAAIyZ,EAAiB,IAAI/b,EAAM0K,kBAAkB,CAC7CtC,WAAW,EACXvG,MAAO,SACP+I,QAAS,GACTC,KAAM7K,EAAMiI,WACZ0C,aAAa,IAEbqR,EAAa,IAAIhc,EAAM8C,KAAKoJ,EAAcxK,mBAAoBqa,GAClEC,EAAW1X,SAASpC,GAAK,IACzB8Z,EAAW1X,SAASC,GAAK,GACzByX,EAAWxS,SAAuB,cAAI,EACtC+R,EAAclS,QAAQ2S,IAQ1BlT,SAAU,SAAUyS,EAAe9S,GAC/B,IAAIkU,EAAY,IAAI3c,EAAM4c,aAAanU,EAAc/G,mBAAoB,IAAI1B,EAAM8L,kBAAkB,CACjGjK,MAAO,YAEX8a,EAAUrY,SAASpC,GAAK,IACxBqZ,EAAclS,QAAQsT,IAS1B3T,sBAAuB,SAAUuS,EAAesB,GAC5Chd,EAAQuB,0BAA0B0b,qBAAqBvB,EAAesB,EAAwBlN,eAAgB,UAC9G9P,EAAQuB,0BAA0B0b,qBAAqBvB,EAAesB,EAAwBjN,eAAgB,QAUlHkN,qBAAsB,SAAUvB,EAAe7H,EAAWqJ,GACtD,IAAIC,EAAoB,IAAI7c,EAAyBU,OACrD6S,EAAU/K,SAAQ,SAAUsU,GACxBD,EAAkBlc,SAAS+H,KAAKoU,EAAS3b,MAAMH,SAC/C6b,EAAkBlc,SAAS+H,KAAKoU,EAAS/b,IAAIC,YAEjD,IAAI+b,EAAgB,IAAIld,EAAM4c,aAAaI,EAAkBtb,mBAAoB,IAAI1B,EAAM8L,kBAAkB,CACzGjK,MAAOkb,KAEXG,EAAc5Y,SAASpC,GAAK,IAC5BqZ,EAAclS,QAAQ6T,IAS1B5Q,uBAAwB,SAAU6Q,EAAW/B,EAAegC,EAAe3c,GAEvE,IAAI4c,EAAoBD,EAAcE,QAAO,SAAUC,EAAajb,GAChE,IAAIiP,EAAO6J,EAActa,SAASwB,GAElC,OADAib,EAAY1U,KAAK0I,EAAKlP,EAAGkP,EAAKrP,GACvBqb,IACR,IAECjF,GAAY,EAAInJ,EAAoBgE,QAAQkK,GAE5CG,EAAoB,IAAIrd,EAAyBU,OAIrD2c,EAAkB1c,SAAWsc,EAAcrc,KAAI,SAAU0K,GACrD,OAAO2P,EAActa,SAAS2K,MAIlC,IADA,IAAIyE,EAAiBhB,EAAkBsJ,OAAOC,oBAAoB+E,EAAkB1c,SAASC,KAAI,SAAU0c,GAAW,OAAO,IAAIvO,EAAkBwJ,OAAO+E,EAAQpb,EAAGob,EAAQvb,OACpKyV,EAAI,EAAGA,EAAIW,EAAUlW,OAAQuV,GAAK,EAAG,CAC1C,IAAIvE,EAAIkF,EAAUX,GACdpJ,EAAI+J,EAAUX,EAAI,GAClBtE,EAAIiF,EAAUX,EAAI,GACtB6F,EAAkB3H,MAAMhN,KAAK,IAAI1I,EAAyB2V,MAAM1C,EAAG7E,EAAG8E,IAEtEjE,EAAYmH,UAAUC,oBAAoBgH,EAAmBtN,EAAgBkD,EAAG7E,EAAG8E,GAEvFmK,EAAkB7Q,eAAgB,EAElC6Q,EAAkB5Q,mBAAoB,EACtC4Q,EAAkB7c,uBAClB,IAAI+c,EAAgB,IAAI1d,EAAM8C,KAAK0a,EAAkB9b,mBAAoB,IAAI1B,EAAM0K,kBAAkB,CACjG7I,MAAO,MACP8I,aAAa,EACbC,QAAS,IACTC,KAAM7K,EAAMiI,cAShB,OAPAyV,EAAcpZ,SAASpC,GAAK,IAE5Bwb,EAAclU,SAAuB,cAAI,EACzC2T,EAAUrX,eAAexC,EAAYqa,sCAAwCH,EACzE/c,EAAQmd,6BACRT,EAAU9T,QAAQqU,GAEfF,GAUXlL,kBAAmB,SAAUuL,EAAMC,EAAQC,GACvC,IAAIC,EAAYF,EAAOzb,EAAIwb,EAAKxb,EAA5B2b,EAAkCF,EAAO5b,EAAI2b,EAAK3b,EAElD+b,EAAQF,EADChT,KAAKmT,KAAKF,EAASA,EAASA,EAASA,GAElDF,EAAOzb,EAAIwb,EAAKxb,EAAI2b,EAASC,EAC7BH,EAAO5b,EAAI2b,EAAK3b,EAAI8b,EAASC,GAUjC5c,mBAAoB,SAAUwc,EAAMC,EAAQC,GACxC,IAAIC,EAAYF,EAAOzb,EAAIwb,EAAKxb,EAA5B2b,EAAkCF,EAAO5b,EAAI2b,EAAK3b,EAAlD8b,EAAwDF,EAAOvZ,EAAIsZ,EAAKtZ,EAExE0Z,EAAQF,EADChT,KAAKmT,KAAKF,EAASA,EAASA,EAASA,EAASA,EAASA,GAEpEF,EAAOzb,EAAIwb,EAAKxb,EAAI2b,EAASC,EAC7BH,EAAO5b,EAAI2b,EAAK3b,EAAI8b,EAASC,EAC7BH,EAAOvZ,EAAIsZ,EAAKtZ,EAAIyZ,EAASC,GAOjCE,oBAAqB,SAAUC,GAC3B,KAAOA,EAASC,WACZD,EAASE,YAAYF,EAASC,YAWtCE,MAAO,SAAU7I,EAAG7B,EAAKxC,GACrB,OAAOtG,KAAKsG,IAAItG,KAAK8I,IAAI6B,EAAGrE,GAAMwC,IAEtClI,yBAA0B,SAAU7K,GAChC,IAAI4K,EAAW,IAAI1L,EAAMwe,eAGrBC,EAAa,IAAIC,aAAa5d,EAASwc,QAAO,SAAUqB,EAAMpN,GAE9D,OADAoN,EAAK9V,KAAK0I,EAAKlP,EAAGkP,EAAKrP,EAAGqP,EAAKhN,GACxBoa,IACR,KAGH,OADAjT,EAAS5E,aAAa,WAAY,IAAI9G,EAAM4e,gBAAgBH,EAAY,IACjE/S,K,YCtdM,IACbmT,EAHRlf,OAAOC,eAAeC,EAAS,aAAc,CAAEC,OAAO,IACtDD,EAAQif,gBAAa,EACrBjf,EAAQif,YACAD,EAAW,IAAI7F,IACP,CACR+F,SAAU,SAAUpF,EAAM1L,GAEtB,IAAI+Q,EAAQH,EAAShF,IAAIF,GASzB,OARKqF,IACDA,EAAQrb,SAASsb,cAAc,OAC/BJ,EAASna,IAAIiV,EAAMqF,GACnBA,EAAME,OAAS,WACXjR,EAAW+Q,IAEfA,EAAMlY,aAAa,MAAO6S,IAEvBqF,GAEXG,cAAe,SAAUH,GACrB,OAAOA,EAAMI,UAAoC,IAAxBJ,EAAMK,oBAA+CC,IAAxBN,EAAMK,kB,YChBxE1f,OAAOC,eAAeC,EAAS,aAAc,CAAEC,OAAO,IACtDD,EAAQ0f,oBAAiB,EACzB,IAAIA,EAAgC,WAKhC,SAASA,KAoBT,OAZAA,EAAejZ,UAAUkZ,eAAiB,SAAUC,EAAoBC,GACpE,IAAIC,EAAaC,aAAaC,QAAQ,eAClCF,GACAF,EAAmBE,GAEvBG,aAAY,WACR,IAAIC,EAAgBL,IAChBK,GACAH,aAAaI,QAAQ,cAAeD,KAEzC,MAEAR,EAzBwB,GA2BnC1f,EAAQ0f,eAAiBA,G,aCxBzB5f,OAAOC,eAAeC,EAAS,aAAc,CAAEC,OAAO,IACtDD,EAAQyL,gBAAa,EACrB,IAAIhI,EAAc,EAAQ,KACtBgI,EAA4B,WAM5B,SAASA,EAAW2U,GAChBxc,KAAKyc,gBAAkB,IAAIC,IAC3B1c,KAAK2c,qBAAuB,IAAID,IAChC1c,KAAK4c,mBAAqB,EAC1B5c,KAAKwc,aAA6B,IAAZA,GAA2BA,GAAW,EAAIA,EAAU3c,EAAYmJ,IAyJ1F,OA3IAnB,EAAWhF,UAAUiF,mBAAqB,SAAU0P,EAAoBqF,GACpE,IAAIC,EAAiB,GACrB9c,KAAKyc,gBAAgBM,QACrB/c,KAAK2c,qBAAqBI,QAM1B,IAAIC,EAAkBC,EAA6BzF,EAAoBqF,EAAc7c,KAAKwc,SACtFvK,EAAI+K,EAAgBre,OAOxB,IALAqB,KAAK2c,qBAAuB,IAAID,IAAIM,EAAgB1f,KAAI,SAAU4f,EAAWvL,GACzE,OAAOA,MAIJ3R,KAAK4c,mBAAqB3K,GAAG,CAChC,IAAIkL,EAAqBnd,KAAK2c,qBAAqBS,SAASC,OAAOhhB,MAE/D6Z,EAAOlW,KAAKsd,mBAAmB9F,EAAoBwF,EAAiBG,GACxEL,EAAe1X,KAAK8Q,GAGxB,OAAOlW,KAAKud,qBAAqBT,EAAgBtF,IAerD3P,EAAWhF,UAAUya,mBAAqB,SAAU9F,EAAoBwF,EAAiBQ,GACrF,IAMIC,EANAvH,EAAO,CAACsH,GAOZ,IANAxd,KAAKyc,gBAAgBrb,IAAIoc,GACzBxd,KAAK2c,qBAAqBe,OAAOF,GACjCxd,KAAK4c,sBAIwG,KAArGa,EAAoBzd,KAAK2d,iBAAiBnG,EAAoBwF,EAAiBQ,KAEnFtH,EAAK9Q,KAAKqY,GACVzd,KAAKyc,gBAAgBrb,IAAIqc,GACzBzd,KAAK2c,qBAAqBe,OAAOD,GACjCzd,KAAK4c,qBACLY,EAAiBC,EAErB,OAAOvH,GAaXrO,EAAWhF,UAAU8a,iBAAmB,SAAUnG,EAAoBwF,EAAiBQ,GAEnF,IADA,IAAII,EAAYpG,EAAmBpF,MAAMzT,OAChCkf,EAAI,EAAGA,EAAID,EAAWC,IAC3B,GAAIC,EAAiBtG,EAAoBqG,EAAGL,GAGxC,IAAK,IAAIjV,EAAI,EAAGA,EAAIyU,EAAgBre,OAAQ4J,IAAK,CAC7C,IAAIwV,EAAgBf,EAAgBzU,GACpC,GAAIwV,IAAkBP,IAGlBxd,KAAKge,UAAUD,GAAnB,CAGA,IAAK/d,KAAKge,UAAUD,IAAkBD,EAAiBtG,EAAoBqG,EAAGE,GAC1E,OAAOA,EAEX,GAAID,EAAiBtG,EAAoBqG,EAAGE,GACxC,OAAOA,GAMvB,OAAQ,GASZlW,EAAWhF,UAAUmb,UAAY,SAAUnf,GACvC,OAAOmB,KAAKyc,gBAAgBwB,IAAIpf,IAUpCgJ,EAAWhF,UAAU0a,qBAAuB,SAAUT,EAAgBtF,GAMlE,IALA,IAAI0G,EAAc,GAEdC,EAAwB,IAAIzB,IAAII,EAAexf,KAAI,SAAU8gB,EAAOzM,GACpE,OAAOA,MAEJwM,EAAsBhgB,KAAO,GAAG,CACnC,IAAIkgB,EAAmBF,EAAsBf,SAASC,OAAOhhB,MAC7D8hB,EAAsBT,OAAOW,GAC7B,IAAIC,EAAcxB,EAAeuB,GAC7BE,EAAW,KACf,KACIA,EAAWC,EAAiB1B,EAAgBwB,EAAYA,EAAY3f,OAAS,GAAIwf,EAAuB3G,KACvF8G,EAAY3f,OAAS,IAElC2f,EAAcA,EAAYG,UAC1BF,EAAWC,EAAiB1B,EAAgBwB,EAAYA,EAAY3f,OAAS,GAAIwf,EAAuB3G,IAExG+G,IACAD,EAAcA,EAAYI,OAAOH,UAEhCA,GAETL,EAAY9Y,KAAKkZ,GAErB,OAAOJ,GAEJrW,EAnKoB,GAqK/BzL,EAAQyL,WAAaA,EAUrB,IAAIiW,EAAmB,SAAUtG,EAAoBmH,EAAW3W,GAC5D,IAAI4W,EAAOpH,EAAmBpF,MAAMuM,GACpC,OAAOC,EAAKjP,IAAM3H,GAAuB4W,EAAK9T,IAAM9C,GAAuB4W,EAAKhP,IAAM5H,GActFiV,EAA+B,SAAUzF,EAAoBqF,EAAcL,GAE3E,IADA,IAAIQ,EAAkB,GACbzU,EAAI,EAAGA,EAAIsU,EAAale,OAAQ4J,IAAK,CAI1C,IAHA,IAAIsW,EAAWhC,EAAatU,GACxBuW,GAAc,EACdC,EAAYvC,EACPhO,EAAI,EAAGA,EAAIgJ,EAAmBna,SAASsB,OAAQ6P,IAAK,CACzD,IAAIwQ,EAAUxH,EAAmBna,SAASmR,GAAGwD,WAAW6M,GACpDG,GAAWD,KAES,IAAhBD,IAEiB,IAAhBA,GAAqBtH,EAAmBna,SAASyhB,GAAY9M,WAAW6M,IAAaG,GAAWF,EAAatQ,KAC9GsQ,EAAatQ,EACbuQ,EAAYC,IAIJ,IAAhBF,EACAxgB,QAAQoM,KAAK,oGACTnC,EACA,+CAIJyU,EAAgB5X,KAAK0Z,GAG7B,OAAO9B,GAsBPwB,EAAmB,SAAU1B,EAAgBmC,EAAkBd,EAAuB3G,GACtF,IAAK,IAAIqG,EAAI,EAAGA,EAAIrG,EAAmBpF,MAAMzT,OAAQkf,IACjD,GAAIC,EAAiBtG,EAAoBqG,EAAGoB,GAExC,IAAK,IAAIlX,EAAI,EAAGA,EAAI+U,EAAene,OAAQoJ,IACvC,GAAKoW,EAAsBF,IAAIlW,GAA/B,CAIA,IAAIwW,EAAWzB,EAAe/U,GAC9B,GAAI+V,EAAiBtG,EAAoBqG,EAAGU,EAAS,IAGjD,OADAJ,EAAsBT,OAAO3V,GACtBwW,EAEN,GAAIT,EAAiBtG,EAAoBqG,EAAGU,EAASA,EAAS5f,OAAS,IAGxE,OADAwf,EAAsBT,OAAO3V,GACtBwW,EAASE,a,cCtQpCviB,OAAOC,eAAeC,EAAS,aAAc,CAAEC,OAAO,IACtDD,EAAQ8b,2BAAwB,EAChC,IAAI3b,EAAQ,EAAQ,KAChB2b,EAIA,WACI,IAAInM,EAAQ/L,KASZA,KAAKmY,sBAAwB,SAAUpO,EAAM9B,EAAUwP,EAAOO,GAE1DjM,EAAMmT,qBAAuB,GAC7B,IAAIC,EAAY,IAAI5iB,EAAMgK,MAStBf,EAAK4Z,EAAoBpH,GAAoBrI,EAAInK,EAAG,GAAIsF,EAAItF,EAAG,GAAIoK,EAAIpK,EAAG,GAC9EiS,EAAM4H,aAAatT,EAAMuT,YAAYC,KAAK5P,IAC1C8H,EAAM4H,aAAatT,EAAMyT,YAAYD,KAAKzU,IAC1C2M,EAAM4H,aAAatT,EAAM0T,YAAYF,KAAK3P,IAC1CuP,EAAUO,sBAAsB3T,EAAMuT,YAAavT,EAAMyT,YAAazT,EAAM0T,aAC5E,IAAIld,EAAQwJ,EAYZ,OAXA9D,EAASmK,MAAMlN,SAAQ,SAAU0Z,GAC7B7U,EAAKsV,aAAa9c,EAAMoN,EAAE4P,KAAKtX,EAAS5K,SAASuhB,EAAKjP,KACtD5F,EAAKsV,aAAa9c,EAAMuI,EAAEyU,KAAKtX,EAAS5K,SAASuhB,EAAK9T,KACtDf,EAAKsV,aAAa9c,EAAMqN,EAAE2P,KAAKtX,EAAS5K,SAASuhB,EAAKhP,KACtDrN,EAAMod,OAAS,IAAIpjB,EAAMuS,MAAMvM,EAAMoN,EAAGpN,EAAMuI,GAC9CvI,EAAMqd,OAAS,IAAIrjB,EAAMuS,MAAMvM,EAAMuI,EAAGvI,EAAMqN,GAC9CrN,EAAMsd,OAAS,IAAItjB,EAAMuS,MAAMvM,EAAMqN,EAAGrN,EAAMoN,GAC9CpN,EAAMud,yBAAyBvd,EAAMod,OAAQR,GAC7C5c,EAAMud,yBAAyBvd,EAAMqd,OAAQT,GAC7C5c,EAAMud,yBAAyBvd,EAAMsd,OAAQV,MAE1CpT,EAAMmT,sBAEjBlf,KAAK8f,yBAA2B,SAAUC,EAAMtI,GAC5C,IAAIuI,EAAoBvI,EAAMwI,cAAcF,EAAM/f,KAAKkgB,qBACnDF,GACAhgB,KAAKkf,qBAAqB9Z,KAAK4a,EAAkBtiB,UAIzDsC,KAAKkf,qBAAuB,GAC5Blf,KAAK2P,EAAI,IAAIpT,EAAMwI,QACnB/E,KAAK8K,EAAI,IAAIvO,EAAMwI,QACnB/E,KAAK4P,EAAI,IAAIrT,EAAMwI,QACnB/E,KAAKsf,YAAc,IAAI/iB,EAAMwI,QAC7B/E,KAAKwf,YAAc,IAAIjjB,EAAMwI,QAC7B/E,KAAKyf,YAAc,IAAIljB,EAAMwI,QAC7B/E,KAAK2f,OAAS,IAAIpjB,EAAMuS,MACxB9O,KAAK4f,OAAS,IAAIrjB,EAAMuS,MACxB9O,KAAK6f,OAAS,IAAItjB,EAAMuS,MACxB9O,KAAKkgB,oBAAsB,IAAI3jB,EAAMwI,SAI7C3I,EAAQ8b,sBAAwBA,EAYhC,IAAIkH,EAAsB,SAAUpH,GAChC,IAAImI,EAAoBnI,EAAkBoI,aAAa,YAOnDzQ,GANc,IAAIpT,EAAMwI,QAMpB,IAAIxI,EAAMwI,SACd+F,EAAI,IAAIvO,EAAMwI,QACd6K,EAAI,IAAIrT,EAAMwI,QAIlB,OAHA4K,EAAE0Q,oBAAoBF,EAAmB,GACzCrV,EAAEuV,oBAAoBF,EAAmB,GACzCvQ,EAAEyQ,oBAAoBF,EAAmB,GAClC,CAACxQ,EAAG7E,EAAG8E,K,cCrGlB1T,OAAOC,eAAeC,EAAS,aAAc,CAAEC,OAAO,IACtDD,EAAQ0W,eAAY,EACpB,IAAIvW,EAAQ,EAAQ,KACpBH,EAAQ0W,UAAY,CAUhBC,oBAAqB,SAAU4B,EAC/Bf,EAAa8C,EAAYC,EAAYC,GACjC,IAAIzB,EAAQR,EAAatX,SAASqZ,GAC9BtB,EAAQT,EAAatX,SAASsZ,GAC9BtB,EAAQV,EAAatX,SAASuZ,GAE9B1B,EAAc,SAAUpH,GACxB,OAAO,IAAIvR,EAAM8W,SAASvF,EAAKlP,EAAIgV,EAAYxD,IAAIxR,GAAKgV,EAAY9Q,OAAQgL,EAAKrP,EAAImV,EAAYxD,IAAI3R,GAAKmV,EAAY1Q,SAE1HyR,EAAa1D,cAAc,GAAG7L,KAAK,CAAC8P,EAAYC,GAAQD,EAAYE,GAAQF,EAAYG,Q,YCvBhGnZ,OAAOC,eAAeC,EAAS,aAAc,CAAEC,OAAO,IACtDD,EAAQic,6BAA0B,EAuBlCjc,EAAQic,wBAZsB,SAAUhb,EAAUmf,QACvB,IAAZA,IACPA,EAZE,MAeN,IADA,IAAI8D,EAAS,GACJ/X,EAAI,EAAGA,EAAIlL,EAASsB,OAAQ4J,IAC5BgY,EAAoBljB,EAAUA,EAASkL,GAAIA,EAAI,EAAGiU,IACnD8D,EAAOlb,KAAK/H,EAASkL,IAG7B,OAAO+X,GAWX,IAYIC,EAAsB,SAAUljB,EAAUyB,EAAQ0hB,EAAWhE,GAC7D,IAAK,IAAIjU,EAAIiY,EAAWjY,EAAIlL,EAASsB,OAAQ4J,IACzC,GAdkB4M,EAcJ9X,EAASkL,GAdE6M,EAcEtW,EAdK2hB,EAcGjE,EAbhCrH,EAAMnD,WAAWoD,GAASqL,EAczB,OAAO,EAfH,IAAUtL,EAAOC,EAAOqL,EAkBpC,OAAO,I,cC1CXvkB,OAAOC,eAAeC,EAAS,aAAc,CAAEC,OAAO,IACtDD,EAAQc,0BAAuB,EAC/B,IAAIX,EAAQ,EAAQ,KAkCpBH,EAAQc,qBAxBmB,SAAUsa,EAAoB3a,GAMrD,IAJA,IAAI6jB,EAAgB7jB,EAAiBujB,aAAa,UAC9CO,EAAuB1V,MAAMuM,EAAmBpF,MAAMzT,QAGjDkf,EAAI,EAAGA,EAAIrG,EAAmBpF,MAAMzT,OAAQkf,IAAK,CACtD,IAAIe,EAAOpH,EAAmBpF,MAAMyL,GAChC+C,EAAc,IAAIrkB,EAAMwI,QAAQ2b,EAAcG,MAAU,EAAJhD,EAAQ,GAAI6C,EAAcG,MAAU,EAAJhD,EAAQ,GAAI6C,EAAcG,MAAU,EAAJhD,EAAQ,IAC5HiD,EAAc,IAAIvkB,EAAMwI,QAAQ2b,EAAcG,MAAU,EAAJhD,EAAQ,GAAI6C,EAAcG,MAAU,EAAJhD,EAAQ,GAAI6C,EAAcG,MAAU,EAAJhD,EAAQ,IAC5HkD,EAAc,IAAIxkB,EAAMwI,QAAQ2b,EAAcG,MAAU,EAAJhD,EAAQ,GAAI6C,EAAcG,MAAU,EAAJhD,EAAQ,GAAI6C,EAAcG,MAAU,EAAJhD,EAAQ,IAChImD,EAAgBL,EAAsB/B,EAAKjP,EAAGiR,GAC9CI,EAAgBL,EAAsB/B,EAAK9T,EAAGgW,GAC9CE,EAAgBL,EAAsB/B,EAAKhP,EAAGmR,GAIlD,IADA,IAAIE,EAAU,IAAIhW,MAAMuM,EAAmBna,SAASsB,QAC3C4J,EAAI,EAAGA,EAAIiP,EAAmBna,SAASsB,OAAQ4J,IAAK,CACzD,IAAI2Y,EAAgBC,EAAqBR,EAAqBpY,IAC9D2Y,EAAc9f,IAAIoW,EAAmBna,SAASkL,IAC9C0Y,EAAQ1Y,GAAK,IAAIhM,EAAMuS,MAAM0I,EAAmBna,SAASkL,GAAI2Y,GAEjE,OAAOD,GAaX,IAAID,EAAkB,SAAUI,EAAQviB,EAAWwiB,IAC3CxiB,GAAauiB,EAAOziB,aAAuC,IAAtByiB,EAAOviB,MAC5CuiB,EAAOviB,GAAa,IAExBuiB,EAAOviB,GAAWuG,KAAKic,IAQvBF,EAAuB,SAAUG,GACjC,IAAIC,EAAM,IAAIhlB,EAAMwI,QAAQ,EAAG,EAAG,GAOlC,OANIuc,IACAA,EAAQpc,SAAQ,SAAUsc,GACtBD,EAAIngB,IAAIogB,MAEZD,EAAIE,aAAaH,EAAQ3iB,SAEtB4iB,I,YC7EXrlB,OAAOC,eAAeC,EAAS,aAAc,CAAEC,OAAO,IACtDD,EAAQiN,qBAAuBjN,EAAQoN,sBAAwBpN,EAAQ0N,mCAAqC1N,EAAQ8d,qCAAuC9d,EAAQyN,8BAAgCzN,EAAQoL,oBAAsBpL,EAAQuN,sBAAwBvN,EAAQqN,qBAAuBrN,EAAQwN,yBAA2BxN,EAAQsN,wBAA0BtN,EAAQuJ,kBAAoBvJ,EAAQyP,WAAazP,EAAQ4M,SAAM,EACpa5M,EAAQ4M,IAAM,KACd5M,EAAQyP,WAAavE,KAAKC,GAAK,IAE/BnL,EAAQuJ,kBAAoB,CAAE/G,EAAG,EAAGH,GAAI,IAAKqC,GAAI,IACjD1E,EAAQsN,wBAA0B,0BAClCtN,EAAQwN,yBAA2B,2BACnCxN,EAAQqN,qBAAuB,uBAC/BrN,EAAQuN,sBAAwB,wBAChCvN,EAAQoL,oBAAsB,sBAC9BpL,EAAQyN,8BAAgC,gCACxCzN,EAAQ8d,qCAAuC,uCAC/C9d,EAAQ0N,mCAAqC,qCAC7C1N,EAAQoN,sBAAwB,wBAChCpN,EAAQiN,qBAAuB,wB,YCpB/BnN,OAAOC,eAAeC,EAAS,aAAc,CAAEC,OAAO,IACtDD,EAAQslB,yBAAsB,EAE9BtlB,EAAQslB,oBAAsB,sjD,cCD9BC,WAAWC,KAAO,U,YCAlB1lB,OAAOC,eAAeC,EAAS,aAAc,CAAEC,OAAO,IACtDD,EAAQylB,oBAAiB,EAOzBzlB,EAAQylB,eANa,WACjB,OAAkBlS,EAGfmS,UAAUC,WAAaD,UAAUE,QAAUthB,OAAOuhB,MAFzC,2TAA2TC,KAAKvS,IACpU,0kDAA0kDuS,KAAKvS,EAAEwS,OAAO,EAAG,IAF5lD,IAAWxS,I,YCCtBzT,OAAOC,eAAeC,EAAS,aAAc,CAAEC,OAAO,IACtDD,EAAQgmB,yBAAsB,EAuB9BhmB,EAAQgmB,oBAZkB,SAAUC,EAAWvjB,EAAQ0d,GAGnD,IAFA,IAAI8F,EAAczQ,OAAOkC,kBACrBwO,GAAgB,EACXha,EAAI,EAAGA,EAAI8Z,EAAU1jB,OAAQ4J,IAAK,CACvC,IAAIia,EAAOH,EAAU9Z,GAAGyJ,WAAWlT,IACb,IAAlByjB,GAAuBC,EAAOF,GAAeE,EAAOhG,IACpD+F,EAAeha,EACf+Z,EAAcE,GAGtB,OAAOD,I,cCjBXrmB,OAAOC,eAAeC,EAAS,aAAc,CAAEC,OAAO,IACtDD,EAAQqmB,oBAAsBrmB,EAAQ2M,qBAAkB,EACxD,IAAIxM,EAAQ,EAAQ,KAChBmmB,EAAwB,EAAQ,KAChChmB,EAA2B,EAAQ,KAqCvCN,EAAQ2M,gBAvBc,SAAU4Z,EAAcC,EAAepG,QAClC,IAAZA,IACPA,EAfE,MAkBN,IADA,IAAIqG,GAAY,EAAIzmB,EAAQqmB,qBAAqBE,EAAcC,EAAepG,GACrEqB,EAAI,EAAGA,EAAI+E,EAAcxQ,MAAMzT,OAAQkf,IAAK,CACjD,IAAIe,EAAOgE,EAAcxQ,MAAMyL,GAC3BlO,EAAIkT,EAAUjE,EAAKjP,GACnB7E,EAAI+X,EAAUjE,EAAK9T,GACnB8E,EAAIiT,EAAUjE,EAAKhP,GAKvB,GADA+S,EAAavQ,MAAMhN,KAAK,IAAI1I,EAAyB2V,MAAM1C,EAAG7E,EAAG8E,IAC7DgT,EAAc3R,cAActS,OAAS,GAAKkf,EAAI+E,EAAc3R,cAAc,GAAGtS,OAAQ,CACrF,IAAImkB,EAASF,EAAc3R,cAAc,GAAG4M,GAC5C8E,EAAa1R,cAAc,GAAG7L,KAAK,CAAC0d,EAAO,GAAGplB,QAASolB,EAAO,GAAGplB,QAASolB,EAAO,GAAGplB,eAGpFilB,EAAa1R,cAAc,GAAG7L,KAAK,CAAC,IAAI7I,EAAM8W,QAAQ,EAAK,GAAM,IAAI9W,EAAM8W,QAAQ,EAAK,GAAM,IAAI9W,EAAM8W,QAAQ,EAAK,QAmCjIjX,EAAQqmB,oBAjBkB,SAAUE,EAAcC,EAAepG,GAE7D,IADA,IAAIqG,EAAY,GACPE,EAAI,EAAGA,EAAIH,EAAcvlB,SAASsB,OAAQokB,IAAK,CACpD,IAAIC,EAAYJ,EAAcvlB,SAAS0lB,GACnCE,GAAc,EAAIP,EAAsBN,qBAAqBO,EAAatlB,SAAU2lB,EAAWxG,IAC9E,IAAjByG,GAGAJ,EAAUzd,KAAKud,EAAatlB,SAASsB,QACrCgkB,EAAatlB,SAAS+H,KAAK4d,EAAUtlB,UAGrCmlB,EAAUzd,KAAK6d,GAGvB,OAAOJ,I,cCtEXzmB,EAAQ,OAAO,EACf,IAAI8mB,EAAa,EAAQ,KACrBC,EAAe,EAAQ,KACvBC,EAAoB,EAAQ,KAC5BC,EAAmB,EAAQ,KAC3BC,EAAmB,EAAQ,KAC3BzjB,EAAc,EAAQ,KAC1BzD,EAAQ,EAAO,CACXslB,oBAAqBwB,EAAWxB,oBAChC7V,WAAYhM,EAAYgM,WACxBlG,kBAAmB9F,EAAY8F,kBAC/B6D,sBAAuB3J,EAAY2J,sBACnCH,qBAAsBxJ,EAAYwJ,qBAClCyS,eAAgBuH,EAAiBvH,eACjCxc,gBAAiB8jB,EAAkB9jB,gBACnC+b,WAAY8H,EAAa9H,WACzBwG,eAAgByB,EAAiBzB,iB,cCfrC3lB,OAAOC,eAAeC,EAAS,aAAc,CAAEC,OAAO,IACtDD,EAAQkM,oBAAiB,EACzB,IAAIib,EAAuB,EAAQ,IAC/BC,EAAsB,EAAQ,KAC9BC,EAAc,EAAQ,KAkC1BrnB,EAAQkM,eAzBa,SAAUqJ,EAAO+R,GAClC,QAAqB,IAAV/R,EAAuB,CAC9B,IAAIgS,EAASrc,KAAKsG,SAAuD,IAA5C2V,EAAqBK,mBAAqCL,EAAqBK,mBAAmBjlB,OAAS,OAAoD,IAA1C6kB,EAAoBK,kBAAoCL,EAAoBK,kBAAkBllB,OAAS,OAAoC,IAA1B8kB,EAAYK,UAA4BL,EAAYK,UAAUnlB,OAAS,GAC1UgT,EAAQrK,KAAKyc,MAAMzc,KAAK0c,SAAWL,GAEvC,OAAQD,GACJ,IAAK,YACD,QAAuD,IAA5CH,EAAqBK,mBAC5B,OAAOL,EAAqBK,mBAAmBjS,EAAQ4R,EAAqBK,mBAAmBjlB,QAAQslB,SAGvG3lB,QAAQoM,KAAK,oGAErB,IAAK,QACD,QAAqD,IAA1C8Y,EAAoBK,kBAC3B,OAAOL,EAAoBK,kBAAkBlS,EAAQ6R,EAAoBK,kBAAkBllB,QAAQslB,SAGnG3lB,QAAQoM,KAAK,mGAGrB,QACI,OAAO+Y,EAAYK,UAAUnS,EAAQ8R,EAAYK,UAAUnlB,QAAQslB,Y,6IChDxE,MAAMC,EAAQ,QACRC,EAAO,OACPC,EAAK,KACLC,EAAY,CAAC,IAAK,IAAK,KCEvBC,EAAkBC,GACdC,EAAUD,GAAOE,OAAOC,GAClBpnB,KAAI,SAAUqnB,GAC7B,OAAOA,EAAMrnB,KAAI,SAAUsnB,GACvB,OAAOA,EAAK,SAKlBJ,EAAaD,IACf,IAAIM,GAAU,EAId,IAHA,IAAIC,EAASP,EAAMjnB,KAAKsnB,GACb,CAACA,KAELC,GACHA,EAAUE,EAAcD,GAK5B,OAHAA,EAASA,EAAOL,QAAO,SAAUE,GAC7B,OAAOA,EAAMhmB,WAIfomB,EAAiBD,IACnBA,EAAO5f,SAAQ,SAAU8f,EAAQzc,GAC7Buc,EAAO5f,SAAQ,SAAU+f,EAAQzW,GAE7B,GADa0W,EAAYF,EAAQC,GAG7B,cADOH,EAAOtW,IACP,SAIZ,GAEL0W,EAAc,CAACF,EAAQC,IACrBD,IAAWC,IAGXE,EAAWH,KAAYI,EAASH,IAChCD,EAAOK,QAAQC,MAAMN,EAAQC,IACtB,GAEPE,EAAWH,KAAYG,EAAWF,IAClCM,EAAaN,GACbD,EAAOK,QAAQC,MAAMN,EAAQC,IACtB,GAEPG,EAASJ,KAAYG,EAAWF,IAChCD,EAAO5f,KAAKkgB,MAAMN,EAAQC,IACnB,GAEPG,EAASJ,KAAYI,EAASH,KAC9BM,EAAaN,GACbD,EAAO5f,KAAKkgB,MAAMN,EAAQC,IACnB,IAITE,EAAcR,GACTA,EAAM,GAAG,GAEdS,EAAYT,GACPA,EAAMA,EAAMhmB,OAAS,GAAG,GAE7B4mB,EAAgBZ,IAClBA,EAAMlG,UACNkG,EAAMzf,SAAQ,SAAU0f,GACpBA,EAAKnG,cAGPiG,EAAaC,GACRQ,EAAWR,KAAWS,EAAST,GAAS,EAAI,E,aCpEhD,MAAMa,EACTja,YAAYka,EAAgBC,EAAgBC,GACxC3lB,KAAKylB,eAAiBA,EACtBzlB,KAAK0lB,eAAiBA,EACtB1lB,KAAK2lB,WAAaA,EAClB3lB,KAAK4lB,cAAgB,GACrB5lB,KAAK6lB,mBAAqB,GAC1B7lB,KAAK8lB,SAAW,CAAC,IAKrBC,UAAUC,GACNhmB,KAAKgmB,gBAAkBA,EACvBhmB,KAAKimB,WAAajmB,KAAKylB,eAAerT,MAAM4T,GAC5ChmB,KAAKkmB,cAAgBlmB,KAAKylB,eAAexU,cAAc,GAAG+U,GAC1DhmB,KAAKmmB,YAAc,GACnBnmB,KAAKomB,YAAc,GACnBpmB,KAAKqmB,QAAU,GAGnBC,UACI,IAAIC,EAAUvmB,KAAKmmB,YAAY7oB,KAAI,SAAUqU,EAAOpJ,GAChD,OAAOA,KAEXvI,KAAKwmB,QAAQD,GAGjBE,aACSzmB,KAAK8lB,SAAS,GAAGnnB,QAGtB2lB,EAAetkB,KAAK8lB,UACf5gB,SAASihB,IACGnmB,KAAK0mB,WAAWP,GAClBQ,IAAI3mB,KAAK2lB,WAAWiB,QAAU,IACrCT,EAAY1H,UAEhBze,KAAK+lB,YACL/lB,KAAKmmB,YAAcA,EACnBnmB,KAAKsmB,YACNtmB,MAGP6mB,UAAUC,GACN9mB,KAAK+mB,MAAMD,GACX9mB,KAAKgnB,UAAUF,GACf,MAAMnV,EAAQ3R,KAAKimB,WAAWa,GAC9B,IAAIG,EACJ,GAAIjnB,KAAK4lB,cAAc1a,eAAeyG,GAClCsV,EAAWjnB,KAAK4lB,cAAcjU,OAE7B,CACD,MAAM7S,EAASkB,KAAKylB,eAAepoB,SAASsU,GAC5C3R,KAAK0lB,eAAeroB,SAAS+H,KAAKtG,GAClCmoB,EAAWjnB,KAAK0lB,eAAeroB,SAASsB,OAAS,EACjDqB,KAAK4lB,cAAcjU,GAASsV,EAEhCjnB,KAAKmmB,YAAY/gB,KAAK6hB,GAG1BC,gBAAgBC,EAAMC,EAAMC,EAAWC,GACnC,MAAMpT,EAAI5M,KAAK2M,IAAIoT,IAAc/f,KAAK2M,IAAIoT,GAAa/f,KAAK2M,IAAIqT,IAChEtnB,KAAKunB,kBAAkBJ,EAAMC,EAAMlT,GACnClU,KAAKwnB,sBAAsBL,EAAMC,EAAMlT,GACvC,MAAMuT,EAASznB,KAAKimB,WAAWkB,GACzBO,EAAS1nB,KAAKimB,WAAWmB,GACzBO,EAAK3nB,KAAK4nB,eAAeH,EAAQC,GACvC,IAAI/V,EACJ,GAAI3R,KAAK6lB,mBAAmB3a,eAAeyc,GACvChW,EAAQ3R,KAAK6lB,mBAAmB8B,OAE/B,CACD,MAAME,EAAU7nB,KAAKylB,eAAepoB,SAASoqB,GACvCK,EAAU9nB,KAAKylB,eAAepoB,SAASqqB,GACvCK,EAAYF,EAAQnqB,QAAQ0B,KAAK0oB,EAAS5T,GAChDlU,KAAK0lB,eAAeroB,SAAS+H,KAAK2iB,GAClCpW,EAAQ3R,KAAK0lB,eAAeroB,SAASsB,OAAS,EAC9CqB,KAAK6lB,mBAAmB8B,GAAMhW,EAElC3R,KAAKmmB,YAAY/gB,KAAKuM,GACtB3R,KAAKgoB,eAAerW,GAGxBoV,MAAMD,GACF,IAAK9mB,KAAKkmB,cACN,OAEJ,MAAMvU,EAAQ3R,KAAKioB,SAASnB,GACtBoB,EAAKloB,KAAKkmB,cAAcvU,GAC9B3R,KAAKqmB,QAAQjhB,KAAK8iB,GAGtBX,kBAAkBJ,EAAMC,EAAMlT,GAC1B,IAAKlU,KAAKkmB,cACN,OAEJ,MAAMuB,EAASznB,KAAKioB,SAASd,GACvBO,EAAS1nB,KAAKioB,SAASb,GACvBe,EAAMnoB,KAAKkmB,cAAcuB,GACzBW,EAAMpoB,KAAKkmB,cAAcwB,GACzBQ,EAAKC,EAAIzqB,QAAQ0B,KAAKgpB,EAAKlU,GACjClU,KAAKqmB,QAAQjhB,KAAK8iB,GAGtBlB,UAAUF,GACN,IAAK9mB,KAAKimB,WAAWvF,cAAc/hB,OAC/B,OAEJ,MAAMgT,EAAQ3R,KAAKioB,SAASnB,GACtBF,EAAS5mB,KAAKimB,WAAWvF,cAAc/O,GAC7C3R,KAAKomB,YAAYhhB,KAAKwhB,GAG1BY,sBAAsBL,EAAMC,EAAMlT,GAC9B,IAAKlU,KAAKimB,WAAWvF,cAAc/hB,OAC/B,OAEJ,MAAM8oB,EAASznB,KAAKioB,SAASd,GACvBO,EAAS1nB,KAAKioB,SAASb,GACvBiB,EAAUroB,KAAKimB,WAAWvF,cAAc+G,GACxCa,EAAUtoB,KAAKimB,WAAWvF,cAAcgH,GACxCd,EAASyB,EAAQ3qB,QAAQ0B,KAAKkpB,EAASpU,GAAGqU,YAChDvoB,KAAKomB,YAAYhhB,KAAKwhB,GAG1BJ,QAAQD,GACJ,GAAuB,IAAnBA,EAAQ5nB,OAER,YADAqB,KAAKwoB,YAAYjC,EAAQ,GAAIA,EAAQ,GAAIA,EAAQ,IAGrD,MAAMkC,EAAQ,GACd,IAAK,IAAIlgB,EAAI,EAAGA,EAAIge,EAAQ5nB,OAAQ4J,IAChC,IAAK,IAAIiG,EAAIjG,EAAI,EAAGiG,EAAI+X,EAAQ5nB,OAAQ6P,IAAK,CACzC,IAAI+L,EAAOjT,KAAK2M,IAAI1L,EAAIiG,GACpB+L,EAAO,GAAKA,EAAOgM,EAAQ5nB,OAAS,GACpC8pB,EAAMrjB,KAAK,CAACmhB,EAAQhe,GAAIge,EAAQ/X,KAI5Cia,EAAMC,MAAK,CAAEC,EAAOC,IACF5oB,KAAK6oB,eAAeF,EAAM,GAAIA,EAAM,IACpC3oB,KAAK6oB,eAAeD,EAAM,GAAIA,EAAM,KAEnDE,KAAK9oB,OACR,MAAM2P,EAAI4W,EAAQwC,QAAQN,EAAM,GAAG,IAE7B3d,GADNyb,EAAUA,EAAQyC,MAAMrZ,GAAG+O,OAAO6H,EAAQyC,MAAM,EAAGrZ,KACjCoZ,QAAQN,EAAM,GAAG,IAC7BQ,EAAW1C,EAAQyC,MAAM,EAAGle,EAAI,GAChCoe,EAAW3C,EAAQyC,MAAMle,GAAG4T,OAAO6H,EAAQyC,MAAM,EAAG,IAC1DhpB,KAAKwmB,QAAQyC,GACbjpB,KAAKwmB,QAAQ0C,GAGjBV,YAAY7Y,EAAG7E,EAAG8E,GACd,IAAIqR,EAAU,KACVjhB,KAAKomB,YAAYznB,SACjBsiB,EAAU,CACNjhB,KAAKomB,YAAYzW,GACjB3P,KAAKomB,YAAYtb,GACjB9K,KAAKomB,YAAYxW,KAGzB,MAAMgP,EAAO,IAAI,KAAM5e,KAAKmmB,YAAYxW,GAAI3P,KAAKmmB,YAAYrb,GAAI9K,KAAKmmB,YAAYvW,GAAIqR,GACtFjhB,KAAK0lB,eAAetT,MAAMhN,KAAKwZ,GAC1B5e,KAAKkmB,eAGVlmB,KAAK0lB,eAAezU,cAAc,GAAG7L,KAAK,CACtCpF,KAAKqmB,QAAQ1W,GACb3P,KAAKqmB,QAAQvb,GACb9K,KAAKqmB,QAAQzW,KAIrBiZ,eAAelZ,EAAG7E,GACd,MAAM2c,EAASznB,KAAKmmB,YAAYxW,GAC1B+X,EAAS1nB,KAAKmmB,YAAYrb,GAC1B+c,EAAU7nB,KAAK0lB,eAAeroB,SAASoqB,GACvCK,EAAU9nB,KAAK0lB,eAAeroB,SAASqqB,GAC7C,OAAOG,EAAQsB,kBAAkBrB,GAGrCF,eAAeH,EAAQC,GACnB,MAAO,CAACD,EAAQC,GAAQgB,OAAOje,KAAK,KAGxCwd,SAASnB,GACL,OAAOzC,EAAU0E,QAAQjC,GAG7BkB,eAAerW,GACX,MAAMyX,EAAYppB,KAAK8lB,SAASnnB,OAAS,EACzC,IAAIimB,EAAO5kB,KAAK8lB,SAASsD,GACrBxE,EAAKjmB,OAAS,EACdimB,EAAKxf,KAAKuM,GAGV3R,KAAK8lB,SAAS1gB,KAAK,CAACuM,IAI5B+U,WAAWP,GACP,MAAM9oB,EAAW8oB,EAAY7oB,KAAMqU,GACxB3R,KAAK0lB,eAAeroB,SAASsU,IACrCmX,KAAK9oB,OACFqpB,EAAQhsB,EAAS,GAAGK,QAAQ4rB,IAAIjsB,EAAS,IACzCksB,EAAQlsB,EAAS,GAAGK,QAAQ4rB,IAAIjsB,EAAS,IAC/C,OAAOgsB,EAAMG,MAAMD,GAAOhB,aCrN3B,MAAM5Q,EAAgB,CAAC1P,EAAUwP,EAAOgP,KAC3C,MAAMgD,EAAS,IAAI,KACbC,EAAU,IAAIlE,EAAgBvd,EAAUwhB,EAAQhS,GAChDkS,EAAY,GACZC,EAAY,GAiDlB,OAhDA3hB,EAAS5K,SAAS6H,SAASpG,IACvB,MAAM8S,EAAWiY,EAAa/qB,EAAQ2Y,GAChC5W,EAAWipB,EAAmBlY,GACpC+X,EAAUvkB,KAAKwM,GACfgY,EAAUxkB,KAAKvE,MAEnBoH,EAASmK,MAAMlN,SAAQ,SAAU0Z,EAAMD,GACnC,MAAMoL,EAAgB1F,EAAU/mB,KAAI,SAAUwpB,GAC1C,OAAO8C,EAAUhL,EAAKkI,OAE1B,IAAsC,IAAlCiD,EAAchB,QAAQ7E,KACW,IAAjC6F,EAAchB,QAAQ5E,GACtB,OAEJuF,EAAQ3D,UAAUpH,GAClB,IAAIqL,EAAU3F,EAAUA,EAAU1lB,OAAS,GACvCuT,EAAY0M,EAAKoL,GACjBC,EAAeN,EAAUzX,GACzBgY,EAAeN,EAAU1X,GAC7BmS,EAAU/mB,KAAKwpB,IACX,IAAInV,EAAQiN,EAAKkI,GACblV,EAAW+X,EAAUhY,GACrB9Q,EAAW+oB,EAAUjY,GACrB9Q,IAAaqjB,IACTgG,IAAiB/F,GACjBuF,EAAQxC,gBAAgB8C,EAASlD,EAAKmD,EAAcrY,GACpD8X,EAAQ7C,UAAUC,IAGlB4C,EAAQ7C,UAAUC,IAGtBjmB,IAAaujB,GACbsF,EAAQ7C,UAAUC,GAElBjmB,IAAasjB,GAAQ+F,IAAiBhG,GACtCwF,EAAQxC,gBAAgB8C,EAASlD,EAAKmD,EAAcrY,GAExDoY,EAAUlD,EACV5U,EAAYP,EACZuY,EAAerpB,EACfopB,EAAerY,KAEnB8X,EAAQpD,aAERG,GACAiD,EAAQjD,aAELgD,GAELK,EAAsBlY,GACpBA,EAAW,EACJuS,EAEPvS,EAAW,EACJsS,EAEJE,EAELyF,EAAe,CAAC/qB,EAAQ2Y,IACnBA,EAAM0S,gBAAgBrrB,KCnE7BsrB,EAA2B,GAG/B,SAASC,EAAoBC,GAE5B,IAAIC,EAAeH,EAAyBE,GAC5C,QAAqBzO,IAAjB0O,EACH,OAAOA,EAAanuB,QAGrB,IAAIouB,EAASJ,EAAyBE,GAAY,CAGjDluB,QAAS,IAOV,OAHAquB,EAAoBH,GAAUnf,KAAKqf,EAAOpuB,QAASouB,EAAQA,EAAOpuB,QAASiuB,GAGpEG,EAAOpuB,QAIfiuB,EAAoBK,EAAID,EzBzBpBxuB,EAAW,GACfouB,EAAoBM,EAAI,CAACrK,EAAQsK,EAAUC,EAAIC,KAC9C,IAAGF,EAAH,CAMA,IAAIG,EAAeC,EAAAA,EACnB,IAASziB,EAAI,EAAGA,EAAItM,EAAS0C,OAAQ4J,IAAK,CAGzC,IAFA,IAAKqiB,EAAUC,EAAIC,GAAY7uB,EAASsM,GACpC0iB,GAAY,EACPzc,EAAI,EAAGA,EAAIoc,EAASjsB,OAAQ6P,MACpB,EAAXsc,GAAsBC,GAAgBD,IAAa5uB,OAAOgvB,KAAKb,EAAoBM,GAAGQ,OAAOrE,GAASuD,EAAoBM,EAAE7D,GAAK8D,EAASpc,MAC9Ioc,EAASQ,OAAO5c,IAAK,IAErByc,GAAY,EACTH,EAAWC,IAAcA,EAAeD,IAG7C,GAAGG,EAAW,CACbhvB,EAASmvB,OAAO7iB,IAAK,GACrB,IAAI8iB,EAAIR,SACEhP,IAANwP,IAAiB/K,EAAS+K,IAGhC,OAAO/K,EAvBNwK,EAAWA,GAAY,EACvB,IAAI,IAAIviB,EAAItM,EAAS0C,OAAQ4J,EAAI,GAAKtM,EAASsM,EAAI,GAAG,GAAKuiB,EAAUviB,IAAKtM,EAASsM,GAAKtM,EAASsM,EAAI,GACrGtM,EAASsM,GAAK,CAACqiB,EAAUC,EAAIC,I0BJ/BT,EAAoBxf,EAAI,CAACzO,EAASkvB,KACjC,IAAI,IAAIxE,KAAOwE,EACXjB,EAAoBkB,EAAED,EAAYxE,KAASuD,EAAoBkB,EAAEnvB,EAAS0qB,IAC5E5qB,OAAOC,eAAeC,EAAS0qB,EAAK,CAAE0E,YAAY,EAAMpV,IAAKkV,EAAWxE,MCJ3EuD,EAAoBkB,EAAI,CAACE,EAAKC,IAAUxvB,OAAO2G,UAAUqI,eAAeC,KAAKsgB,EAAKC,GCClFrB,EAAoBgB,EAAKjvB,IACH,oBAAXuvB,QAA0BA,OAAOC,aAC1C1vB,OAAOC,eAAeC,EAASuvB,OAAOC,YAAa,CAAEvvB,MAAO,WAE7DH,OAAOC,eAAeC,EAAS,aAAc,CAAEC,OAAO,K,MCAvD,IAAIwvB,EAAkB,CACrB,IAAK,GAaNxB,EAAoBM,EAAEnc,EAAKsd,GAA0C,IAA7BD,EAAgBC,GAGxD,IAAIC,EAAuB,CAACC,EAA4BC,KACvD,IAGI3B,EAAUwB,GAHTlB,EAAUsB,EAAaC,GAAWF,EAGhB1jB,EAAI,EAC3B,GAAGqiB,EAASwB,MAAMzE,GAAgC,IAAxBkE,EAAgBlE,KAAa,CACtD,IAAI2C,KAAY4B,EACZ7B,EAAoBkB,EAAEW,EAAa5B,KACrCD,EAAoBK,EAAEJ,GAAY4B,EAAY5B,IAGhD,GAAG6B,EAAS,IAAI7L,EAAS6L,EAAQ9B,GAGlC,IADG2B,GAA4BA,EAA2BC,GACrD1jB,EAAIqiB,EAASjsB,OAAQ4J,IACzBujB,EAAUlB,EAASriB,GAChB8hB,EAAoBkB,EAAEM,EAAiBC,IAAYD,EAAgBC,IACrED,EAAgBC,GAAS,KAE1BD,EAAgBC,GAAW,EAE5B,OAAOzB,EAAoBM,EAAErK,IAG1B+L,EAAqBC,KAAuB,iBAAIA,KAAuB,kBAAK,GAChFD,EAAmBnnB,QAAQ6mB,EAAqBjD,KAAK,KAAM,IAC3DuD,EAAmBjnB,KAAO2mB,EAAqBjD,KAAK,KAAMuD,EAAmBjnB,KAAK0jB,KAAKuD,K,GC7CvF,IAAIE,EAAsBlC,EAAoBM,OAAE9O,EAAW,CAAC,MAAM,IAAOwO,EAAoB,OAC7FkC,EAAsBlC,EAAoBM,EAAE4B,I","sources":["webpack://ngdg/webpack/runtime/chunk loaded","webpack://ngdg/./src/cjs/BumpMapper.js","webpack://ngdg/./src/cjs/DildoGeneration.js","webpack://ngdg/./src/cjs/DildoGeometry.js","webpack://ngdg/./src/cjs/DildoMaterials.js","webpack://ngdg/./src/cjs/GeometryGenerationHelpers.js","webpack://ngdg/./src/cjs/ImageStore.js","webpack://ngdg/./src/cjs/LocalstorageIO.js","webpack://ngdg/./src/cjs/PathFinder.js","webpack://ngdg/./src/cjs/PlaneMeshIntersection.js","webpack://ngdg/./src/cjs/UVHelpers.js","webpack://ngdg/./src/cjs/clearDuplicateVertices3.js","webpack://ngdg/./src/cjs/computeVertexNormals.js","webpack://ngdg/./src/cjs/constants.js","webpack://ngdg/./src/cjs/defaults.js","webpack://ngdg/./src/cjs/entry.js","webpack://ngdg/./src/cjs/isMobileDevice.js","webpack://ngdg/./src/cjs/locateVertexInArray.js","webpack://ngdg/./src/cjs/mergeGeometries.js","webpack://ngdg/./src/cjs/ngdg.js","webpack://ngdg/./src/cjs/randomWebColor.js","webpack://ngdg/../threejs-slice-geometry-typescript/src/esm/constants.js","webpack://ngdg/../threejs-slice-geometry-typescript/src/esm/faces-from-edges.js","webpack://ngdg/../threejs-slice-geometry-typescript/src/esm/GeometryBuilder.js","webpack://ngdg/../threejs-slice-geometry-typescript/src/esm/slice.js","webpack://ngdg/webpack/bootstrap","webpack://ngdg/webpack/runtime/define property getters","webpack://ngdg/webpack/runtime/hasOwnProperty shorthand","webpack://ngdg/webpack/runtime/make namespace object","webpack://ngdg/webpack/runtime/jsonp chunk loading","webpack://ngdg/webpack/startup"],"sourcesContent":["var deferred = [];\n__webpack_require__.O = (result, chunkIds, fn, priority) => {\n\tif(chunkIds) {\n\t\tpriority = priority || 0;\n\t\tfor(var i = deferred.length; i > 0 && deferred[i - 1][2] > priority; i--) deferred[i] = deferred[i - 1];\n\t\tdeferred[i] = [chunkIds, fn, priority];\n\t\treturn;\n\t}\n\tvar notFulfilled = Infinity;\n\tfor (var i = 0; i < deferred.length; i++) {\n\t\tvar [chunkIds, fn, priority] = deferred[i];\n\t\tvar fulfilled = true;\n\t\tfor (var j = 0; j < chunkIds.length; j++) {\n\t\t\tif ((priority & 1 === 0 || notFulfilled >= priority) && Object.keys(__webpack_require__.O).every((key) => (__webpack_require__.O[key](chunkIds[j])))) {\n\t\t\t\tchunkIds.splice(j--, 1);\n\t\t\t} else {\n\t\t\t\tfulfilled = false;\n\t\t\t\tif(priority < notFulfilled) notFulfilled = priority;\n\t\t\t}\n\t\t}\n\t\tif(fulfilled) {\n\t\t\tdeferred.splice(i--, 1)\n\t\t\tvar r = fn();\n\t\t\tif (r !== undefined) result = r;\n\t\t}\n\t}\n\treturn result;\n};","\"use strict\";\n/**\n * A helper to apply bumpmaps to any rectangular mesh.\n *\n * @author  Ikaros Kappler\n * @date    2021-09-06\n * @modified 2022-02-22 Replaced Gmetry by ThreeGeometryHellfix.Gmetry.\n * @version 1.0.1\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.BumpMapper = void 0;\nvar THREE = require(\"three\");\nvar computeVertexNormals_1 = require(\"./computeVertexNormals\");\nvar GeometryGenerationHelpers_1 = require(\"./GeometryGenerationHelpers\");\nvar three_geometry_hellfix_1 = require(\"three-geometry-hellfix\");\nexports.BumpMapper = {\n    applyBumpmap: function (dildoGeometry, bufferedGeometry, bumpmap, material, options) {\n        var collectedVertexNormals = (0, computeVertexNormals_1.computeVertexNormals)(dildoGeometry, bufferedGeometry);\n        var dildoNormalGeometry = new three_geometry_hellfix_1.Gmetry();\n        dildoNormalGeometry.vertices = collectedVertexNormals.map(function (normalLine) {\n            var endPoint = normalLine.end.clone();\n            GeometryGenerationHelpers_1.GeometryGenerationHelpers.normalizeVectorXYZ(normalLine.start, endPoint, options.bumpmapStrength);\n            return endPoint;\n        });\n        var dildoNormalsMesh = new THREE.Points(dildoNormalGeometry.toBufferGeometry(), new THREE.PointsMaterial({\n            size: 1.4,\n            color: 0x00ffff\n        }));\n        // if (options.showBumpmapTargets) {\n        //   dildoNormalsMesh.position.y = -100;\n        //   this.addMesh(dildoNormalsMesh);\n        // }\n        var dildoMesh = null;\n        console.log(\"options.useBumpmap\", options.useBumpmap, \"bumpmap\", bumpmap);\n        // const heightMap = createHeightMapFromImage( bumpmapTexture ):\n        if (options.useBumpmap && bumpmap) {\n            for (var y = 0; y < dildoGeometry.vertexMatrix.length; y++) {\n                for (var x = 0; x < dildoGeometry.vertexMatrix[y].length; x++) {\n                    var vertIndex = dildoGeometry.vertexMatrix[y][x];\n                    var vertex = dildoGeometry.vertices[vertIndex];\n                    var yRatio = 1.0 - y / (dildoGeometry.vertexMatrix.length - 1);\n                    var xRatio = x / (dildoGeometry.vertexMatrix[y].length - 1);\n                    var lerpFactor = bumpmap.getHeightAt(xRatio, yRatio);\n                    var lerpTarget = dildoNormalGeometry.vertices[vertIndex];\n                    vertex.lerp(lerpTarget, lerpFactor);\n                }\n            }\n            // Also lerp top point\n            //   const vertIndex: number = dildoGeometry.topIndex;\n            //   //   const vertIndex: number = dildoGeometry.vertexMatrix[dildoGeometry.vertexMatrix.length - 1][0];\n            //   const vertex: THREE.Vector3 = dildoGeometry.vertices[vertIndex];\n            //   const yRatio: number = 0.0;\n            //   const xRatio: number = 0.5;\n            //   const lerpFactor: number = bumpmap.getHeightAt(xRatio, yRatio);\n            //   const lerpTarget: THREE.Vector3 = dildoNormalGeometry.vertices[vertIndex];\n            //   vertex.lerp(lerpTarget, lerpFactor);\n            // Override the buffered geometry! (bumpmap has been applied)\n            // TODO: verify correctness with Gmery\n            // bufferedGeometry = new THREE.BufferGeometry().fromGeometry(dildoGeometry as unknown as Gmetry);\n            bufferedGeometry = dildoGeometry.toBufferGeometry();\n            bufferedGeometry.computeVertexNormals();\n            // Override the mesh! (bumpmap has been applied)\n            dildoMesh = new THREE.Mesh(bufferedGeometry, material);\n        }\n        return { dildoMesh: dildoMesh, dildoNormalsMesh: dildoNormalsMesh };\n    }\n};\n//# sourceMappingURL=BumpMapper.js.map","\"use strict\";\n/**\n * A class to manage 3d scenes and the generation of dildo models.\n *\n * @author   Ikaros Kappler\n * @date     2020-07-01\n * @modified 2020-09-11 Added proper texture loading.\n * @modified 2021-06-07 Fixing `removeCachedGeometries`. Adding bending of model.\n * @modified 2021-08-29 Ported this class to Typescript from vanilla JS.\n * @modified 2022-02-03 Added `clearResults` function.\n * @modified 2022-02-22 Replaced Gmetry by ThreeGeometryHellfix.Gmetry.\n * @version  1.2.3\n **/\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.DildoGeneration = void 0;\nvar THREE = require(\"three\");\nvar VertexNormalsHelper_1 = require(\"three/examples/jsm/helpers/VertexNormalsHelper\");\nvar DildoGeometry_1 = require(\"./DildoGeometry\");\nvar DildoMaterials_1 = require(\"./DildoMaterials\");\nvar GeometryGenerationHelpers_1 = require(\"./GeometryGenerationHelpers\");\nvar mergeGeometries_1 = require(\"./mergeGeometries\");\nvar PathFinder_1 = require(\"./PathFinder\");\nvar randomWebColor_1 = require(\"./randomWebColor\");\nvar constants_1 = require(\"./constants\");\nvar BumpMapper_1 = require(\"./BumpMapper\");\nvar three_geometry_hellfix_1 = require(\"three-geometry-hellfix\");\nvar DildoGeneration = /** @class */ (function () {\n    function DildoGeneration(canvasId, options) {\n        this.canvas = document.getElementById(canvasId);\n        this.parent = this.canvas.parentElement;\n        this.scene = new THREE.Scene();\n        this.camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 10000);\n        this.camera.position.z = 500;\n        var lightDistanceFactor = 10.0;\n        var intensityFactor = 1.0;\n        this.ambientLightA = new THREE.AmbientLight(0x444444);\n        this.ambientLightA.position.set(350, 0, -350).multiplyScalar(lightDistanceFactor * 5);\n        // this.ambientLightA = new THREE.PointLight(0xffffff, intensityFactor * 5.0, 350.0 * lightDistanceFactor, 0.5); // color, intensity, distance, decay);\n        // this.ambientLightA.position.set(350, 0, -350).multiplyScalar(lightDistanceFactor);\n        this.scene.add(this.ambientLightA);\n        this.ambientLightB = new THREE.PointLight(0xffffff, intensityFactor * 5.0, 350.0 * lightDistanceFactor, 0.5); // color, intensity, distance, decay);\n        this.ambientLightB.position.set(-350, 0, 350).multiplyScalar(lightDistanceFactor);\n        this.scene.add(this.ambientLightB);\n        this.directionalLightA = new THREE.DirectionalLight(0xffffff, intensityFactor * 2.0);\n        // this.directionalLightA = new THREE.PointLight(0xffffff, 1.0, 350.0 * lightDistanceFactor, 0.5); // color, intensity, distance, decay);\n        this.directionalLightA.position.set(350, 350, 350).multiplyScalar(lightDistanceFactor);\n        this.scene.add(this.directionalLightA);\n        this.scene.add(this.directionalLightA.target);\n        this.directionalLightB = new THREE.DirectionalLight(0xffffff, intensityFactor * 2.0);\n        this.directionalLightB.position.set(-350, -350, -50).multiplyScalar(lightDistanceFactor);\n        this.scene.add(this.directionalLightB);\n        this.renderer = new THREE.WebGLRenderer({\n            canvas: this.canvas,\n            preserveDrawingBuffer: true,\n            antialias: true // false\n        });\n        // TODO: check if this works!\n        // this.controls = new OrbitControls(this.camera, this.renderer.domElement);\n        this.controls = options.makeOrbitControls(this.camera, this.renderer.domElement);\n        this.controls.update();\n        // Cache all geometries for later removal\n        this.geometries = [];\n        // Remember partial results\n        // Record<string,object>\n        this.partialResults = {};\n        // Record<string.THREE.Mesh>\n        this.splitResults = {};\n        var _self = this;\n        window.addEventListener(\"resize\", function () {\n            _self.resizeCanvas();\n        });\n        this.resizeCanvas();\n        var animate = function () {\n            requestAnimationFrame(animate);\n            _self.controls.update();\n            _self.renderer.render(_self.scene, _self.camera);\n        };\n        animate();\n    }\n    /**\n     * Resize the 3d canvas to fit its container.\n     */\n    DildoGeneration.prototype.resizeCanvas = function () {\n        var width = window.innerWidth || document.documentElement.clientWidth || document.body.clientWidth;\n        var height = window.innerHeight || document.documentElement.clientHeight || document.body.clientHeight;\n        this.canvas.width = width;\n        this.canvas.height = height;\n        this.canvas.style.width = \"\" + width + \"px\";\n        this.canvas.style.height = \"\" + height + \"px\";\n        this.canvas.setAttribute(\"width\", \"\" + width + \"px\");\n        this.canvas.setAttribute(\"height\", height + \"px\");\n        this.renderer.setSize(width, height);\n        // What am I doing here?\n        this.camera.setViewOffset(width, height, width / 4, height / 20, width, height);\n    };\n    /**\n     * Clears the current scene and rebuilds everything from scratch according to the\n     * mesh options being passed.\n     *\n     * @param {BezierPath} options.outline\n     * @param {number}     options.segmentCount\n     * @param {number}     options.outlineSegmentCount (>= 2).\n     * @param {number}     options.bendAngle The bending angle in degrees (!).\n     * @param {boolean}    options.performSlice\n     * @param {boolean?}   options.useTextureImage\n     * @param {string?}    options.textureImagePath\n     * @param {boolean?}   options.wireframe\n     * @param {string}     options.renderFaces - \"double\" or \"front\" (default) or \"back\"\n     **/\n    DildoGeneration.prototype.rebuild = function (options) {\n        this.removeCachedGeometries();\n        this.clearResults();\n        var baseRadius = options.outline.getBounds().width;\n        var baseShape = GeometryGenerationHelpers_1.GeometryGenerationHelpers.mkCircularPolygon(baseRadius, options.shapeSegmentCount, options.baseShapeExcentricity);\n        var useBumpmap = typeof options.useBumpmap !== \"undefined\" ? options.useBumpmap : false;\n        // const bumpmapPath = \"./assets/img/bumpmap.png\";\n        // const bumpmapTexture: THREE.Texture | null = useBumpmap ? DildoMaterials.loadTextureImage(bumpmapPath) : null;\n        var bumpmap = useBumpmap && options.bumpmap ? options.bumpmap : null;\n        var dildoGeometry = new DildoGeometry_1.DildoGeometry(Object.assign({ baseShape: baseShape /*, bumpmapTexture: bumpmapTexture */ }, options));\n        var useTextureImage = options.useTextureImage && typeof options.textureImagePath !== \"undefined\";\n        var textureImagePath = typeof options.textureImagePath !== \"undefined\" ? options.textureImagePath : null;\n        var doubleSingleSide = options.renderFaces === \"double\" ? THREE.DoubleSide : options.renderFaces === \"back\" ? THREE.BackSide : THREE.FrontSide;\n        var wireframe = typeof options.wireframe !== \"undefined\" ? options.wireframe : false;\n        var material = DildoMaterials_1.DildoMaterials.createMainMaterial(useTextureImage, wireframe, textureImagePath, doubleSingleSide);\n        // This can be overriden in later steps! (after bumpmap was applied)\n        // let bufferedGeometry: THREE.BufferGeometry = new THREE.BufferGeometry().fromGeometry(\n        //   dildoGeometry as unknown as Gmetry\n        // );\n        // TODO: verify correctness\n        var bufferedGeometry = dildoGeometry.toBufferGeometry();\n        bufferedGeometry.computeVertexNormals();\n        // This can be overriden in later steps! (after bumpmap was applied)\n        var dildoMesh = new THREE.Mesh(bufferedGeometry, material);\n        this.camera.lookAt(new THREE.Vector3(20, 0, 150));\n        this.camera.lookAt(dildoMesh.position);\n        var spineGeometry = new three_geometry_hellfix_1.Gmetry();\n        dildoGeometry.spineVertices.forEach(function (spineVert) {\n            spineGeometry.vertices.push(spineVert.clone());\n        });\n        if (options.addSpine) {\n            GeometryGenerationHelpers_1.GeometryGenerationHelpers.addSpine(this, spineGeometry);\n        }\n        // Add perpendicular path?\n        if (options.showBasicPerpendiculars) {\n            GeometryGenerationHelpers_1.GeometryGenerationHelpers.addPerpendicularPaths(this, dildoGeometry);\n        }\n        // Show computed dildo normals?\n        // if (options.previewBumpmap || options.useBumpmap) {\n        if (options.useBumpmap) {\n            // const collectedVertexNormals: Array<THREE.Line3> = computeVertexNormals(\n            //   dildoGeometry as unknown as Gmetry,\n            //   bufferedGeometry\n            // );\n            // const dildoNormalGeometry = new Gmetry();\n            // dildoNormalGeometry.vertices = collectedVertexNormals.map((normalLine: THREE.Line3) => {\n            //   const endPoint: THREE.Vector3 = normalLine.end.clone();\n            //   GeometryGenerationHelpers.normalizeVectorXYZ(normalLine.start, endPoint, options.bumpmapStrength);\n            //   return endPoint;\n            // });\n            // const dildoNormalsMesh: THREE.Points = new THREE.Points(\n            //   dildoNormalGeometry,\n            //   new THREE.PointsMaterial({\n            //     size: 1.4,\n            //     color: 0x00ffff\n            //   })\n            // );\n            // if (options.showBumpmapTargets) {\n            //   dildoNormalsMesh.position.y = -100;\n            //   this.addMesh(dildoNormalsMesh);\n            // }\n            // console.log(\"options.useBumpmap\", options.useBumpmap, \"bumpmap\", bumpmap);\n            // // const heightMap = createHeightMapFromImage( bumpmapTexture ):\n            // if (options.useBumpmap && bumpmap) {\n            //   for (var y = 0; y < dildoGeometry.vertexMatrix.length; y++) {\n            //     for (var x = 0; x < dildoGeometry.vertexMatrix[y].length; x++) {\n            //       const vertIndex: number = dildoGeometry.vertexMatrix[y][x];\n            //       const vertex: THREE.Vector3 = dildoGeometry.vertices[vertIndex];\n            //       const yRatio: number = y / (dildoGeometry.vertexMatrix.length - 1);\n            //       const xRatio: number = x / (dildoGeometry.vertexMatrix[y].length - 1);\n            //       const lerpFactor: number = bumpmap.getHeightAt(xRatio, yRatio);\n            //       const lerpTarget: THREE.Vector3 = dildoNormalGeometry.vertices[vertIndex];\n            //       vertex.lerp(lerpTarget, lerpFactor);\n            //     }\n            //   }\n            //   // Override the buffered geometry! (bumpmap has been applied)\n            //   bufferedGeometry = new THREE.BufferGeometry().fromGeometry(dildoGeometry as unknown as Gmetry);\n            //   bufferedGeometry.computeVertexNormals();\n            //   // Override the mesh! (bumpmap has been applied)\n            //   dildoMesh = new THREE.Mesh(bufferedGeometry, material);\n            // }\n            var _a = BumpMapper_1.BumpMapper.applyBumpmap(dildoGeometry, bufferedGeometry, bumpmap, material, options), bumpmappedDildoMesh = _a.dildoMesh, dildoNormalsMesh = _a.dildoNormalsMesh;\n            dildoMesh = bumpmappedDildoMesh;\n            if (options.showBumpmapTargets) {\n                // dildoNormalsMesh.position.y = -100;\n                dildoNormalsMesh.position.y = constants_1.SPLIT_MESH_OFFSET.y;\n                this.addMesh(dildoNormalsMesh);\n            }\n        }\n        if (options.performSlice) {\n            this.__performPlaneSlice(dildoMesh, dildoGeometry, wireframe, useTextureImage, textureImagePath, options);\n            // The CSG operations are not reliable.\n            // this.__performCsgSlice(latheMesh, geometry, material);\n        }\n        else {\n            // dildoMesh.position.y = -100;\n            dildoMesh.position.y = constants_1.SPLIT_MESH_OFFSET.y;\n            dildoMesh.userData[\"isExportable\"] = true;\n            this.addMesh(dildoMesh);\n            if (options.showNormals) {\n                var vnHelper = new VertexNormalsHelper_1.VertexNormalsHelper(dildoMesh, options.normalsLength, 0x00ff00); // Fourth param 1?\n                // TODO: use addMesh() here?\n                this.scene.add(vnHelper);\n                this.geometries.push(vnHelper);\n            }\n        }\n    };\n    /**\n     * Perform the actual slice operation.\n     *\n     * This will create several new meshes:\n     *  * a left geometry slice (along the z- axis).\n     *  * a right geometry slice (along the z+ axis).\n     *  * an inner slice cut geometry (inside the dildo model, cutting it into two halves).\n     *  * an outer slice cut geometry (inside the mould model, cutting that one into two halves).\n     *\n     * These will always be generated, even if the options tell different; if so then they are set\n     * to be invisible.\n     *\n     * @param {ThreeGeometryHellfix.Gmetry} latheMesh - The buffered dildo geometry (required to perform the slice operation).\n     * @param {DildoGeometry} latheUnbufferedGeometry - The unbuffered dildo geometry (required to obtain the perpendicular path lines).\n     * @param {boolean} wireframe\n     */\n    DildoGeneration.prototype.__performPlaneSlice = function (latheMesh, latheUnbufferedGeometry, wireframe, useTextureImage, textureImagePath, options) {\n        // var epsilon = 0.000001;\n        var leftPlane = new THREE.Plane(new THREE.Vector3(0, 0, 1), 0);\n        var leftSliceGeometry = GeometryGenerationHelpers_1.GeometryGenerationHelpers.makeSlice(latheUnbufferedGeometry, leftPlane);\n        var rightPlane = new THREE.Plane(new THREE.Vector3(0, 0, -1), 0);\n        var rightSliceGeometry = GeometryGenerationHelpers_1.GeometryGenerationHelpers.makeSlice(latheUnbufferedGeometry, rightPlane);\n        var sliceMaterial = DildoMaterials_1.DildoMaterials.createSliceMaterial(useTextureImage, wireframe, textureImagePath);\n        // Find points on intersection path (this is a single path in this configuration)\n        var planeGeom = new THREE.PlaneGeometry(300, 500);\n        var planeMesh = new THREE.Mesh(planeGeom, new THREE.MeshBasicMaterial({\n            color: 0x484848,\n            transparent: true,\n            opacity: 0.35,\n            side: THREE.DoubleSide\n        }));\n        planeMesh.rotation.x = Math.PI / 5;\n        this.partialResults[constants_1.KEY_SPLIT_PANE_MESH] = planeMesh;\n        if (options.showSplitPane) {\n            planeMesh.position.z = 0.5;\n            this.addMesh(planeMesh);\n        }\n        var planeIntersectionPoints = GeometryGenerationHelpers_1.GeometryGenerationHelpers.makeAndAddPlaneIntersection(this, latheMesh, latheUnbufferedGeometry, planeMesh, planeGeom, options);\n        // Find the connected path (there is only one if you choose the cut plane properly)\n        // Note that it doesn't matter which slice geometry we use as left and right match\n        // perfectly together at their cut plane.\n        // Array<number[]>\n        var connectedPaths = new PathFinder_1.PathFinder().findAllPathsOnMesh(leftSliceGeometry, planeIntersectionPoints);\n        // TEST what the connected paths look like\n        // TODO: add an option and only add to scene if desired.\n        for (var p = 0; p < connectedPaths.length; p++) {\n            // TODO: verify\n            // const geometry: Gmetry = new Gmetry();\n            // geometry.vertices = connectedPaths[p].map(function (geometryVertexIndex) {\n            //   return leftSliceGeometry.vertices[geometryVertexIndex];\n            // });\n            var vertices = connectedPaths[p].map(function (geometryVertexIndex) {\n                return leftSliceGeometry.vertices[geometryVertexIndex];\n            });\n            var geometry = GeometryGenerationHelpers_1.GeometryGenerationHelpers.verticesToBufferGeometry(vertices);\n            var linesMesh_1 = new THREE.Line(geometry, // .toBufferGeometry(),\n            new THREE.LineBasicMaterial({\n                color: (0, randomWebColor_1.randomWebColor)(i, \"Mixed\") // 0x8800a8\n            }));\n            // linesMesh.position.y = -100;\n            linesMesh_1.position.y = constants_1.SPLIT_MESH_OFFSET.y;\n            // linesMesh.position.z = -50;\n            this.addMesh(linesMesh_1);\n        }\n        if (options.addPrecalculatedShapeOutlines) {\n            // TEST what the line mesh looks like\n            var pointGeometry = new three_geometry_hellfix_1.Gmetry();\n            pointGeometry.vertices = planeIntersectionPoints;\n            var linesMesh = new THREE.Line(pointGeometry.toBufferGeometry(), new THREE.LineBasicMaterial({\n                color: 0x8800a8\n            }));\n            // linesMesh.position.y = -100;\n            // linesMesh.position.z = -50;\n            linesMesh.position.y = constants_1.SPLIT_MESH_OFFSET.y;\n            linesMesh.position.z = constants_1.SPLIT_MESH_OFFSET.z;\n            this.addMesh(linesMesh);\n        }\n        // Triangulate connected paths\n        var triangulatedGeometries = [];\n        for (var i = 0; i < connectedPaths.length; i++) {\n            var triangulationGeometry = GeometryGenerationHelpers_1.GeometryGenerationHelpers.makePlaneTriangulation(this, leftSliceGeometry, connectedPaths[i], options);\n            triangulatedGeometries.push(triangulationGeometry);\n            // Merge together left and right slice geometry with the triangulated\n            // cut faces.\n            if (options.closeCutAreas) {\n                (0, mergeGeometries_1.mergeGeometries)(leftSliceGeometry, triangulationGeometry, constants_1.EPS);\n                (0, mergeGeometries_1.mergeGeometries)(rightSliceGeometry, triangulationGeometry, constants_1.EPS);\n            }\n        }\n        // const arrangeSplitsOnPlane = true;\n        if (options.showLeftSplit) {\n            leftSliceGeometry.uvsNeedUpdate = true;\n            // TODO: check if this is still required\n            leftSliceGeometry.buffersNeedUpdate = true;\n            leftSliceGeometry.computeVertexNormals();\n            var slicedMeshLeft = new THREE.Mesh(leftSliceGeometry.toBufferGeometry(), sliceMaterial);\n            // slicedMeshLeft.position.y = -100;\n            // slicedMeshLeft.position.z = -50;\n            slicedMeshLeft.position.y = constants_1.SPLIT_MESH_OFFSET.y;\n            slicedMeshLeft.position.z = constants_1.SPLIT_MESH_OFFSET.z;\n            // if (arrangeSplitsOnPlane) {\n            //   // slicedMeshLeft.rotation.x = -Math.PI / 2;\n            //   slicedMeshLeft.rotation.y = -Math.PI / 2.0;\n            //   slicedMeshLeft.rotation.z = Math.PI / 2.0;\n            // }\n            slicedMeshLeft.userData[\"isExportable\"] = true;\n            this.addMesh(slicedMeshLeft);\n            this.splitResults[constants_1.KEY_SLICED_MESH_LEFT] = slicedMeshLeft;\n            if (options.showNormals) {\n                var vnHelper = new VertexNormalsHelper_1.VertexNormalsHelper(slicedMeshLeft, options.normalsLength, 0x00ff00);\n                this.scene.add(vnHelper);\n                this.geometries.push(vnHelper);\n            }\n        }\n        if (options.showRightSplit) {\n            rightSliceGeometry.uvsNeedUpdate = true;\n            // TODO: check if this is still required\n            rightSliceGeometry.buffersNeedUpdate = true;\n            rightSliceGeometry.computeVertexNormals();\n            var slicedMeshRight = new THREE.Mesh(rightSliceGeometry.toBufferGeometry(), sliceMaterial);\n            // slicedMeshRight.position.y = -100;\n            // slicedMeshRight.position.z = 50;\n            slicedMeshRight.position.y = constants_1.SPLIT_MESH_OFFSET.y;\n            slicedMeshRight.position.z = -constants_1.SPLIT_MESH_OFFSET.z; // Important: use inverse value here!\n            slicedMeshRight.userData[\"isExportable\"] = true;\n            this.addMesh(slicedMeshRight);\n            this.splitResults[constants_1.KEY_SLICED_MESH_RIGHT] = slicedMeshRight;\n            if (options.showNormals) {\n                var vnHelper = new VertexNormalsHelper_1.VertexNormalsHelper(slicedMeshRight, options.normalsLength, 0x00ff00);\n                this.scene.add(vnHelper);\n                this.geometries.push(vnHelper);\n            }\n        }\n        // Remember everything\n        this.partialResults[constants_1.KEY_LEFT_SLICE_PLANE] = leftPlane;\n        this.partialResults[constants_1.KEY_LEFT_SLICE_GEOMETRY] = leftSliceGeometry;\n        this.partialResults[constants_1.KEY_RIGHT_SLICE_PLANE] = rightPlane;\n        this.partialResults[constants_1.KEY_RIGHT_SLICE_GEOMETRY] = rightSliceGeometry;\n        this.partialResults[constants_1.KEY_PLANE_INTERSECTION_POINTS] = planeIntersectionPoints;\n        this.partialResults[constants_1.KEY_SPLIT_TRIANGULATION_GEOMETRIES] = triangulatedGeometries;\n    };\n    //   /**\n    //    * Make a triangulation of the given path specified by the verted indices.\n    //    *\n    //    * @param {Array<number>} connectedPath - An array of vertex indices.\n    //    * @return {ThreeGeometryHellfix.Gmetry} trianglesMesh\n    //    */\n    //   var makePlaneTriangulation = function (generator, sliceGeometry, connectedPath, options) {\n    //     // Convert the connected paths indices to [x, y, x, y, x, y, ...] coordinates (requied by earcut)\n    //     var currentPathXYData = connectedPath.reduce(function (earcutInput, vertIndex) {\n    //       var vert = sliceGeometry.vertices[vertIndex];\n    //       earcutInput.push(vert.x, vert.y);\n    //       return earcutInput;\n    //     }, []);\n    //     // Array<number> : triplets of vertex indices in the plain XY array\n    //     var triangles = earcut(currentPathXYData);\n    //     // Convert triangle indices back to a geometry\n    //     var trianglesGeometry = new Gmetry();\n    //     // We will merge the geometries in the end which will create clones of the vertices.\n    //     // No need to clone here.\n    //     // trianglesGeometry.vertices = leftSliceGeometry.vertices;\n    //     trianglesGeometry.vertices = connectedPath.map(function (geometryVertexIndex) {\n    //       return sliceGeometry.vertices[geometryVertexIndex];\n    //     });\n    //     // Array<{x,y}> is compatible with Array<{x,y,z}> here :)\n    //     var flatSideBounds = Bounds.computeFromVertices(trianglesGeometry.vertices);\n    //     for (var t = 0; t < triangles.length; t += 3) {\n    //       var a = triangles[t];\n    //       var b = triangles[t + 1];\n    //       var c = triangles[t + 2];\n    //       trianglesGeometry.faces.push(new THREE.Face3(a, b, c));\n    //       // Add UVs\n    //       UVHelpers.makeFlatTriangleUVs(trianglesGeometry, flatSideBounds, a, b, c);\n    //     }\n    //     trianglesGeometry.uvsNeedUpdate = true;\n    //     trianglesGeometry.buffersNeedUpdate = true;\n    //     trianglesGeometry.computeVertexNormals();\n    //     var trianglesMesh = new THREE.Mesh(\n    //       trianglesGeometry,\n    //       new THREE.MeshBasicMaterial({\n    //         color: 0x0048ff,\n    //         transparent: true,\n    //         opacity: 0.55,\n    //         side: THREE.DoubleSide\n    //       })\n    //     );\n    //     trianglesMesh.position.y = -100;\n    //     // trianglesMesh.position.z += 1.0; // Avoid Moir with plane mesh?\n    //     trianglesMesh.userData[\"isExportable\"] = false;\n    //     generator.partialResults[KEY_PLANE_INTERSECTION_TRIANGULATION] = trianglesGeometry;\n    //     if (options.showSplitShapeTriangulation) {\n    //       generator.addMesh(trianglesMesh);\n    //     }\n    //     return trianglesGeometry;\n    //   };\n    /**\n     * Add a mesh to the underlying scene.\n     *\n     * The function will make some modifications to the rotation of the meshes.\n     * @param {THREE.Mesh} mesh\n     */\n    DildoGeneration.prototype.addMesh = function (mesh) {\n        mesh.rotation.x = Math.PI;\n        this.scene.add(mesh);\n        this.geometries.push(mesh);\n    };\n    DildoGeneration.prototype.removeCachedGeometries = function () {\n        for (var i = 0; i < this.geometries.length; i++) {\n            var old = this.geometries[i];\n            // Remove old object.\n            //  A better way would be to update the lathe in-place. Possible?\n            this.scene.remove(old);\n            //   if (typeof old.dispose == \"function\") old.dispose();\n            //   if (typeof old.material != \"undefined\" && typeof old.material.dispose == \"function\") old.material.dispose();\n            if (old instanceof THREE.Mesh) {\n                old.geometry.dispose();\n                old.material.dispose();\n            }\n        }\n        this.geometries = [];\n    };\n    DildoGeneration.prototype.clearResults = function () {\n        this.splitResults[constants_1.KEY_SLICED_MESH_RIGHT] = null;\n        this.splitResults[constants_1.KEY_SLICED_MESH_LEFT] = null;\n        this.partialResults[constants_1.KEY_LEFT_SLICE_PLANE] = null;\n        this.partialResults[constants_1.KEY_LEFT_SLICE_GEOMETRY] = null;\n        this.partialResults[constants_1.KEY_RIGHT_SLICE_PLANE] = null;\n        this.partialResults[constants_1.KEY_RIGHT_SLICE_GEOMETRY] = null;\n        this.partialResults[constants_1.KEY_PLANE_INTERSECTION_POINTS] = null;\n        this.partialResults[constants_1.KEY_SPLIT_TRIANGULATION_GEOMETRIES] = null;\n    };\n    /**\n     * Generate an STL string from the (exportable) meshes that are currently stored inside this generator.\n     *\n     * @param {function(string)} options.onComplete\n     **/\n    DildoGeneration.prototype.generateSTL = function (options, exporter) {\n        // const exporter: STLExporter = new STLExporter();\n        var stlBuffer = [];\n        // TODO: merge all exportable geometries together and export as one.\n        for (var i in this.geometries) {\n            if (this.geometries[i].userData[\"isExportable\"] === true) {\n                var stlData = exporter.parse(this.geometries[i]);\n                stlBuffer.push(stlData);\n            }\n        }\n        if (typeof options.onComplete === \"function\") {\n            options.onComplete(stlBuffer.join(\"\\n\\n\"));\n        }\n        else {\n            console.warn(\"STL data was generated but no 'onComplete' callback was defined.\");\n        }\n    };\n    return DildoGeneration;\n}()); // END class\nexports.DildoGeneration = DildoGeneration;\n//# sourceMappingURL=DildoGeneration.js.map","\"use strict\";\n/**\n * @require THREE.Geometry\n *\n * @author   Ikaros Kappler\n * @date     2020-07-08\n * @modified 2021-06-11 Fixing top and bottom points; preparing slicing of mesh.\n * @modified 2021-08-29 Ported to Typescript from vanilla JS.\n * @modified 2022-02-22 Replaced THREE.Geometry by ThreeGeometryHellfix.Gmetry (and Face3).\n * @version  1.0.3\n **/\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        if (typeof b !== \"function\" && b !== null)\n            throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.DildoGeometry = void 0;\n// TODOs\n// + Add cut-plane faces when hollow\n// + Move vertex-creating helper functions out of the class\n// + Move face-creating helper functions out of the class\n// + Move UV-creating helper functions out of the class\n// + port to typescript\nvar plotboilerplate_1 = require(\"plotboilerplate\");\nvar THREE = require(\"three\");\nvar GeometryGenerationHelpers_1 = require(\"./GeometryGenerationHelpers\");\nvar earcut_typescript_1 = require(\"earcut-typescript\"); // TODO: fix earcut types\nvar UVHelpers_1 = require(\"./UVHelpers\");\nvar cjs_1 = require(\"three-geometry-hellfix/src/cjs\");\nvar DEG_TO_RAD = Math.PI / 180.0;\n// import { DEG_TO_RAD } from \"./constants\";\n// This is a dirty workaround to\n// avoid direct class extending of THREE.Geometry.\n// I am using `THREE.Geometry.call(this);` instead :/\n// export class DildoBaseClass {\n//   // implements IDildoGeometry {\n//   vertices: Array<THREE.Vector3>;\n//   faces: Array<Face3>;\n//   faceVertexUvs: Array<Array<[THREE.Vector2, THREE.Vector2, THREE.Vector2]>>;\n//   uvsNeedUpdate: boolean;\n//   buffersNeedUpdate: boolean;\n//   constructor() {\n//     this.vertices = [];\n//     this.faces = [];\n//     this.faceVertexUvs = [[]];\n//   }\n// }\n// export class DildoGeometry { // extends globalThis.THREE.Geometry {\n// export class DildoGeometry extends DildoBaseClass {\nvar DildoGeometry = /** @class */ (function (_super) {\n    __extends(DildoGeometry, _super);\n    /**\n     * Create a new dildo geometry from the passed options..\n     *\n     * @param {Polygon} options.baseShape - The base shape to use (this is usually some regular polygon).\n     * @param {BezierPath} options.outline - The lathe outline to use.\n     * @param {number} options.bendAngle - A bend angle (in degrees!). Will only be applied if isBending=true.\n     * @param {number} options.outlineSegmentCount (>= 2).\n     * @param {boolean} options.isBending - Switch bending on/off no matter what the bend angle says.\n     * @param {boolean} options.makeHollow - Make a hollow mold.\n     **/\n    function DildoGeometry(options) {\n        var _this = _super.call(this) || this;\n        // TODO: verify\n        // THREE.Geometry.call(this);\n        cjs_1.Gmetry.call(_this);\n        _this.vertexMatrix = []; // Array<Array<number>>\n        _this.topIndex = -1;\n        _this.bottomIndex = -1;\n        _this.spineVertices = []; // Array<THREE.Vector>\n        _this.outerPerpLines = []; // Array<Three.Line3>\n        _this.innerPerpLines = []; // Array<Three.Line3>\n        _this.flatSidePolygon = null; // Polygon (2d)\n        _this.leftFlatIndices = []; // Array<number>\n        _this.rightFlatIndices = []; // Array<number>\n        _this.leftFlatTriangleIndices = []; // Array[[number,number,number]]\n        _this.rightFlatTriangleIndices = []; // Array[[number,number,number]]\n        _this.flatSideBounds = null; // Bounds\n        // The four corner vertices from the hollow shell plus the bottom vertex indices left and right\n        _this.hollowBottomEdgeVertIndices = []; // [number,number,number,number, number, number]\n        _this.hollowBottomTriagles = []; // Array<[number,number,number]>\n        _this.dildoNormals = [];\n        _this._buildVertices(options);\n        _this._buildFaces(options);\n        _this._buildUVMapping(options);\n        // Fill up missing UVs to avoid warnings\n        // This is a bit dirty, but not in call cases it is useful to create UV mappings\n        // while (this.faceVertexUvs[0].length < this.faces.length) {\n        //   this.faceVertexUvs[0].push([new THREE.Vector2(0, 0), new THREE.Vector2(1, 0), new THREE.Vector2(0.5, 1)]);\n        // }\n        if (options.useBumpmap) {\n            if (options.bumpmapTexture) {\n                _this.__applyBumpmap(options.bumpmapTexture);\n            }\n            else {\n                console.warn(\"Cannot apply bumpmap as desired, because the bumpmap texture is null or undefined.\");\n            }\n        }\n        return _this;\n    }\n    /**\n     *\n     * @param {Polygon} baseShape\n     * @param {Vertex} shapeCenter\n     * @param {Bounds} outlineBounds\n     * @param {THREE.Vertex3} outlineVert\n     * @param {number} sliceIndex\n     * @param {number} heightT A value between 0.0 and 1.0 (inclusive) to indicate the height position.\n     * @param {boolean} isBending\n     * @param {number=} bendAngle Must not be null, NaN or infinity if `isBending==true`\n     * @param {number=} arcRadius\n     * @param {boolean=} normalizePerpendiculars\n     * @param {number=} normalsLength\n     * @param {number=0} shapeTwistAngle - The angle to twist this particular shape around the y axis.\n     * @return { yMin: number, yMax : number }\n     */\n    DildoGeometry.prototype.__buildSlice = function (baseShape, outlineBounds, outlineVert, sliceIndex, heightT, isBending, bendAngle, arcRadius, shapeTwistAngle) {\n        var outlineXPct = (outlineBounds.max.x - outlineVert.x) / outlineBounds.width;\n        // TODO: are these is use?\n        var yMin, yMax;\n        for (var i = 0; i < baseShape.vertices.length; i++) {\n            var shapeVert = baseShape.vertices[i];\n            if (isBending) {\n                var vert = new THREE.Vector3(shapeVert.x * outlineXPct, 0, shapeVert.y * outlineXPct);\n                // Apply twist\n                rotateVertY(vert, shapeTwistAngle, 0, 0);\n                this._bendVertex(vert, bendAngle, arcRadius, heightT);\n                vert.y += outlineBounds.max.y;\n            }\n            else {\n                var vert = new THREE.Vector3(shapeVert.x * outlineXPct, outlineVert.y, shapeVert.y * outlineXPct);\n                // Apply twist\n                rotateVertY(vert, shapeTwistAngle, 0, 0);\n            }\n            this.vertexMatrix[sliceIndex][i] = this.vertices.length;\n            this.vertices.push(vert);\n            if (sliceIndex == 0) {\n                if (i == 0)\n                    yMin = vert.y;\n                if (i + 1 == baseShape.vertices.length)\n                    yMax = vert.y;\n            }\n        } // END for\n    };\n    /**\n     *\n     * @param {Polygon} baseShape\n     * @param {Vertex} shapeCenter\n     * @param {Bounds} outlineBounds\n     * @param {THREE.Vertex3} outlineVert\n     * @param {number} sliceIndex\n     * @param {number} heightT A value between 0.0 and 1.0 (inclusive) to indicate the height position.\n     * @param {boolean} isBending\n     * @param {number=} bendAngle Must not be null, NaN or infinity if `isBending==true`\n     * @param {number=} arcRadius\n     * @param {boolean=} normalizePerpendiculars\n     * @param {number=} normalsLength\n     * @return { yMin: number, yMax : number }\n     */\n    DildoGeometry.prototype.__buildSpine = function (shapeCenter, outlineBounds, outlineVert, heightT, isBending, bendAngle, arcRadius) {\n        var outlineXPct = (outlineBounds.max.x - outlineVert.x) / outlineBounds.width;\n        // Find shape's center point to construct a spine\n        var spineVert = shapeCenter.clone();\n        if (isBending) {\n            var vert = new THREE.Vector3(spineVert.x * outlineXPct, 0, spineVert.y * outlineXPct);\n            this._bendVertex(vert, bendAngle, arcRadius, heightT);\n            vert.y += outlineBounds.max.y;\n        }\n        else {\n            var vert = new THREE.Vector3(spineVert.x * outlineXPct, outlineVert.y, spineVert.y * outlineXPct);\n        }\n        this.spineVertices.push(vert);\n    };\n    /**\n     *\n     * @param {Polygon} baseShape\n     * @param {Bounds} outlineBounds\n     * @param {THREE.Vertex3} outlineVert\n     * @param {number} sliceIndex\n     * @param {number} heightT A value between 0.0 and 1.0 (inclusive) to indicate the height position.\n     * @param {boolean} isBending\n     * @param {number=} bendAngle Must not be null, NaN or infinity if `isBending==true`\n     * @param {number=} arcRadius\n     * @param {boolean=} normalizePerpendiculars\n     * @param {number=} normalsLength\n     * @return { yMin: number, yMax : number }\n     */\n    DildoGeometry.prototype.__buildPerps = function (baseShape, outlineBounds, outlineVert, // THREE.Vector3?\n    perpendicularVert, heightT, isBending, bendAngle, arcRadius, normalizePerpendiculars, normalsLength) {\n        var outlineXPct = (outlineBounds.max.x - outlineVert.x) / outlineBounds.width;\n        var halfIndices = [0, Math.floor(baseShape.vertices.length / 2)];\n        for (var j = 0; j < halfIndices.length; j++) {\n            var i = halfIndices[j];\n            var shapeVert = baseShape.vertices[i];\n            if (isBending) {\n                var vert = new THREE.Vector3(shapeVert.x * outlineXPct, 0, shapeVert.y * outlineXPct);\n                this._bendVertex(vert, bendAngle, arcRadius, heightT);\n                vert.y += outlineBounds.max.y;\n            }\n            else {\n                var vert = new THREE.Vector3(shapeVert.x * outlineXPct, outlineVert.y, shapeVert.y * outlineXPct);\n            }\n            var perpDifference = new THREE.Vector3(outlineVert.x - perpendicularVert.x, outlineVert.y - perpendicularVert.y, 0);\n            // TODO: check (this is in both cases the same)\n            if (i == 0)\n                var endVert = new THREE.Vector3(vert.x - perpendicularVert.x, vert.y + perpendicularVert.y, 0);\n            else\n                var endVert = new THREE.Vector3(vert.x + perpendicularVert.x, vert.y + perpendicularVert.y, 0);\n            rotateVert(endVert, bendAngle * heightT, vert.x, vert.y);\n            var outerPerpVert = vert.clone();\n            outerPerpVert.x += perpDifference.x;\n            outerPerpVert.y += perpDifference.y;\n            outerPerpVert.z += perpDifference.z;\n            if (normalizePerpendiculars) {\n                GeometryGenerationHelpers_1.GeometryGenerationHelpers.normalizeVectorXY(vert, endVert, normalsLength);\n            }\n            if (i == 0) {\n                this.outerPerpLines.push(new THREE.Line3(vert, endVert));\n            }\n            else {\n                this.innerPerpLines.push(new THREE.Line3(vert, endVert));\n            }\n        } // END for\n    };\n    //   /**\n    //    *\n    //    * @param {Polygon} baseShape\n    //    * @param {Bounds} outlineBounds\n    //    * @param {THREE.Vertex3} outlineVert\n    //    * @param {number} sliceIndex\n    //    * @param {number} heightT A value between 0.0 and 1.0 (inclusive) to indicate the height position.\n    //    * @param {boolean} isBending\n    //    * @param {number=} bendAngle Must not be null, NaN or infinity if `isBending==true`\n    //    * @param {number=} arcRadius\n    //    * @param {boolean=} normalizePerpendiculars\n    //    * @param {number=} normalsLength\n    //    * @return { yMin: number, yMax : number }\n    //    */\n    //   __buildNormals(\n    //     outlineSegmentIndex: number,\n    //     baseShape: Polygon,\n    //     outlineBounds: Bounds,\n    //     outlineVert: Vertex, // THREE.Vector3?\n    //     perpendicularVert: Vertex,\n    //     heightT: number,\n    //     isBending: boolean,\n    //     bendAngle: number,\n    //     arcRadius: number,\n    //     normalizePerpendiculars: boolean,\n    //     normalsLength: number\n    //   ) {\n    //     // var outlineXPct = (outlineBounds.max.x - outlineVert.x) / outlineBounds.width;\n    //     // var halfIndices = [0, Math.floor(baseShape.vertices.length / 2)];\n    //     // for (var j = 0; j < halfIndices.length; j++) {\n    //     //   var i = halfIndices[j];\n    //     //   var shapeVert = baseShape.vertices[i];\n    //     //   if (isBending) {\n    //     //     var vert = new THREE.Vector3(shapeVert.x * outlineXPct, 0, shapeVert.y * outlineXPct);\n    //     //     this._bendVertex(vert, bendAngle, arcRadius, heightT);\n    //     //     vert.y += outlineBounds.max.y;\n    //     //   } else {\n    //     //     var vert = new THREE.Vector3(shapeVert.x * outlineXPct, outlineVert.y, shapeVert.y * outlineXPct);\n    //     //   }\n    //     //   var perpDifference = new THREE.Vector3(outlineVert.x - perpendicularVert.x, outlineVert.y - perpendicularVert.y, 0);\n    //     //   if (i == 0) var endVert = new THREE.Vector3(vert.x - perpendicularVert.x, vert.y + perpendicularVert.y, 0);\n    //     //   else var endVert = new THREE.Vector3(vert.x + perpendicularVert.x, vert.y + perpendicularVert.y, 0);\n    //     //   rotateVert(endVert, bendAngle * heightT, vert.x, vert.y);\n    //     //   var outerPerpVert = vert.clone();\n    //     //   outerPerpVert.x += perpDifference.x;\n    //     //   outerPerpVert.y += perpDifference.y;\n    //     //   outerPerpVert.z += perpDifference.z;\n    //     //   if (normalizePerpendiculars) {\n    //     //     normalizeVectorXY(vert, endVert, normalsLength);\n    //     //   }\n    //     //   if (i == 0) {\n    //     //     this.outerPerpLines.push(new THREE.Line3(vert, endVert));\n    //     //   } else {\n    //     //     this.innerPerpLines.push(new THREE.Line3(vert, endVert));\n    //     //   }\n    //     // } // END for\n    //     var outlineXPct = (outlineBounds.max.x - outlineVert.x) / outlineBounds.width;\n    //     var halfIndices = [0, Math.floor(baseShape.vertices.length / 2)];\n    //     // Just append? Should be growing from 0 to n-1\n    //     this.dildoNormals[outlineSegmentIndex] = [];\n    //     // for (var j = 0; j < halfIndices.length; j++) {\n    //     console.log(\"baseShape.vertices.length\", baseShape.vertices.length);\n    //     for (var i = 0; i < baseShape.vertices.length; i++) {\n    //       //   var i = halfIndices[j];\n    //       var shapeVert = baseShape.vertices[i];\n    //       var perpDifference = new THREE.Vector3(outlineVert.x - perpendicularVert.x, outlineVert.y - perpendicularVert.y, 0);\n    //       normalizeVectorXY(outlineVert, perpDifference, normalsLength);\n    //       rotateVertY(perpDifference, bendAngle * heightT, vert.x, vert.y);\n    //       if (i == 0) {\n    //         console.log(\"perpDifference\", perpDifference);\n    //       }\n    //       if (isBending) {\n    //         var vert = new THREE.Vector3(shapeVert.x * outlineXPct, 0, shapeVert.y * outlineXPct);\n    //         // vert.add(new THREE.Vector3(perpDifference.x, 0, perpDifference.y));\n    //         // vert.sub(perpDifference);\n    //         this._bendVertex(vert, bendAngle, arcRadius, heightT);\n    //         vert.y += outlineBounds.max.y;\n    //       } else {\n    //         var vert = new THREE.Vector3(shapeVert.x * outlineXPct, outlineVert.y, shapeVert.y * outlineXPct);\n    //         // vert.add(new THREE.Vector3(perpDifference.x, perpDifference.y, 0));\n    //         // vert.sub(perpDifference);\n    //       }\n    //       //   var perpDifference = new THREE.Vector3(outlineVert.x - perpendicularVert.x, outlineVert.y - perpendicularVert.y, 0);\n    //       // TODO: check (this is in both cases the same)\n    //       //   if (i == 0) var endVert = new THREE.Vector3(vert.x - perpendicularVert.x, vert.y + perpendicularVert.y, vert.z);\n    //       //   //0);\n    //       //   else var endVert = new THREE.Vector3(vert.x + perpendicularVert.x, vert.y + perpendicularVert.y, vert.z); // 0);\n    //       // var endVert = new THREE.Vector3(vert.x + perpendicularVert.x, vert.y + perpendicularVert.y, vert.z);\n    //       //   rotateVert(endVert, bendAngle * heightT, vert.x, vert.y);\n    //       var outerPerpVert = vert.clone();\n    //       outerPerpVert.x += perpDifference.x;\n    //       outerPerpVert.y += perpDifference.y;\n    //       outerPerpVert.z += perpDifference.z;\n    //       // TODO: re-check\n    //       if (true || normalizePerpendiculars) {\n    //         // normalizeVectorXY(vert, endVert, normalsLength);\n    //         // normalizeVectorXYZ(vert, endVert, normalsLength);\n    //       }\n    //       // Add to cut lines?\n    //       //   if (i == 0) {\n    //       //     this.outerPerpLines.push(new THREE.Line3(vert, endVert));\n    //       //   } else if (i == halfIndices[1]) {\n    //       //     this.innerPerpLines.push(new THREE.Line3(vert, endVert));\n    //       //   }\n    //       // Add to regular normals\n    //       this.dildoNormals[outlineSegmentIndex].push(vert);\n    //       if (i == 0) {\n    //         // console.log(\"endVert\", outerPerpVert);\n    //       }\n    //     } // END for\n    //   }\n    /**\n     * Pre: perpLines are already built.\n     *\n     * Note: the last indices in the array will show to the point equivalent to the bottom point.\n     *\n     * @param {*} options\n     */\n    DildoGeometry.prototype.__makeFlatSideVertices = function (shapeRadius) {\n        // We are using the earcut algorithm later\n        //  + create an outline of the perpendicular end points\n        //  + shift the outline to the left bound of the mesh\n        //  + [LATER] run earcut\n        //  + [LATER] add all triangle faces\n        //  + [LATER] create a copy of the vertices and the triangulation the the right side\n        // Step 1: serialize the 2d vertex data along the perpendicular path\n        // var polygon = new Polygon(this.getPerpendicularPathVertices(true), false);\n        this.flatSidePolygon = new plotboilerplate_1.Polygon(this.getPerpendicularPathVertices(true), false);\n        this.flatSideBounds = this.flatSidePolygon.getBounds();\n        // Step 2: Add the 3d vertices to this geometry (and store positions in left-/rightFlatIndices array)\n        for (var i = 0; i < this.flatSidePolygon.vertices.length; i++) {\n            var nextIndex = this.vertices.length;\n            this.leftFlatIndices.push(nextIndex);\n            this.vertices.push(new THREE.Vector3(this.flatSidePolygon.vertices[i].x, this.flatSidePolygon.vertices[i].y, shapeRadius));\n            if (i === 0 || i + 1 === this.flatSidePolygon.vertices.length || i + 2 === this.flatSidePolygon.vertices.length) {\n                // Keep track of the four corner points (two left, two right)\n                this.hollowBottomEdgeVertIndices.push(nextIndex);\n            }\n        }\n        for (var i = 0; i < this.flatSidePolygon.vertices.length; i++) {\n            var nextIndex = this.vertices.length;\n            this.rightFlatIndices.push(nextIndex);\n            this.vertices.push(new THREE.Vector3(this.flatSidePolygon.vertices[i].x, this.flatSidePolygon.vertices[i].y, -shapeRadius));\n            if (i === 0 || i + 1 === this.flatSidePolygon.vertices.length || i + 2 === this.flatSidePolygon.vertices.length) {\n                // Keep track of the four corner points (two left, two right)\n                this.hollowBottomEdgeVertIndices.push(nextIndex);\n            }\n        }\n    };\n    /**\n     * Pre: perpLines are already built.\n     *\n     * Note: the last indices in the array will show to the point equivalent to the bottom point.\n     *\n     * @param {*}\n     */\n    DildoGeometry.prototype.__makeFlatSideFaces = function () {\n        // We are using the earcut algorithm here\n        //  + [DONE before] create an outline of the perpendicular end points\n        //  + [DONE before] shift the outline to the left bound of the mesh\n        //  + run earcut\n        //  + add all triangle faces\n        //  + create a copy of the vertices and the triangulation the the right side\n        var _self = this;\n        // Array<THREE.Vector3>  (compatible with XYCoords :)\n        var polygonVertices = this.leftFlatIndices.map(function (flatSideIndex) {\n            return _self.vertices[flatSideIndex];\n        });\n        var polygonData = GeometryGenerationHelpers_1.GeometryGenerationHelpers.flattenVert2dArray(polygonVertices);\n        // Step 3: run Earcut\n        var triangleIndices = (0, earcut_typescript_1.earcut)(polygonData);\n        // Step 4: process the earcut result;\n        //         add the retrieved triangles as geometry faces.\n        for (var i = 0; i + 2 < triangleIndices.length; i += 3) {\n            var a = triangleIndices[i];\n            var b = triangleIndices[i + 1];\n            var c = triangleIndices[i + 2];\n            GeometryGenerationHelpers_1.GeometryGenerationHelpers.makeFace3(this, this.leftFlatIndices[a], this.leftFlatIndices[b], this.leftFlatIndices[c]);\n            this.leftFlatTriangleIndices.push([this.leftFlatIndices[a], this.leftFlatIndices[b], this.leftFlatIndices[c]]);\n        }\n        for (var i = 0; i + 2 < triangleIndices.length; i += 3) {\n            var a = triangleIndices[i];\n            var b = triangleIndices[i + 1];\n            var c = triangleIndices[i + 2];\n            GeometryGenerationHelpers_1.GeometryGenerationHelpers.makeFace3(this, this.rightFlatIndices[a], this.rightFlatIndices[c], this.rightFlatIndices[b]);\n            this.rightFlatTriangleIndices.push([this.rightFlatIndices[a], this.rightFlatIndices[b], this.rightFlatIndices[c]]);\n        }\n    };\n    DildoGeometry.prototype.getPerpendicularPathVertices = function (includeBottomVert, getInner) {\n        // Array<XYCoords>\n        var polygonVertices = [];\n        for (var i = 0; i < this.innerPerpLines.length; i++) {\n            polygonVertices.push(getInner ? this.innerPerpLines[i].start : this.innerPerpLines[i].end);\n        }\n        // Reverse the outer path segment (both begin at bottom and meet at the top)\n        for (var i = this.outerPerpLines.length - 1; i >= 0; i--) {\n            polygonVertices.push(getInner ? this.outerPerpLines[i].start : this.outerPerpLines[i].end);\n        }\n        // Also add base point at last index\n        if (includeBottomVert) {\n            polygonVertices.push(this.vertices[this.bottomIndex]);\n        }\n        return polygonVertices;\n    };\n    DildoGeometry.prototype.getPerpendicularHullLines = function () {\n        // Array<XYCoords>\n        var perpLines = [];\n        for (var i = 0; i < this.innerPerpLines.length; i++) {\n            perpLines.push(this.innerPerpLines[i]);\n        }\n        // Reverse the outer path segment (both begin at bottom and meet at the top)\n        for (var i = this.outerPerpLines.length - 1; i >= 0; i--) {\n            perpLines.push(this.outerPerpLines[i]);\n        }\n        return perpLines;\n    };\n    /**\n     * Construct the top vertex that's used to closed the cylinder geometry at the top.\n     *\n     * @param {plotboilerplate.Bounds} outlineBounds\n     * @param {boolean} isBending\n     * @param {number|NaN|undefined} bendAngle\n     * @param {number|undefined} arcRadius\n     * @returns THREE.Vector\n     */\n    DildoGeometry.prototype._getTopVertex = function (outlineBounds, isBending, bendAngle, arcRadius) {\n        if (isBending) {\n            var topPoint = new THREE.Vector3(0, 0, 0);\n            this._bendVertex(topPoint, bendAngle, arcRadius, 1.0);\n            topPoint.y += outlineBounds.max.y;\n            return topPoint;\n        }\n        else {\n            return new THREE.Vector3(0, outlineBounds.min.y, 0);\n        }\n    };\n    /**\n     * Construct the bottom vertex that's used to closed the cylinder geometry at the bottom.\n     *\n     * @param {plotboilerplate.Bounds} outlineBounds\n     * @param {boolean} isBending\n     * @returns THREE.Vector\n     */\n    DildoGeometry.prototype._getBottomVertex = function (outlineBounds) {\n        var bottomPoint = new THREE.Vector3(0, outlineBounds.max.y, 0);\n        // if (isBending) {\n        // No need to bend the bottom point (no effect)\n        // this._bendVertex(bottomPoint, bendAngle, arcRadius, 0.0);\n        // }\n        return bottomPoint;\n    };\n    /**\n     * A helper function to 'bend' a vertex position around the desired bend axis (angle + radius).\n     * @private\n     * @param {} vert\n     * @param {*} bendAngle\n     * @param {*} arcRadius\n     * @param {*} heightT\n     */\n    DildoGeometry.prototype._bendVertex = function (vert, bendAngle, arcRadius, heightT) {\n        var axis = new THREE.Vector3(0, 0, 1);\n        var angle = bendAngle * heightT;\n        // Move slice point along radius, rotate, then move back\n        // (equivalent to rotation around arc center)\n        vert.x -= arcRadius;\n        vert.applyAxisAngle(axis, angle);\n        vert.x += arcRadius;\n    };\n    /**\n     * Rotate a 3d vector around the z axis (back-front-axis).\n     *\n     * @param {THREE.Vector3} vert\n     * @param {THREE.Vector3} angle\n     * @param {number} xCenter\n     * @param {number} yCenter\n     * @returns\n     */\n    //   // TODO: move to helpers\n    //   var rotateVert = function (vert, angle, xCenter, yCenter) {\n    //     var axis = new THREE.Vector3(0, 0, 1);\n    //     vert.x -= xCenter;\n    //     vert.y -= yCenter;\n    //     vert.applyAxisAngle(axis, angle);\n    //     vert.x += xCenter;\n    //     vert.y += yCenter;\n    //     return vert;\n    //   };\n    //   /**\n    //    * Rotate a 3d vector around the y axis (up-down-axis).\n    //    *\n    //    * @param {THREE.Vector3} vert\n    //    * @param {THREE.Vector3} angle\n    //    * @param {number} xCenter\n    //    * @param {number} zCenter\n    //    * @returns\n    //    */\n    //   // TODO: move to helpers\n    //   var rotateVertY = function (vert, angle, xCenter, zCenter) {\n    //     var axis = new THREE.Vector3(0, 1, 0);\n    //     vert.x -= xCenter;\n    //     vert.z -= zCenter;\n    //     vert.applyAxisAngle(axis, angle);\n    //     vert.x += xCenter;\n    //     vert.z += zCenter;\n    //     return vert;\n    //   };\n    //   /**\n    //    * Normalize a 2D vector to a given length.\n    //    *\n    //    * @param {XYCoords} base - The start point.\n    //    * @param {XYCoords} extend - The end point.\n    //    * @param {number} normalLength - The desired length\n    //    */\n    //   var normalizeVectorXY = function (base, extend, normalLength) {\n    //     var diff = { x: extend.x - base.x, y: extend.y - base.y }; // XYCoords\n    //     var length = Math.sqrt(diff.x * diff.x + diff.y * diff.y);\n    //     var ratio = normalLength / length;\n    //     extend.x = base.x + diff.x * ratio;\n    //     extend.y = base.y + diff.y * ratio;\n    //   };\n    // computeVertexNormals() {\n    //   for( var f = 0; f < this.faces.length; f++ ) {\n    //       var face = this.faces[f];\n    //   }\n    // }\n    // TODO\n    DildoGeometry.prototype.applyBumpMap = function (bumpMapTexture) {\n        // Build normals\n        for (var i = 0; i < this.vertexMatrix.length; i++) {\n            for (var j = 0; j < this.vertexMatrix[i].length; j++) {\n                var vertIndex = this.vertexMatrix[i][j];\n                var vertex = this.vertices[vertIndex];\n            }\n        }\n    };\n    /**\n     * Build up the faces for this geometry.\n     * @param {*} options\n     */\n    // DildoGeometry.prototype._buildFaces = function (options) {\n    DildoGeometry.prototype._buildFaces = function (options) {\n        var baseShape = options.baseShape;\n        var outlineSegmentCount = options.outlineSegmentCount;\n        var closeTop = Boolean(options.closeTop);\n        var closeBottom = Boolean(options.closeBottom);\n        var makeHollow = Boolean(options.makeHollow);\n        var baseShapeSegmentCount = baseShape.vertices.length;\n        this.faceVertexUvs[0] = [];\n        for (var s = 0; s < outlineSegmentCount; s++) {\n            for (var i = 0; i < baseShapeSegmentCount; i++) {\n                if (s > 0) {\n                    if (i > 0) {\n                        this.addFace4ByIndices(s, i - 1, s - 1, i, makeHollow);\n                        if (i + 1 == baseShape.vertices.length) {\n                            // Close the gap on the shape\n                            this.addFace4ByIndices(s, i, s - 1, 0, makeHollow);\n                        }\n                    }\n                }\n            } // END for\n        } // END for\n        if (makeHollow) {\n            this.__makeFlatSideFaces();\n            this.__makeBackFrontFaces();\n        }\n        if (closeBottom) {\n            if (makeHollow)\n                this._buildHollowBottomFaces();\n            else\n                this._buildEndFaces(this.bottomIndex, 0, baseShapeSegmentCount, false);\n        }\n        if (closeTop) {\n            this._buildEndFaces(this.topIndex, this.vertexMatrix.length - 1, baseShapeSegmentCount, makeHollow);\n        }\n    };\n    DildoGeometry.prototype._buildHollowBottomFaces = function () {\n        var _self = this;\n        var edgeVertices = this.hollowBottomEdgeVertIndices.map(function (edgeVertIndex) {\n            return _self.vertices[edgeVertIndex];\n        });\n        var findClosestEdgeIndex = function (vert) {\n            // THREE.Vector\n            var index = 0;\n            var distance = Number.MAX_VALUE;\n            var tmpDist;\n            for (var i = 0; i < edgeVertices.length; i++) {\n                var tmpIndex = _self.hollowBottomEdgeVertIndices[i];\n                if ((tmpDist = edgeVertices[i].distanceTo(vert)) < distance) {\n                    index = tmpIndex;\n                    distance = tmpDist;\n                }\n            }\n            return index;\n        };\n        // 'Last index' starts at last point at all : )\n        var n = this.vertexMatrix[0].length;\n        var lastIndex = findClosestEdgeIndex(this.vertices[n - 1]);\n        var triangleIndices; // = []; // [number,number,number]\n        // Use first slice (at bottom position)\n        for (var i = 0; i < n; i++) {\n            var curIndex = findClosestEdgeIndex(this.vertices[this.vertexMatrix[0][i]]);\n            // Close gap to last (different shell index)\n            triangleIndices = [lastIndex, this.vertexMatrix[0][i == 0 ? n - 1 : i - 1], this.vertexMatrix[0][i]];\n            this.faces.push(new cjs_1.Face3(triangleIndices[0], triangleIndices[1], triangleIndices[2])); // Same?\n            this.hollowBottomTriagles.push(triangleIndices);\n            if (lastIndex !== curIndex) {\n                // Add normal triangle to same shell index\n                triangleIndices = [curIndex, lastIndex, this.vertexMatrix[0][i]];\n                this.faces.push(new cjs_1.Face3(triangleIndices[0], triangleIndices[1], triangleIndices[2]));\n                this.hollowBottomTriagles.push(triangleIndices);\n            }\n            lastIndex = curIndex;\n        }\n    };\n    /**\n     * Build the face and the top or bottom end of the geometry. Imagine the dildo geometry\n     * as a closed cylinder: this function created the top or the bottom 'circle'.\n     *\n     * @param {number} endVertexIndex - This should be `this.topIndex` or `this.bottomIndex`.\n     * @param {number} shapeIndex - This should be `0` (top) or `outlineSegmentCount-1` (bottom).\n     * @param {number} baseShapeSegmentCount - The number of shape segments.\n     * @param {boolean=false} inverseFaceDirection - If true then the face will have left winding order (instead of right which is the default).\n     */\n    DildoGeometry.prototype._buildEndFaces = function (endVertexIndex, shapeIndex, baseShapeSegmentCount, inverseFaceDirection) {\n        // Close at top.\n        for (var i = 1; i < baseShapeSegmentCount; i++) {\n            GeometryGenerationHelpers_1.GeometryGenerationHelpers.makeFace3(this, this.vertexMatrix[shapeIndex][i - 1], endVertexIndex, this.vertexMatrix[shapeIndex][i], inverseFaceDirection);\n            if (i + 1 == baseShapeSegmentCount) {\n                GeometryGenerationHelpers_1.GeometryGenerationHelpers.makeFace3(this, this.vertexMatrix[shapeIndex][i], endVertexIndex, this.vertexMatrix[shapeIndex][0], inverseFaceDirection);\n            }\n        }\n    };\n    /**\n     * Pre: flatSides are made\n     *\n     * @param {*} options\n     */\n    DildoGeometry.prototype.__makeBackFrontFaces = function () {\n        // Connect left and right side (important: ignore bottom vertex at last index)\n        for (var i = 1; i + 1 < this.flatSidePolygon.vertices.length; i++) {\n            GeometryGenerationHelpers_1.GeometryGenerationHelpers.makeFace4(this, this.leftFlatIndices[i], this.leftFlatIndices[i - 1], this.rightFlatIndices[i], this.rightFlatIndices[i - 1]);\n        }\n    };\n    /**\n     * Build the texture UV mapping for all faces.\n     *\n     * @param {Polygon} options.baseShape\n     * @param {number} options.outlineSegmentCount\n     * @param {number} options.vertices.length\n     */\n    // DildoGeometry.prototype._buildUVMapping = function (options) {\n    DildoGeometry.prototype._buildUVMapping = function (options) {\n        var baseShape = options.baseShape;\n        var outlineSegmentCount = options.outlineSegmentCount;\n        var baseShapeSegmentCount = baseShape.vertices.length;\n        var closeTop = Boolean(options.closeTop);\n        var closeBottom = Boolean(options.closeBottom);\n        var makeHollow = Boolean(options.makeHollow);\n        // https://stackoverflow.com/questions/20774648/three-js-generate-uv-coordinate\n        for (var s = 1; s < outlineSegmentCount; s++) {\n            for (var i = 1; i < baseShape.vertices.length; i++) {\n                GeometryGenerationHelpers_1.GeometryGenerationHelpers.addCylindricUV4(this, s, i - 1, s - 1, i, outlineSegmentCount, baseShapeSegmentCount, makeHollow);\n                if (i + 1 == baseShape.vertices.length) {\n                    // Close the gap on the shape\n                    GeometryGenerationHelpers_1.GeometryGenerationHelpers.addCylindricUV4(this, s, i - 1, s - 1, i, outlineSegmentCount, baseShapeSegmentCount, makeHollow);\n                }\n            }\n        }\n        if (makeHollow) {\n            // Make flat side UVS (left)\n            // Note: left flat side and right flat side have the same number of polygon vertices\n            for (var i = 0; i < this.leftFlatTriangleIndices.length; i++) {\n                var leftA = this.leftFlatTriangleIndices[i][0];\n                var leftB = this.leftFlatTriangleIndices[i][1];\n                var leftC = this.leftFlatTriangleIndices[i][2];\n                UVHelpers_1.UVHelpers.makeFlatTriangleUVs(this, this.flatSideBounds, leftA, leftB, leftC);\n            }\n            // Make flat side UVS (right)\n            for (var i = 0; i < this.rightFlatTriangleIndices.length; i++) {\n                // NOTE: as the triangles are computed on the left flat side -> for the right side\n                //          change the winding order!!!\n                var rightA = this.rightFlatTriangleIndices[i][0];\n                var rightB = this.rightFlatTriangleIndices[i][2];\n                var rightC = this.rightFlatTriangleIndices[i][1];\n                UVHelpers_1.UVHelpers.makeFlatTriangleUVs(this, this.flatSideBounds, rightA, rightB, rightC);\n            }\n            // TODO: add these as function\n            for (var i = 1; i + 1 < this.flatSidePolygon.vertices.length; i++) {\n                var ratioI = (i - 1) / (this.flatSidePolygon.vertices.length - 1);\n                var ratioJ = i / (this.flatSidePolygon.vertices.length - 1);\n                this.faceVertexUvs[0].push([\n                    new THREE.Vector2(0.0, ratioJ),\n                    new THREE.Vector2(0.0, ratioI),\n                    new THREE.Vector2(1.0, ratioJ)\n                ]);\n                this.faceVertexUvs[0].push([\n                    new THREE.Vector2(0.0, ratioI),\n                    new THREE.Vector2(1.0, ratioI),\n                    new THREE.Vector2(1.0, ratioJ)\n                ]);\n            }\n        } // END if[makeHollow]\n        // Build UV mapping for the bottom (base)\n        if (closeBottom) {\n            if (makeHollow) {\n                makeHollowBottomUVs(this, this.hollowBottomEdgeVertIndices, this.hollowBottomTriagles);\n            }\n            else {\n                for (var i = 1; i < baseShapeSegmentCount; i++) {\n                    GeometryGenerationHelpers_1.GeometryGenerationHelpers.addPyramidalBaseUV3(this, i - 1, baseShapeSegmentCount);\n                    if (i + 1 == baseShapeSegmentCount) {\n                        // Close the gap on the shape\n                        GeometryGenerationHelpers_1.GeometryGenerationHelpers.addPyramidalBaseUV3(this, i - 1, baseShapeSegmentCount);\n                    }\n                }\n            }\n        }\n        // Build UV mapping for the top (closing element)\n        if (closeTop) {\n            var lastIndex = outlineSegmentCount - 1;\n            for (var i = 1; i < baseShapeSegmentCount; i++) {\n                GeometryGenerationHelpers_1.GeometryGenerationHelpers.addPyramidalBaseUV3(this, i - 1, baseShapeSegmentCount);\n                if (i + 1 == baseShapeSegmentCount) {\n                    // Close the gap on the shape\n                    GeometryGenerationHelpers_1.GeometryGenerationHelpers.addPyramidalBaseUV3(this, lastIndex, baseShapeSegmentCount);\n                }\n            }\n        }\n        this.uvsNeedUpdate = true;\n    };\n    /**\n     * Build a triangulated face4 (two face3) for the given matrix index pairs. The method will create\n     * two right-turning triangles.\n     *\n     * <pre>\n     *       (a,b)---(c,b)\n     *         |    /  |\n     *         |   /   |\n     *         |  /    |\n     *       (a,d)---(c,d)\n     * </pre>\n     *\n     * @param {number} a - The first primary index in the `vertexMatrix` array.\n     * @param {number} b - The first seconday index in the `vertexMatrix[a]` array.\n     * @param {number} c - The second primary index in the `vertexMatrix` array.\n     * @param {number} d - The second seconday index in the `vertexMatrix[c]` array.\n     * @param {boolean=false} inverseFaceDirection - If true then the face will have left winding order (instead of right which is the default).\n     */\n    DildoGeometry.prototype.addFace4ByIndices = function (a, b, c, d, inverseFaceDirection) {\n        GeometryGenerationHelpers_1.GeometryGenerationHelpers.makeFace4(this, this.vertexMatrix[a][b], this.vertexMatrix[c][b], this.vertexMatrix[a][d], this.vertexMatrix[c][d], inverseFaceDirection);\n    };\n    /**\n     * Build up the vertices in this geometry.\n     *\n     * @param {} options\n     */\n    DildoGeometry.prototype._buildVertices = function (options) {\n        var baseShape = options.baseShape;\n        var outline = options.outline;\n        var outlineSegmentCount = options.outlineSegmentCount;\n        var makeHollow = Boolean(options.makeHollow);\n        var bendAngleRad = (options.bendAngle / 180) * Math.PI;\n        var hollowStrengthX = options.hollowStrengthX; // default=15.0? // TODO: hollow strength as param\n        var twistAngle = options.twistAngle * DEG_TO_RAD;\n        var normalizePerpendiculars = Boolean(options.normalizePerpendiculars);\n        var normalsLength = typeof options.normalsLength !== \"undefined\" ? options.normalsLength : 10.0;\n        var outlineBounds = outline.getBounds();\n        var shapeHeight = outlineBounds.height;\n        var shapeBounds = baseShape.getBounds();\n        var shapeCenter = shapeBounds.getCenter();\n        var arcLength = shapeHeight;\n        var arcRadius = arcLength / bendAngleRad;\n        var isBending = options.isBending &&\n            !isNaN(arcRadius) &&\n            arcRadius !== Number.POSITIVE_INFINITY &&\n            arcRadius !== Number.NEGATIVE_INFINITY &&\n            Math.abs(bendAngleRad) > 0.01;\n        for (var s = 0; s < outlineSegmentCount; s++) {\n            var t = Math.min(1.0, Math.max(0.0, s / (outlineSegmentCount - 1)));\n            this.vertexMatrix[s] = [];\n            var outlineVert = outline.getPointAt(t);\n            var perpendicularVert = outline.getPerpendicularAt(t);\n            var heightT = (outlineBounds.max.y - outlineVert.y) / shapeHeight;\n            var outlineT = s / (outlineSegmentCount - 1);\n            this.__buildSlice(baseShape, outlineBounds, outlineVert, s, heightT, isBending, bendAngleRad, arcRadius, twistAngle * outlineT);\n            this.__buildSpine(shapeCenter, outlineBounds, outlineVert, heightT, isBending, bendAngleRad, arcRadius);\n            this.__buildPerps(baseShape, outlineBounds, outlineVert, perpendicularVert, heightT, isBending, bendAngleRad, arcRadius, normalizePerpendiculars, normalsLength);\n            // this.__buildNormals(\n            //   s,\n            //   baseShape,\n            //   outlineBounds,\n            //   outlineVert,\n            //   perpendicularVert,\n            //   heightT,\n            //   isBending,\n            //   bendAngleRad,\n            //   arcRadius,\n            //   normalizePerpendiculars,\n            //   normalsLength\n            // );\n        } // END for\n        var topVertex = this._getTopVertex(outlineBounds, isBending, bendAngleRad, arcRadius);\n        var bottomVertex = this._getBottomVertex(outlineBounds);\n        this.topIndex = this.vertices.length;\n        this.vertices.push(topVertex);\n        this.bottomIndex = this.vertices.length;\n        this.vertices.push(bottomVertex);\n        if (makeHollow) {\n            // Construct the left and the right flat bounds (used to make a casting mould)\n            this.__makeFlatSideVertices(Math.max(shapeBounds.width, shapeBounds.height) / 2.0 + hollowStrengthX);\n        }\n    };\n    DildoGeometry.prototype.__applyBumpmap = function (bumpmapTexture) {\n        var tmp = this;\n        for (var i = 0; i < this.vertexMatrix.length; i++) {\n            for (var j = 0; j < this.vertexMatrix[i].length; j++) {\n                // apply local bump map\n                // const normal = tmp.\n            }\n        }\n    };\n    return DildoGeometry;\n}(cjs_1.Gmetry)); // END class\nexports.DildoGeometry = DildoGeometry;\n// TODO: move to helpers\nvar rotateVert = function (vert, angle, xCenter, yCenter) {\n    var axis = new THREE.Vector3(0, 0, 1);\n    vert.x -= xCenter;\n    vert.y -= yCenter;\n    vert.applyAxisAngle(axis, angle);\n    vert.x += xCenter;\n    vert.y += yCenter;\n    return vert;\n};\n/**\n * Rotate a 3d vector around the y axis (up-down-axis).\n *\n * @param {THREE.Vector3} vert\n * @param {THREE.Vector3} angle\n * @param {number} xCenter\n * @param {number} zCenter\n * @returns\n */\n// TODO: move to helpers\nvar rotateVertY = function (vert, angle, xCenter, zCenter) {\n    var axis = new THREE.Vector3(0, 1, 0);\n    vert.x -= xCenter;\n    vert.z -= zCenter;\n    vert.applyAxisAngle(axis, angle);\n    vert.x += xCenter;\n    vert.z += zCenter;\n    return vert;\n};\n// /**\n//  * Normalize a 2D vector to a given length.\n//  *\n//  * @param {XYCoords} base - The start point.\n//  * @param {XYCoords} extend - The end point.\n//  * @param {number} normalLength - The desired length\n//  */\n// // TODO: add types\n// var normalizeVectorXY = function (base, extend, normalLength) {\n//   var diff = { x: extend.x - base.x, y: extend.y - base.y }; // XYCoords\n//   var length = Math.sqrt(diff.x * diff.x + diff.y * diff.y);\n//   var ratio = normalLength / length;\n//   extend.x = base.x + diff.x * ratio;\n//   extend.y = base.y + diff.y * ratio;\n// };\n/**\n * Normalize a 2D vector to a given length.\n *\n * @param {THREE.Vector3} base - The start point.\n * @param {THREE.Vector3} extend - The end point.\n * @param {number} normalLength - The desired length\n */\n// TOTO: add types\nvar normalizeVectorXYZ = function (base, extend, normalLength) {\n    var diff = { x: extend.x - base.x, y: extend.y - base.y, z: extend.z - base.z };\n    var length = Math.sqrt(diff.x * diff.x + diff.y * diff.y + diff.z * diff.z);\n    var ratio = normalLength / length;\n    extend.x = base.x + diff.x * ratio;\n    extend.y = base.y + diff.y * ratio;\n    extend.z = base.z + diff.z * ratio;\n};\n/**\n *\n * @param {THREE.Geometry} thisGeometry\n * @param {Array<number>} containingPolygonIndices\n * @param {Array<[number,number,number]>} triangles\n */\nvar makeHollowBottomUVs = function (thisGeometry, containingPolygonIndices, triangles) {\n    // Compute polyon bounds\n    var polygonBounds = plotboilerplate_1.Bounds.computeFromVertices(containingPolygonIndices.map(function (vertIndex) {\n        return new plotboilerplate_1.Vertex(thisGeometry.vertices[vertIndex].x, thisGeometry.vertices[vertIndex].z);\n    }));\n    var getUVRatios = function (vert) {\n        // console.log((vert.x - shapeBounds.min.x) / shapeBounds.width, (vert.y - shapeBounds.min.y) / shapeBounds.height);\n        return new THREE.Vector2((vert.x - polygonBounds.min.x) / polygonBounds.width, (vert.z - polygonBounds.min.y) / polygonBounds.height);\n    };\n    // ON the x-z-plane {x, *, z}\n    for (var t = 0; t < triangles.length; t++) {\n        var vertA = thisGeometry.vertices[triangles[t][0]];\n        var vertB = thisGeometry.vertices[triangles[t][1]];\n        var vertC = thisGeometry.vertices[triangles[t][2]];\n        thisGeometry.faceVertexUvs[0].push([getUVRatios(vertA), getUVRatios(vertB), getUVRatios(vertC)]);\n    }\n};\n//# sourceMappingURL=DildoGeometry.js.map","\"use strict\";\n/**\n * A collection of materials and material making functions.\n *\n * @require THREE\n *\n * @author Ikaros Kappler\n * @date 2021-07-02\n * @modified 2021-08-04 Ported to Typescript from vanilla JS.\n * @version 1.0.1\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.DildoMaterials = void 0;\nvar THREE = require(\"three\");\nexports.DildoMaterials = (function () {\n    /**\n     * Map<string,texture>\n     */\n    var textureStore = new Map();\n    var DildoMaterials = {\n        /**\n         * Create a new mesh material from the given parameters.\n         *\n         * @param {boolean} useTextureImage - Load and use the given texture (at `textureImagePath`) if set to true.\n         * @param {boolean} wireframe - Create a wireframe material if true.\n         * @param {string} textureImagePath - The texture path to use (if useTextureImage is set to true).\n         * @param {THREE.DoubleSide|THREE.FrontSide|THREE.Backside} doubleSingleSide - Wether to display one one or both face sides.\n         * @returns\n         */\n        createMainMaterial: function (useTextureImage, wireframe, textureImagePath, doubleSingleSide) {\n            return useTextureImage\n                ? new THREE.MeshLambertMaterial({\n                    color: 0xffffff,\n                    wireframe: wireframe,\n                    //   flatShading: false,\n                    depthTest: true,\n                    opacity: 1.0,\n                    // side: THREE.DoubleSide,\n                    side: doubleSingleSide,\n                    visible: true,\n                    emissive: 0x0,\n                    reflectivity: 1.0,\n                    refractionRatio: 0.89,\n                    map: DildoMaterials.loadTextureImage(textureImagePath)\n                })\n                : new THREE.MeshPhongMaterial({\n                    color: 0x3838ff,\n                    wireframe: wireframe,\n                    flatShading: false,\n                    depthTest: true,\n                    opacity: 1.0,\n                    // side: THREE.DoubleSide,\n                    side: doubleSingleSide,\n                    visible: true,\n                    emissive: 0x0,\n                    reflectivity: 1.0,\n                    refractionRatio: 0.89,\n                    map: null\n                });\n        },\n        createSliceMaterial: function (useTextureImage, wireframe, textureImagePath) {\n            if (wireframe) {\n                return new THREE.MeshBasicMaterial({ wireframe: true });\n                // return new THREE.MeshStandardMaterial({ wireframe: true });\n            }\n            else {\n                return new THREE.MeshLambertMaterial({\n                    color: useTextureImage ? 0x888888 : 0xa1848a8,\n                    wireframe: false,\n                    // flatShading: false,\n                    depthTest: true,\n                    opacity: 1.0,\n                    side: THREE.DoubleSide,\n                    // side: doubleSingleSide,\n                    visible: true,\n                    emissive: 0x0,\n                    reflectivity: 1.0,\n                    refractionRatio: 0.89,\n                    map: useTextureImage ? DildoMaterials.loadTextureImage(textureImagePath) : null,\n                    vertexColors: false\n                });\n            }\n        },\n        /**\n         * Load a texture or get it from the internal buffer if it was already loaded before.\n         *\n         * @param {string} path - The path (absolute or relative) to the texture image to load.\n         * @returns {THREE.Texture}\n         */\n        loadTextureImage: function (path) {\n            var texture = textureStore.get(path);\n            if (!texture) {\n                // TODO: use a singleton here?\n                var loader = new THREE.TextureLoader();\n                texture = loader.load(path);\n                textureStore.set(path, texture);\n            }\n            return texture;\n        }\n    };\n    return DildoMaterials;\n})();\n//# sourceMappingURL=DildoMaterials.js.map","\"use strict\";\n/**\n * A collection of helper function used to generate dildo meshes.\n *\n * @require sliceGeometry\n *\n * @author   Ikaros Kappler\n * @date     2021-06-30\n * @modified 2021-08-29 Ported to Typescript from vanilla JS.\n * @modified 2022-02-22 Replaced Gmetry by ThreeGeometryHellfix.Gmetry.\n * @version  1.0.0\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.GeometryGenerationHelpers = void 0;\nvar THREE = require(\"three\");\nvar earcut_typescript_1 = require(\"earcut-typescript\");\nvar plotboilerplate_1 = require(\"plotboilerplate\");\nvar threejs_slice_geometry_typescript_1 = require(\"threejs-slice-geometry-typescript\"); // TODO: convert to custom library\nvar PlaneMeshIntersection_1 = require(\"./PlaneMeshIntersection\");\nvar clearDuplicateVertices3_1 = require(\"./clearDuplicateVertices3\");\nvar three_geometry_hellfix_1 = require(\"three-geometry-hellfix\");\nvar UVHelpers_1 = require(\"./UVHelpers\");\nvar constants_1 = require(\"./constants\");\nexports.GeometryGenerationHelpers = {\n    /**\n     * Create a (right-turning) triangle of the three vertices at index A, B and C.\n     *\n     * The default direction (right) can be changed to left to pass `invsereFaceDirection=true`.\n     *\n     * @param {ThreeGeometryHellfix.Gmetry} geometry - The geometry to add the face to.\n     * @param {number} vertIndexA\n     * @param {number} vertIndexB\n     * @param {number} vertIndexC\n     * @param {boolean=false} inverseFaceDirection - If true then the face will have left winding order (instead of right which is the default).\n     */\n    makeFace3: function (geometry, vertIndexA, vertIndexB, vertIndexC, inverseFaceDirection) {\n        if (inverseFaceDirection) {\n            geometry.faces.push(new three_geometry_hellfix_1.Face3(vertIndexC, vertIndexB, vertIndexA));\n        }\n        else {\n            geometry.faces.push(new three_geometry_hellfix_1.Face3(vertIndexA, vertIndexB, vertIndexC));\n        }\n    },\n    /**\n     * Build a triangulated face4 (two face3) for the given vertex indices. The method will create\n     * two right-turning triangles by default, or two left-turning triangles if `inverseFaceDirection`.\n     *\n     * <pre>\n     *         A-----B\n     *         |   / |\n     *         |  /  |\n     *         | /   |\n     *         C-----D\n     * </pre>\n     *\n     * @param {ThreeGeometryHellfix.Gmetry} geometry - The geometry to add the face to.\n     * @param {number} vertIndexA - The first vertex index.\n     * @param {number} vertIndexB - The second vertex index.\n     * @param {number} vertIndexC - The third vertex index.\n     * @param {number} vertIndexD - The fourth vertex index.\n     * @param {boolean=false} inverseFaceDirection - If true then the face will have left winding order (instead of right which is the default).\n     */\n    makeFace4: function (geometry, vertIndexA, vertIndexB, vertIndexC, vertIndexD, inverseFaceDirection) {\n        if (inverseFaceDirection) {\n            // Just inverse the winding order of both face3 elements\n            exports.GeometryGenerationHelpers.makeFace3(geometry, vertIndexA, vertIndexC, vertIndexB, false);\n            exports.GeometryGenerationHelpers.makeFace3(geometry, vertIndexC, vertIndexD, vertIndexB, false);\n        }\n        else {\n            exports.GeometryGenerationHelpers.makeFace3(geometry, vertIndexA, vertIndexB, vertIndexC, false);\n            exports.GeometryGenerationHelpers.makeFace3(geometry, vertIndexB, vertIndexD, vertIndexC, false);\n        }\n    },\n    /**\n     * Create texture UV coordinates for the rectangular two  triangles at matrix indices a, b, c and d.\n     *\n     * @param {ThreeGeometryHellfix.Gmetry} geometry - The geometry to add the face to.\n     * @param {number} a - The first face-4 vertex index.\n     * @param {number} b - The second face-4 vertex index.\n     * @param {number} c - The third face-4 vertex index.\n     * @param {number} d - The fourth face-4 vertex index.\n     * @param {number} outlineSegmentCount - The total number of segments on the outline.\n     * @param {number} baseShapeSegmentCount - The total number of segments on the base shape.\n     * @param {boolean=false} inverseFaceDirection - If true then the UV mapping is applied in left winding order (instead of right which is the default).\n     */\n    addCylindricUV4: function (geometry, a, b, c, d, outlineSegmentCount, baseShapeSegmentCount, inverseFaceDirection) {\n        if (inverseFaceDirection) {\n            // change: abc -> acb\n            // change: bdc -> cdb\n            geometry.faceVertexUvs[0].push([\n                new THREE.Vector2(a / outlineSegmentCount, b / baseShapeSegmentCount),\n                new THREE.Vector2(a / outlineSegmentCount, d / baseShapeSegmentCount),\n                new THREE.Vector2(c / outlineSegmentCount, b / baseShapeSegmentCount)\n            ]);\n            geometry.faceVertexUvs[0].push([\n                new THREE.Vector2(a / outlineSegmentCount, d / baseShapeSegmentCount),\n                new THREE.Vector2(c / outlineSegmentCount, d / baseShapeSegmentCount),\n                new THREE.Vector2(c / outlineSegmentCount, b / baseShapeSegmentCount)\n            ]);\n        }\n        else {\n            geometry.faceVertexUvs[0].push([\n                new THREE.Vector2(a / outlineSegmentCount, b / baseShapeSegmentCount),\n                new THREE.Vector2(c / outlineSegmentCount, b / baseShapeSegmentCount),\n                new THREE.Vector2(a / outlineSegmentCount, d / baseShapeSegmentCount)\n            ]);\n            geometry.faceVertexUvs[0].push([\n                new THREE.Vector2(c / outlineSegmentCount, b / baseShapeSegmentCount),\n                new THREE.Vector2(c / outlineSegmentCount, d / baseShapeSegmentCount),\n                new THREE.Vector2(a / outlineSegmentCount, d / baseShapeSegmentCount)\n            ]);\n        }\n    },\n    /**\n     * Create texture UV coordinates for the triangle at matrix indices a, b and c.\n     *\n     * @param {ThreeGeometryHellfix.Gmetry} geometry - The geometry to add the new faces to.\n     * @param {number} a - The current base shape segment index, must be inside [0,baseShapeSegmentCount-1].\n     * @param {number} baseShapeSegmentCount - The total number of base shape segments.\n     */\n    addPyramidalBaseUV3: function (geometry, a, baseShapeSegmentCount) {\n        // Create a mirrored texture to avoid hard visual cuts\n        var ratioA = 1.0 - Math.abs(0.5 - a / baseShapeSegmentCount) * 2;\n        var ratioB = 1.0 - Math.abs(0.5 - (a + 1) / baseShapeSegmentCount) * 2;\n        geometry.faceVertexUvs[0].push([new THREE.Vector2(ratioA, 0), new THREE.Vector2(0.5, 1), new THREE.Vector2(ratioB, 0)]);\n    },\n    /**\n     * Flatten an array of 2d vertices into a flat array of coordinates.\n     * (required by the earcut algorithm for example).\n     *\n     * @param {Array<XYCoords>} vertices2d\n     * @returns {Array<number>}\n     */\n    flattenVert2dArray: function (vertices2d) {\n        // Array<number>\n        var coordinates = [];\n        for (var i = 0; i < vertices2d.length; i++) {\n            coordinates.push(vertices2d[i].x, vertices2d[i].y);\n        }\n        return coordinates;\n    },\n    /**\n     * A helper function to create (discrete) circular 2d shapes.\n     *\n     * @param {number} radius - The radius of the circle.\n     * @param {number} pointCount - The number of vertices to construct the circle with.\n     * @param {number=1.0} excentricity - To create ellipses (default is 1.0).\n     * @returns {Polygon}\n     */\n    mkCircularPolygon: function (radius, pointCount, excentricity) {\n        if (typeof excentricity === \"undefined\") {\n            excentricity = 1.0;\n        }\n        var vertices = [];\n        var phi;\n        for (var i = 0; i < pointCount; i++) {\n            phi = Math.PI * 2 * (i / pointCount);\n            vertices.push(new plotboilerplate_1.Vertex(Math.cos(phi) * radius * excentricity, Math.sin(phi) * radius));\n        }\n        return new plotboilerplate_1.Polygon(vertices, false);\n    },\n    /**\n     * Slice a geometry at the given plane and add the remaining part(s).\n     *\n     * Note that only the right half (on the positive z axis) is kept. To obtain both you\n     * need to run the algorithm twice with two flipped planes.\n     *\n     * Note also that the mesh is open at the cut plane.\n     *\n     * @param {ThreeGeometryHellfix.Gmetry} unbufferedGeometry - The geometry to slice.\n     * @param {THREE.Plane} plane PlaneGeometry???\n     * @return {ThreeGeometryHellfix.Gmetry}\n     */\n    makeSlice: function (unbufferedGeometry, plane) {\n        // Slice mesh into two\n        // See https://github.com/tdhooper/threejs-slice-geometry\n        var closeHoles = false; // This might be configurable in a later version.\n        // TODO: resolve typecast here.\n        //       Maybe the whole IDildoGeometry interface can be removed\n        var slicedGeometry = (0, threejs_slice_geometry_typescript_1.sliceGeometry)(unbufferedGeometry, plane, closeHoles);\n        // Now note that it's possible that the result might contain multiple vertices\n        // at the same position, which makes further calculations quite difficult.\n        // -> Merge multiple vertices into one\n        slicedGeometry.mergeVertices();\n        // And don't forget to compute the normals.\n        slicedGeometry.computeFaceNormals();\n        return slicedGeometry;\n    },\n    /**\n     * This function creates the cut intersection elements to fill the (open) slice meshes.\n     *\n     * @param {DildoGeneration} thisGenerator\n     * @param {THREE.Mesh} mesh\n     * @param {IDildoGeometry} unbufferedGeometry\n     * @param {THREE.Plane} planeGeometry\n     * @returns\n     */\n    makeAndAddPlaneIntersection: function (thisGenerator, mesh, unbufferedGeometry, // Gmetry,\n    planeGeometry, // THREE.Plane, // THREE.PlaneGeometry, // THREE.Plane ???\n    planeGeometryReal, \n    // TODO: use a proper global interface here\n    options // { showSplitShape?: boolean }\n    ) {\n        // Find the cut path\n        var planeMeshIntersection = new PlaneMeshIntersection_1.PlaneMeshIntersection();\n        // Array<THREE.Vector3>  (compatible with XYCoords :)\n        var intersectionPoints = planeMeshIntersection.getIntersectionPoints(mesh, unbufferedGeometry, planeGeometry, planeGeometryReal);\n        var EPS = 0.000001;\n        var uniqueIntersectionPoints = (0, clearDuplicateVertices3_1.clearDuplicateVertices3)(intersectionPoints, EPS);\n        // TODO: verify\n        // const pointGeometry: Gmetry = new Gmetry();\n        // pointGeometry.vertices = uniqueIntersectionPoints;\n        var pointGeometry = exports.GeometryGenerationHelpers.verticesToBufferGeometry(uniqueIntersectionPoints);\n        var pointsMaterial = new THREE.PointsMaterial({\n            size: 1.4,\n            color: 0x00ffff\n        });\n        // TODO: verify\n        // const pointsMesh: THREE.Points = new THREE.Points(pointGeometry.toBufferGeometry(), pointsMaterial);\n        var pointsMesh = new THREE.Points(pointGeometry, pointsMaterial);\n        if (options.showSplitShape) {\n            pointsMesh.position.y = -100;\n            pointsMesh.position.z = -50;\n            thisGenerator.addMesh(pointsMesh);\n        }\n        // TODO: convert point set to path\n        // Test: make a triangulation to see what the path looks like\n        var polygonData = exports.GeometryGenerationHelpers.flattenVert2dArray(uniqueIntersectionPoints);\n        // Run Earcut\n        var triangleIndices = (0, earcut_typescript_1.earcut)(polygonData);\n        // Process the earcut result;\n        //         add the retrieved triangles as geometry faces.\n        var triangleGeometry = new three_geometry_hellfix_1.Gmetry();\n        for (var i = 0; i < uniqueIntersectionPoints.length; i++) {\n            triangleGeometry.vertices.push(uniqueIntersectionPoints[i].clone());\n        }\n        for (var i = 0; i + 2 < triangleIndices.length; i += 3) {\n            var a = triangleIndices[i];\n            var b = triangleIndices[i + 1];\n            var c = triangleIndices[i + 2];\n            exports.GeometryGenerationHelpers.makeFace3(triangleGeometry, a, b, c);\n        }\n        if (options.addRawIntersectionTriangleMesh) {\n            // This is more a quick experimental preview feature.\n            // The data is often faulty and too unprecise.\n            var triangleMesh = new THREE.Mesh(triangleGeometry.toBufferGeometry(), new THREE.LineBasicMaterial({\n                color: 0xff8800\n            }));\n            triangleMesh.position.y = -100;\n            triangleMesh.position.z = -50;\n            thisGenerator.addMesh(triangleMesh);\n        }\n        // Make the actual models\n        // CURRENTLY NOT IN USE. THE UNDERLYING MODEL IS A NON-TWISTED ONE.\n        if (options.addPrecalculatedMassiveFaces) {\n            exports.GeometryGenerationHelpers.makeAndAddMassivePlaneIntersection(thisGenerator, unbufferedGeometry);\n        }\n        if (options.addPrecalculatedHollowFaces) {\n            exports.GeometryGenerationHelpers.makeAndAddHollowPlaneIntersection(thisGenerator, unbufferedGeometry);\n        }\n        return uniqueIntersectionPoints;\n    },\n    // CURRENTLY NOT REALLY IN USE. THE UNDERLYING MODEL IS A NON-TWISTED ONE.\n    makeAndAddMassivePlaneIntersection: function (thisGenerator, unbufferedGeometry) {\n        var intersectionPoints = unbufferedGeometry.getPerpendicularPathVertices(true, true); // includeBottom=true, getInner=true\n        var pointGeometry = new three_geometry_hellfix_1.Gmetry();\n        pointGeometry.vertices = intersectionPoints;\n        var pointsMaterial = new THREE.MeshBasicMaterial({\n            wireframe: false,\n            color: 0xff0000,\n            opacity: 0.5,\n            side: THREE.DoubleSide,\n            transparent: true\n        });\n        // Array<number,number,number,...>\n        var polygonData = exports.GeometryGenerationHelpers.flattenVert2dArray(intersectionPoints);\n        // Step 3: run Earcut\n        var triangleIndices = (0, earcut_typescript_1.earcut)(polygonData);\n        // Step 4: process the earcut result;\n        //         add the retrieved triangles as geometry faces.\n        for (var i = 0; i + 2 < triangleIndices.length; i += 3) {\n            var a = triangleIndices[i];\n            var b = triangleIndices[i + 1];\n            var c = triangleIndices[i + 2];\n            exports.GeometryGenerationHelpers.makeFace3(pointGeometry, a, b, c);\n        }\n        var pointsMesh = new THREE.Mesh(pointGeometry.toBufferGeometry(), pointsMaterial);\n        pointsMesh.position.y = -100;\n        pointsMesh.position.z = 50;\n        pointsMesh.userData[\"isExportable\"] = false;\n        thisGenerator.addMesh(pointsMesh);\n    },\n    // CURRENTLY NOT REALLY IN USE. THE UNDERLYING MODEL IS A NON-TWISTED ONE.\n    makeAndAddHollowPlaneIntersection: function (thisGenerator, unbufferedGeometry) {\n        var pointGeometry = new three_geometry_hellfix_1.Gmetry();\n        var perpLines = unbufferedGeometry.getPerpendicularHullLines();\n        for (var i = 0; i < perpLines.length; i++) {\n            var innerPoint = perpLines[i].start;\n            var outerPoint = perpLines[i].end;\n            pointGeometry.vertices.push(innerPoint, outerPoint);\n            var vertIndex = pointGeometry.vertices.length;\n            if (i > 0) {\n                pointGeometry.faces.push(new three_geometry_hellfix_1.Face3(vertIndex - 4, vertIndex - 2, vertIndex - 3));\n                pointGeometry.faces.push(new three_geometry_hellfix_1.Face3(vertIndex - 3, vertIndex - 2, vertIndex - 1));\n            }\n        }\n        var pointsMaterial = new THREE.MeshBasicMaterial({\n            wireframe: false,\n            color: 0xff0000,\n            opacity: 0.5,\n            side: THREE.DoubleSide,\n            transparent: true\n        });\n        var pointsMesh = new THREE.Mesh(pointGeometry.toBufferGeometry(), pointsMaterial);\n        pointsMesh.position.y = -100;\n        pointsMesh.position.z = -50;\n        pointsMesh.userData[\"isExportable\"] = false;\n        thisGenerator.addMesh(pointsMesh);\n    },\n    /**\n     * Add an orange colored line mesh from a spine geometry..\n     *\n     * @param {DildoGeneration} thisGenerator - The generator to add the new mesh to.\n     * @param {ThreeGeometryHellfix.Gmetry} spineGeometry - The spine geometry itself.\n     */\n    addSpine: function (thisGenerator, spineGeometry) {\n        var spineMesh = new THREE.LineSegments(spineGeometry.toBufferGeometry(), new THREE.LineBasicMaterial({\n            color: 0xff8800\n        }));\n        spineMesh.position.y = -100;\n        thisGenerator.addMesh(spineMesh);\n    },\n    /**\n     * This function creates two line-meshes in red and green indicating the perpendicular cut\n     * path along the geometry to be sliced.\n     *\n     * @param {DildoGeneration} thisGenerator - The generator to add the new two meshes to.\n     * @param {DildoGeometry} unbufferedDildoGeometry - The dildo geometry to retrieve the perpendicular path from.\n     */\n    addPerpendicularPaths: function (thisGenerator, unbufferedDildoGeometry) {\n        exports.GeometryGenerationHelpers.addPerpendicularPath(thisGenerator, unbufferedDildoGeometry.outerPerpLines, 0xff0000);\n        exports.GeometryGenerationHelpers.addPerpendicularPath(thisGenerator, unbufferedDildoGeometry.innerPerpLines, 0x00ff00);\n    },\n    /**\n     * Add the given array of perpendicular lines (perpendicular to the mesh surface along the cut path)\n     * as a THREE.LineSegments geometry.\n     *\n     * @param {DildoGeneration} thisGenerator - The generator to add the created line mesh to.\n     * @param {Array<THREE.Line3>} perpLines - The lines to\n     * @param {number} materialColor - A color for the material to use (like 0xff0000 for red).\n     */\n    addPerpendicularPath: function (thisGenerator, perpLines, materialColor) {\n        var outerPerpGeometry = new three_geometry_hellfix_1.Gmetry();\n        perpLines.forEach(function (perpLine) {\n            outerPerpGeometry.vertices.push(perpLine.start.clone());\n            outerPerpGeometry.vertices.push(perpLine.end.clone());\n        });\n        var outerPerpMesh = new THREE.LineSegments(outerPerpGeometry.toBufferGeometry(), new THREE.LineBasicMaterial({\n            color: materialColor\n        }));\n        outerPerpMesh.position.y = -100;\n        thisGenerator.addMesh(outerPerpMesh);\n    },\n    // TODO: add to global helper functions\n    /**\n     * Make a triangulation of the given path specified by the verted indices.\n     *\n     * @param {Array<number>} connectedPath - An array of vertex indices.\n     * @return {ThreeGeometryHellfix.Gmetry} trianglesMesh\n     */\n    makePlaneTriangulation: function (generator, sliceGeometry, connectedPath, options) {\n        // Convert the connected paths indices to [x, y, x, y, x, y, ...] coordinates (requied by earcut)\n        var currentPathXYData = connectedPath.reduce(function (earcutInput, vertIndex) {\n            var vert = sliceGeometry.vertices[vertIndex];\n            earcutInput.push(vert.x, vert.y);\n            return earcutInput;\n        }, []);\n        // Array<number> : triplets of vertex indices in the plain XY array\n        var triangles = (0, earcut_typescript_1.earcut)(currentPathXYData);\n        // Convert triangle indices back to a geometry\n        var trianglesGeometry = new three_geometry_hellfix_1.Gmetry();\n        // We will merge the geometries in the end which will create clones of the vertices.\n        // No need to clone here.\n        // trianglesGeometry.vertices = leftSliceGeometry.vertices;\n        trianglesGeometry.vertices = connectedPath.map(function (geometryVertexIndex) {\n            return sliceGeometry.vertices[geometryVertexIndex];\n        });\n        // Array<{x,y}> is compatible with Array<{x,y,z}> here :)\n        var flatSideBounds = plotboilerplate_1.Bounds.computeFromVertices(trianglesGeometry.vertices.map(function (vector3) { return new plotboilerplate_1.Vertex(vector3.x, vector3.y); }));\n        for (var t = 0; t < triangles.length; t += 3) {\n            var a = triangles[t];\n            var b = triangles[t + 1];\n            var c = triangles[t + 2];\n            trianglesGeometry.faces.push(new three_geometry_hellfix_1.Face3(a, b, c));\n            // Add UVs\n            UVHelpers_1.UVHelpers.makeFlatTriangleUVs(trianglesGeometry, flatSideBounds, a, b, c);\n        }\n        trianglesGeometry.uvsNeedUpdate = true;\n        // TODO: check if this is still required\n        trianglesGeometry.buffersNeedUpdate = true;\n        trianglesGeometry.computeVertexNormals();\n        var trianglesMesh = new THREE.Mesh(trianglesGeometry.toBufferGeometry(), new THREE.MeshBasicMaterial({\n            color: 0x0048ff,\n            transparent: true,\n            opacity: 0.55,\n            side: THREE.DoubleSide\n        }));\n        trianglesMesh.position.y = -100;\n        // trianglesMesh.position.z += 1.0; // Avoid Moir with plane mesh?\n        trianglesMesh.userData[\"isExportable\"] = false;\n        generator.partialResults[constants_1.KEY_PLANE_INTERSECTION_TRIANGULATION] = trianglesGeometry;\n        if (options.showSplitShapeTriangulation) {\n            generator.addMesh(trianglesMesh);\n        }\n        return trianglesGeometry;\n    },\n    /**\n     * Normalize a 2D vector to a given length.\n     *\n     * @param {XYCoords} base - The start point.\n     * @param {XYCoords} extend - The end point.\n     * @param {number} normalLength - The desired length\n     */\n    // TODO: add types\n    normalizeVectorXY: function (base, extend, normalLength) {\n        var diff = { x: extend.x - base.x, y: extend.y - base.y }; // XYCoords\n        var length = Math.sqrt(diff.x * diff.x + diff.y * diff.y);\n        var ratio = normalLength / length;\n        extend.x = base.x + diff.x * ratio;\n        extend.y = base.y + diff.y * ratio;\n    },\n    /**\n     * Normalize a 2D vector to a given length.\n     *\n     * @param {XYCoords} base - The start point.\n     * @param {XYCoords} extend - The end point.\n     * @param {number} normalLength - The desired length\n     */\n    // TODO: add types\n    normalizeVectorXYZ: function (base, extend, normalLength) {\n        var diff = { x: extend.x - base.x, y: extend.y - base.y, z: extend.z - base.z };\n        var length = Math.sqrt(diff.x * diff.x + diff.y * diff.y + diff.z * diff.z);\n        var ratio = normalLength / length;\n        extend.x = base.x + diff.x * ratio;\n        extend.y = base.y + diff.y * ratio;\n        extend.z = base.z + diff.z * ratio;\n    },\n    /**\n     * A helper function to clear all child nodes from the given HTML DOM node.\n     *\n     * @param {HTMLElement} rootNoode\n     */\n    removeAllChildNodes: function (rootNode) {\n        while (rootNode.lastChild) {\n            rootNode.removeChild(rootNode.lastChild);\n        }\n    },\n    /**\n     * Clamp the given number into the passed min-max interval.\n     *\n     * @param {number} n\n     * @param {number} min\n     * @param {number} max\n     * @returns\n     */\n    clamp: function (n, min, max) {\n        return Math.max(Math.min(n, max), min);\n    },\n    verticesToBufferGeometry: function (vertices) {\n        var geometry = new THREE.BufferGeometry();\n        // create a simple square shape. We duplicate the top left and bottom right\n        // vertices because each vertex needs to appear once per triangle.\n        var vertexData = new Float32Array(vertices.reduce(function (accu, vert) {\n            accu.push(vert.x, vert.y, vert.z);\n            return accu;\n        }, []));\n        // itemSize = 3 because there are 3 values (components) per vertex\n        geometry.setAttribute(\"position\", new THREE.BufferAttribute(vertexData, 3));\n        return geometry;\n    }\n};\n//# sourceMappingURL=GeometryGenerationHelpers.js.map","\"use strict\";\n/**\n * @author  Ikaros Kappler\n * @date    2021-09-02\n * @version 1.0.0\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.ImageStore = void 0;\nexports.ImageStore = (function () {\n    var imageMap = new Map();\n    var Store = {\n        getImage: function (path, onComplete) {\n            // Try to find in store\n            var image = imageMap.get(path);\n            if (!image) {\n                image = document.createElement(\"img\"); // as HTMLImageElement;\n                imageMap.set(path, image);\n                image.onload = function () {\n                    onComplete(image);\n                };\n                image.setAttribute(\"src\", path);\n            }\n            return image;\n        },\n        isImageLoaded: function (image) {\n            return image.complete && image.naturalHeight !== 0 && image.naturalHeight !== undefined;\n        }\n    };\n    return Store;\n})();\n//# sourceMappingURL=ImageStore.js.map","\"use strict\";\n/**\n * A basic IO interface for storing and retrieving json data from local storage.\n *\n * @author   Ikaros Kappler\n * @date     2021-10-13\n * @modified 2022-02-02 Removed the dnd IO (using FileDrop.js instead).\n * @version  1.1.0\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.LocalstorageIO = void 0;\nvar LocalstorageIO = /** @class */ (function () {\n    /**\n     *\n     * @param {HTMLElement} element - The element you wish to operate as the drop zone (like <body/>).\n     */\n    function LocalstorageIO() {\n    }\n    /**\n     * Install a callback for retrieving the `bezier_path` string from the localstorage.\n     *\n     * @param {(data:string)=>void} handlePathRestored - The callback to handle the retrieved storage value. Will be called immediately.\n     * @param {()=>string} requestPath - Requests the `bezier_path` string value to store; will be called on a 10 second timer interval.\n     */\n    LocalstorageIO.prototype.onPathRestored = function (handlePathRestored, requestPath) {\n        var bezierJSON = localStorage.getItem(\"bezier_path\");\n        if (bezierJSON) {\n            handlePathRestored(bezierJSON);\n        }\n        setInterval(function () {\n            var newBezierJSON = requestPath();\n            if (newBezierJSON) {\n                localStorage.setItem(\"bezier_path\", newBezierJSON);\n            }\n        }, 10000);\n    };\n    return LocalstorageIO;\n}());\nexports.LocalstorageIO = LocalstorageIO;\n//# sourceMappingURL=LocalstorageIO.js.map","\"use strict\";\n/**\n * The PathFinger tool will find the connected path on a mesh surface, given by a set\n * of vertices that lay on the geometry's surface.\n *\n * Each vertex in the path elements array must be at some gometry vertex position. The position\n * does not necessarily need to be exact, some epsilon is used (default epsilon is 0.000001).\n *\n * @author   Ikaros Kappler\n * @modified 2021-08-29 Ported to Typescript from vanilla JS.\n * @modified 2022-02-22 Replaced THREE.Geometry by ThreeGeometryHellfix.Gmetry.\n * @date     2021-07-06\n * @version  1.0.1\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.PathFinder = void 0;\nvar constants_1 = require(\"./constants\");\nvar PathFinder = /** @class */ (function () {\n    /**\n     * Construct a new PathFinder.\n     *\n     * @param {number=0.000001} epsilon - (optional) Specity any custom epsilon here if the default epsilon is too large/small. Must be >= 0.\n     */\n    function PathFinder(epsilon) {\n        this.visitedVertices = new Set();\n        this.unvisitedVertIndices = new Set(); // <number>\n        this.numVisitedVertices = 0;\n        this.epsilon = typeof epsilon !== \"undefined\" && epsilon >= 0 ? epsilon : constants_1.EPS;\n    }\n    /**\n     * Find all connected paths specified by the path vertex array, that lay on the geometry's surface.\n     *\n     * If the vertices depict more than one path, then the returned array will contain\n     * multiple paths, too.\n     *\n     * The pathVertices array must not contain duplicates.\n     *\n     * @param {ThreeGeometryHellfix.Gmetry} unbufferedGeometry - The geometry itself containing the path vertices.\n     * @param {THREE.Vector3[]} pathVertices - The unsorted vertices (must form a connected path on the geometry).\n     * @return {Array<number[]>} An array of paths; each path consists of an array of path vertex indices in the `pathVertices` param.\n     */\n    PathFinder.prototype.findAllPathsOnMesh = function (unbufferedGeometry, pathVertices) {\n        var collectedPaths = []; // Array<number[]>\n        this.visitedVertices.clear();\n        this.unvisitedVertIndices.clear();\n        // Map path vertices to vertices in the geometry.\n        //\n        // Please note that the index array might be shorter than the vertex array itself, if some vertices could\n        // not be located in the geometry.\n        //\n        var pathVertIndices = mapVerticesToGeometryIndices(unbufferedGeometry, pathVertices, this.epsilon);\n        var n = pathVertIndices.length;\n        // Initially build up an array of path vertices, marking them all as unvisited.\n        this.unvisitedVertIndices = new Set(pathVertIndices.map(function (_pathVert, index) {\n            return index;\n        }));\n        // As long as there are path vertices unvisited, there are sill portions of the path(s)\n        // to be processed.\n        while (this.numVisitedVertices < n) {\n            var nextUnvisitedIndex = this.unvisitedVertIndices.values().next().value;\n            // Array<number>\n            var path = this.findUnvisitedPaths(unbufferedGeometry, pathVertIndices, nextUnvisitedIndex);\n            collectedPaths.push(path);\n        }\n        // Try to find adjacent paths to connect them.\n        return this.combineAdjacentPaths(collectedPaths, unbufferedGeometry);\n    };\n    /**\n     * Find the next sequence unvisited path (indices) of vertices that are directly connected\n     * via some faces on the geometry's surface.\n     *\n     * Be aware that path detection only works in one direction, so you will probably end up\n     * in several paths that can still be connected, if you start with some random vertex\n     * index.\n     *\n     * @param {ThreeGeometryHellfix.Gmetry} unbufferedGeometry - The geometry to use to find connected vertices (use it's faces).\n     * @param {Array<number>} pathVertIndices - The indices of all vertices that form the path(s). Each index must match a vertex in the geometry's `vertices` array.\n     * @param {number} unvisitedIndex - The path vertex (index) to start with. This can be picked randomly.\n     * @returns {Array<number>} The indices of the found path in an array (index sequence).\n     */\n    PathFinder.prototype.findUnvisitedPaths = function (unbufferedGeometry, pathVertIndices, unvisitedIndex) {\n        var path = [unvisitedIndex]; // which elements?\n        this.visitedVertices.add(unvisitedIndex);\n        this.unvisitedVertIndices.delete(unvisitedIndex);\n        this.numVisitedVertices++;\n        // Find the the face for this vertex's index\n        // var faceAndVertIndex; // { faceIndex: number, vertIndex: number }\n        var adjacentVertIndex;\n        while ((adjacentVertIndex = this.findAdjacentFace(unbufferedGeometry, pathVertIndices, unvisitedIndex)) !== -1) {\n            // Retrieved face/vertex tuple represents the next element on the path\n            path.push(adjacentVertIndex);\n            this.visitedVertices.add(adjacentVertIndex);\n            this.unvisitedVertIndices.delete(adjacentVertIndex);\n            this.numVisitedVertices++;\n            unvisitedIndex = adjacentVertIndex;\n        }\n        return path;\n    };\n    /**\n     * Find the next unvisited vertex index that connects the given (unvisited) vertex\n     * index of the path.\n     *\n     * To find that the geometry's faces will be used.\n     *\n     * @param {ThreeGeometryHellfix.Gmetry} unbufferedGeometry\n     * @param {Array<number>} pathVertIndices\n     * @param {number} unvisitedIndex\n     * @returns {number} The next adjacent face index or -1 if none can be found.\n     */\n    PathFinder.prototype.findAdjacentFace = function (unbufferedGeometry, pathVertIndices, unvisitedIndex) {\n        var faceCount = unbufferedGeometry.faces.length;\n        for (var f = 0; f < faceCount; f++) {\n            if (faceHasVertIndex(unbufferedGeometry, f, unvisitedIndex)) {\n                // Face is a canditate to extend the path.\n                // Check if there is a second un-visited path vertex\n                for (var i = 0; i < pathVertIndices.length; i++) {\n                    var pathVertIndex = pathVertIndices[i];\n                    if (pathVertIndex === unvisitedIndex) {\n                        continue;\n                    }\n                    if (this.isVisited(pathVertIndex)) {\n                        continue;\n                    }\n                    if (!this.isVisited(pathVertIndex) && faceHasVertIndex(unbufferedGeometry, f, pathVertIndex)) {\n                        return pathVertIndex;\n                    }\n                    if (faceHasVertIndex(unbufferedGeometry, f, pathVertIndex)) {\n                        return pathVertIndex;\n                    }\n                } // END for\n            } // END if\n        } // END for\n        // At this point no matching face was found\n        return -1;\n    };\n    /**\n     * Checks if the given vertex index (one of the path vertices) was already\n     * marked as being visited.\n     *\n     * @param {number} vertIndex\n     * @returns {boolean}\n     */\n    PathFinder.prototype.isVisited = function (vertIndex) {\n        return this.visitedVertices.has(vertIndex);\n    };\n    /**\n     * Find adjacent paths and connect them.\n     *\n     * @param {Array<number[]>} collectedPaths\n     * @param {ThreeGeometryHellfix.Gmetry} unbufferedGeometry\n     * @param {THREE.Vector3[]} pathVertices\n     * @return {Array<number[]>} A new sequence of paths (a path is an array of vertex indices).\n     */\n    PathFinder.prototype.combineAdjacentPaths = function (collectedPaths, unbufferedGeometry) {\n        var resultPaths = [];\n        // First build up an unvisited path set (set of path indices)\n        var unvisitedPathIndexSet = new Set(collectedPaths.map(function (_path, index) {\n            return index;\n        }));\n        while (unvisitedPathIndexSet.size > 0) {\n            var currentPathIndex = unvisitedPathIndexSet.values().next().value;\n            unvisitedPathIndexSet.delete(currentPathIndex);\n            var currentPath = collectedPaths[currentPathIndex];\n            var nextPath = null; // TODO: type?\n            do {\n                nextPath = findAdjacentPath(collectedPaths, currentPath[currentPath.length - 1], unvisitedPathIndexSet, unbufferedGeometry);\n                if (!nextPath && currentPath.length > 1) {\n                    // If path's end point has no connection try reversed path\n                    currentPath = currentPath.reverse();\n                    nextPath = findAdjacentPath(collectedPaths, currentPath[currentPath.length - 1], unvisitedPathIndexSet, unbufferedGeometry);\n                }\n                if (nextPath) {\n                    currentPath = currentPath.concat(nextPath);\n                }\n            } while (nextPath);\n            // All adjacent paths found and connected.\n            resultPaths.push(currentPath);\n        }\n        return resultPaths;\n    };\n    return PathFinder;\n}()); // END class\nexports.PathFinder = PathFinder;\n/**\n * A simple check to determine if a face of the geometry (given by the face index)\n * is adjacent to the given vertex index (a vertex index in the geometry.).\n *\n * @param {ThreeGeometryHellfix.Gmetry} unbufferedGeometry\n * @param {number} faceIndex\n * @param {number} geometryVertexIndex\n * @returns\n */\nvar faceHasVertIndex = function (unbufferedGeometry, faceIndex, geometryVertexIndex) {\n    var face = unbufferedGeometry.faces[faceIndex];\n    return face.a === geometryVertexIndex || face.b === geometryVertexIndex || face.c === geometryVertexIndex;\n};\n/**\n * Get an array of vertex indices inside the geometry that represent the given path vertices,\n *\n * If no equivalent geometry vertex can be found (for a path vertex) then the path vertex\n * will be skipped.\n * So the returned array might be shorter than the path  and thus, have gaps.\n *\n * @param {ThreeGeometryHellfix.Gmetry} unbufferedGeometry - The Three.js geometry to use.\n * @param {Array<THREE.Vector3>} pathVertices - The acual mesh vertices of the current path.\n * @param {number} epsilon - Is required here (just pass through).\n * @returns\n */\nvar mapVerticesToGeometryIndices = function (unbufferedGeometry, pathVertices, epsilon) {\n    var pathVertIndices = [];\n    for (var i = 0; i < pathVertices.length; i++) {\n        var pathVert = pathVertices[i];\n        var foundIndex = -1;\n        var foundDist = epsilon;\n        for (var j = 0; j < unbufferedGeometry.vertices.length; j++) {\n            var curDist = unbufferedGeometry.vertices[j].distanceTo(pathVert);\n            if (curDist <= foundDist) {\n                // Remember geometry index if closest to path vertex\n                if (foundIndex === -1 ||\n                    // By convention use smalled vertex index if multiple found\n                    (foundIndex !== -1 && unbufferedGeometry.vertices[foundIndex].distanceTo(pathVert) >= curDist && foundIndex > j)) {\n                    foundIndex = j;\n                    foundDist = curDist;\n                }\n            }\n        }\n        if (foundIndex === -1) {\n            console.warn(\"PathFinder.mapVerticesToGeometryIndices could not find a matching geometry vertex for path point \" +\n                i +\n                \". The final result might be locally broken.\");\n        }\n        else {\n            // Note: it may be possible that NO MATCHING GEOMETRY VERT was found (foundIndex = -1).\n            pathVertIndices.push(foundIndex);\n        }\n    } // END for i\n    return pathVertIndices;\n};\n/**\n * This is a helper function to find adjacent sub paths and connect them.\n * It expects basic path segments already to be found and that they are\n * somehow connected. Unconnected paths  which are possible in non-convex\n * geometries  will stay unconnected.\n *\n * It locates the next path that connects to the given (current) path\n * and returns the acual path indices in the correct order. Forward paths\n * and backward paths are detected here and being brought into the correct\n * order.\n *\n * Example: if a path connects with it's end vertex to the end of the given\n * path, then it will be reversed.\n *\n * @param {Array<number[]>} collectedPaths - The array of paths (array of array)\n * @param {number} currentVertIndex - The vertex index in the geometry to find the next adjacent path for.\n * @param {Set<number>} unvisitedPathIndexSet - A set to keep track of unvisited vertex indices. Will be updated.\n * @param {ThreeGeometryHellfix.Gmetry} unbufferedGeometry - The geometry to find the path on.\n * @returns\n */\nvar findAdjacentPath = function (collectedPaths, currentVertIndex, unvisitedPathIndexSet, unbufferedGeometry) {\n    for (var f = 0; f < unbufferedGeometry.faces.length; f++) {\n        if (faceHasVertIndex(unbufferedGeometry, f, currentVertIndex)) {\n            // Now find any unvisited path (first or last point) that connects here.\n            for (var p = 0; p < collectedPaths.length; p++) {\n                if (!unvisitedPathIndexSet.has(p)) {\n                    // Path already visited\n                    continue;\n                }\n                var nextPath = collectedPaths[p];\n                if (faceHasVertIndex(unbufferedGeometry, f, nextPath[0])) {\n                    // Concat forwards\n                    unvisitedPathIndexSet.delete(p);\n                    return nextPath;\n                }\n                else if (faceHasVertIndex(unbufferedGeometry, f, nextPath[nextPath.length - 1])) {\n                    // Concat backwards\n                    unvisitedPathIndexSet.delete(p);\n                    return nextPath.reverse();\n                }\n            }\n        }\n    }\n};\n//# sourceMappingURL=PathFinder.js.map","\"use strict\";\n/**\n * Compute the intersection of a mesh and a plane.\n *\n * Inspired by\n *    https://stackoverflow.com/questions/42348495/three-js-find-all-points-where-a-mesh-intersects-a-plane\n *    https://jsfiddle.net/prisoner849/8uxw667m/\n *\n * @co-author Ikaros Kappler\n * @date 2021-06-11\n * @modified 2021-08-29 Ported to Typescript from vanilla JS.\n * @modified 2022-02-22 Replaced THREE.Geometry by ThreeGeometryHellfix.Gmetry.\n * @version 1.0.1\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.PlaneMeshIntersection = void 0;\nvar THREE = require(\"three\");\nvar PlaneMeshIntersection = /** @class */ (function () {\n    /**\n     * Constructor.\n     */\n    function PlaneMeshIntersection() {\n        var _this = this;\n        /**\n         *\n         * @param {THREE.Mesh} mesh\n         * @param {ThreeGeometryHellfix.Gmetry} geometry\n         * @param {THREE.Mesh} plane {THREE.PlaneGeometry ???\n         * @returns {Array<THREE.Vector3>}\n         */\n        // TODO: plane type???\n        this.getIntersectionPoints = function (mesh, geometry, plane, planeGeometryReal) {\n            // Note: this could also work with a directly passed Mesh.Plane object instead a THREE.PlaneGeometry.\n            _this.pointsOfIntersection = [];\n            var mathPlane = new THREE.Plane();\n            // var planeGeometry : THREE.Geometry = (plane as unknown).geometry;\n            // plane.localToWorld(this.planePointA.copy(plane.geometry.vertices[plane.geometry.faces[0].a]));\n            // plane.localToWorld(this.planePointB.copy(plane.geometry.vertices[plane.geometry.faces[0].b]));\n            // plane.localToWorld(this.planePointC.copy(plane.geometry.vertices[plane.geometry.faces[0].c]));\n            // TODO: https://discourse.threejs.org/t/three-geometry-will-be-removed-from-core-with-r125/22401/13\n            // plane.localToWorld(this.planePointA.copy(planeGeometryReal.vertices[planeGeometryReal.faces[0].a]));\n            // plane.localToWorld(this.planePointB.copy(planeGeometryReal.vertices[planeGeometryReal.faces[0].b]));\n            // plane.localToWorld(this.planePointC.copy(planeGeometryReal.vertices[planeGeometryReal.faces[0].c]));\n            var _a = getThreePlanePoints(planeGeometryReal), a = _a[0], b = _a[1], c = _a[2];\n            plane.localToWorld(_this.planePointA.copy(a));\n            plane.localToWorld(_this.planePointB.copy(b));\n            plane.localToWorld(_this.planePointC.copy(c));\n            mathPlane.setFromCoplanarPoints(_this.planePointA, _this.planePointB, _this.planePointC);\n            var _self = _this;\n            geometry.faces.forEach(function (face) {\n                mesh.localToWorld(_self.a.copy(geometry.vertices[face.a]));\n                mesh.localToWorld(_self.b.copy(geometry.vertices[face.b]));\n                mesh.localToWorld(_self.c.copy(geometry.vertices[face.c]));\n                _self.lineAB = new THREE.Line3(_self.a, _self.b);\n                _self.lineBC = new THREE.Line3(_self.b, _self.c);\n                _self.lineCA = new THREE.Line3(_self.c, _self.a);\n                _self.__setPointOfIntersection(_self.lineAB, mathPlane);\n                _self.__setPointOfIntersection(_self.lineBC, mathPlane);\n                _self.__setPointOfIntersection(_self.lineCA, mathPlane);\n            });\n            return _this.pointsOfIntersection;\n        };\n        this.__setPointOfIntersection = function (line, plane) {\n            var intersectionPoint = plane.intersectLine(line, this.pointOfIntersection);\n            if (intersectionPoint) {\n                this.pointsOfIntersection.push(intersectionPoint.clone());\n            }\n        };\n        //   Vector3[]\n        this.pointsOfIntersection = [];\n        this.a = new THREE.Vector3();\n        this.b = new THREE.Vector3();\n        this.c = new THREE.Vector3();\n        this.planePointA = new THREE.Vector3();\n        this.planePointB = new THREE.Vector3();\n        this.planePointC = new THREE.Vector3();\n        this.lineAB = new THREE.Line3();\n        this.lineBC = new THREE.Line3();\n        this.lineCA = new THREE.Line3();\n        this.pointOfIntersection = new THREE.Vector3();\n    }\n    return PlaneMeshIntersection;\n}());\nexports.PlaneMeshIntersection = PlaneMeshIntersection;\n// https://discourse.threejs.org/t/three-geometry-will-be-removed-from-core-with-r125/22401/13\n//\n// Due to Mugen87 accessing vertices in the BufferGeometry (replacing Geomtry) works like this:\n//\n// const positionAttribute = MovingCube.geometry.getAttribute( 'position' );\n// const localVertex = new THREE.Vector3();\n// const globalVertex = new THREE.Vector3();\n// for ( let vertexIndex = 0; vertexIndex < positionAttribute.count; vertexIndex ++ ) {\n// \tlocalVertex.fromBufferAttribute( positionAttribute, vertexIndex );\n// \tglobalVertex.copy( localVertex ).applyMatrix4( MovingCube.matrixWorld );\n// }\nvar getThreePlanePoints = function (planeGeometryReal) {\n    var positionAttribute = planeGeometryReal.getAttribute(\"position\");\n    var localVertex = new THREE.Vector3();\n    // const globalVertex = new THREE.Vector3();\n    // for ( let vertexIndex = 0; vertexIndex < positionAttribute.count; vertexIndex ++ ) {\n    // \tlocalVertex.fromBufferAttribute( positionAttribute, vertexIndex );\n    // \t// globalVertex.copy( localVertex ).applyMatrix4( planeGeometryReal.matrixWorld );\n    // }\n    var a = new THREE.Vector3();\n    var b = new THREE.Vector3();\n    var c = new THREE.Vector3();\n    a.fromBufferAttribute(positionAttribute, 0);\n    b.fromBufferAttribute(positionAttribute, 1);\n    c.fromBufferAttribute(positionAttribute, 2);\n    return [a, b, c];\n};\n//# sourceMappingURL=PlaneMeshIntersection.js.map","\"use strict\";\n/**\n * @author   Ikaros Kappler\n * @date     2021-08-03\n * @modified 2021-08-04 Ported to Typsescript from vanilla JS.\n * @modified 2022-02-22 Replaced THREE.Geometry by ThreeGeometryHellfix.Gmetry.\n * @version  1.0.2\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.UVHelpers = void 0;\nvar THREE = require(\"three\");\nexports.UVHelpers = {\n    /**\n     * Helper function to create triangular UV Mappings for a triangle.\n     *\n     * @param {ThreeGeometryHellfix.Gmetry} thisGeometry\n     * @param {Bounds} shapeBounds\n     * @param {number} vertIndexA - The index in the geometry's vertices array.\n     * @param {number} vertIndexB - ...\n     * @param {number} vertIndexC - ...\n     */\n    makeFlatTriangleUVs: function (thisGeometry, // THREE.Geometry does not longer exist since r125 and will be replaced by BufferGeometry\n    shapeBounds, vertIndexA, vertIndexB, vertIndexC) {\n        var vertA = thisGeometry.vertices[vertIndexA];\n        var vertB = thisGeometry.vertices[vertIndexB];\n        var vertC = thisGeometry.vertices[vertIndexC];\n        // Convert a position vertex { x, y, * } to UV coordinates { u, v }\n        var getUVRatios = function (vert) {\n            return new THREE.Vector2((vert.x - shapeBounds.min.x) / shapeBounds.width, (vert.y - shapeBounds.min.y) / shapeBounds.height);\n        };\n        thisGeometry.faceVertexUvs[0].push([getUVRatios(vertA), getUVRatios(vertB), getUVRatios(vertC)]);\n    }\n};\n//# sourceMappingURL=UVHelpers.js.map","\"use strict\";\n/**\n * @author   Ikaros Kappler\n * @date     2021-07-13\n * @modified 2021-08-04 Ported to Typescript from vainlla JS.\n * @version  1.0.1\n **/\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.clearDuplicateVertices3 = void 0;\nvar EPS = 0.000001;\n/**\n * Filter the array and clear all duplicates.\n *\n * The original array is left unchanged. The vertices in the array are not cloned.\n *\n * @param {THREE.Vector3[]} vertices\n * @param {number=EPS} epsilon\n * @return {THREE.Vector3[]}\n */\nvar clearDuplicateVertices3 = function (vertices, epsilon) {\n    if (typeof epsilon === \"undefined\") {\n        epsilon = EPS;\n    }\n    var result = [];\n    for (var i = 0; i < vertices.length; i++) {\n        if (!containsElementFrom(vertices, vertices[i], i + 1, epsilon)) {\n            result.push(vertices[i]);\n        }\n    }\n    return result;\n};\nexports.clearDuplicateVertices3 = clearDuplicateVertices3;\n/**\n * A distance checker: check if the passed to vertices are no more than 'eps' units apart.\n *\n * @param {THREE.Vector3} vertA\n * @param {THREE.Vector3} vertB\n * @param {number} eps\n * @returns {boolean}\n */\nvar isCloseTo = function (vertA, vertB, eps) {\n    return vertA.distanceTo(vertB) < eps;\n};\n/**\n * Try to find an element in the given vertex array, starting at a given position (inclusive).\n *\n * @param {THREE.Vector3[]} vertices\n * @param {THREE.Vector3} vertex\n * @param {number} fromIndex\n * @param {number} epsilon\n * @returns {boolan}\n */\nvar containsElementFrom = function (vertices, vertex, fromIndex, epsilon) {\n    for (var i = fromIndex; i < vertices.length; i++) {\n        if (isCloseTo(vertices[i], vertex, epsilon)) {\n            return true;\n        }\n    }\n    return false;\n};\n//# sourceMappingURL=clearDuplicateVertices3.js.map","\"use strict\";\n/**\n * Calculate the vertex normals of a mesh from the pre-calculated face normals.\n *\n * jkmott writing about this challenge:\n *   >> If you have a large complex mesh with small faces you can get away with\n *   >> computing the vertex normals by taking the average of the face normals\n *   >> that surround it, and thats a fine strategy.\n *\n * https://meshola.wordpress.com/2016/07/24/three-js-vertex-normals/\n *\n * @author   Ikaros Kappler\n * @date     2021-08-31\n * @modified 2022-02-22 Replaced THREE.Geometry by ThreeGeometryHellfix.Gmetry.\n * @version  1.0.1\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.computeVertexNormals = void 0;\nvar THREE = require(\"three\");\n/**\n * Compute the vertex normals of a base geometry and its buffered counterpart (both parts are required here).\n *\n * Note that unbufferedGeometry.computeVertexNormals() must have been called for this to work.\n *\n * @param {ThreeGeometryHellfix.Gmetry} unbufferedGeometry - The base geometry.\n * @param {THREE.BufferedGeometry} bufferedGeometry - The buffered geometry.\n * @returns\n */\nvar computeVertexNormals = function (unbufferedGeometry, bufferedGeometry) {\n    // Fetch the face normals from the buffers.\n    var vertexNormals = bufferedGeometry.getAttribute(\"normal\");\n    var collectedFaceNormals = Array(unbufferedGeometry.faces.length);\n    // For each face get the three face normals, each of which consists of 3 float values itself.\n    // So each face consumes 9 floats from the array buffer.\n    for (var f = 0; f < unbufferedGeometry.faces.length; f++) {\n        var face = unbufferedGeometry.faces[f];\n        var faceNormalA = new THREE.Vector3(vertexNormals.array[f * 9 + 0], vertexNormals.array[f * 9 + 1], vertexNormals.array[f * 9 + 2]);\n        var faceNormalB = new THREE.Vector3(vertexNormals.array[f * 9 + 3], vertexNormals.array[f * 9 + 4], vertexNormals.array[f * 9 + 5]);\n        var faceNormalC = new THREE.Vector3(vertexNormals.array[f * 9 + 6], vertexNormals.array[f * 9 + 7], vertexNormals.array[f * 9 + 8]);\n        addVertexNormal(collectedFaceNormals, face.a, faceNormalA);\n        addVertexNormal(collectedFaceNormals, face.b, faceNormalB);\n        addVertexNormal(collectedFaceNormals, face.c, faceNormalC);\n    } // END for\n    //   console.log(\"collectedFaceNormals\", collectedFaceNormals);\n    var normals = new Array(unbufferedGeometry.vertices.length);\n    for (var i = 0; i < unbufferedGeometry.vertices.length; i++) {\n        var averageNormal = computeAverageVector(collectedFaceNormals[i]);\n        averageNormal.add(unbufferedGeometry.vertices[i]);\n        normals[i] = new THREE.Line3(unbufferedGeometry.vertices[i], averageNormal);\n    }\n    return normals;\n};\nexports.computeVertexNormals = computeVertexNormals;\n/**\n * Add the computed face normal to the given vertex normal buffer.\n *\n * Each vertex normal buffer ends up with multiple face normals associated with it (from the\n * adjacent faces). The aim is to calculate the average vector from all.\n *\n * @param {Array<THREE.Vector3[]>} buffer\n * @param {number} vertIndex\n * @param {THREE.Vector3} vertexNormal\n */\nvar addVertexNormal = function (buffer, vertIndex, vertexNormal) {\n    if (vertIndex >= buffer.length || typeof buffer[vertIndex] === \"undefined\") {\n        buffer[vertIndex] = [];\n    }\n    buffer[vertIndex].push(vertexNormal);\n};\n/**\n * Compute the average vector from a sequence of (nromal) vectors.\n *\n * @param {Array<THREE.Vector3>} vectors - The vectors to get the average vector for.\n * @returns {THREE.Vector3} The average vector from all given.\n */\nvar computeAverageVector = function (vectors) {\n    var avg = new THREE.Vector3(0, 0, 0);\n    if (vectors) {\n        vectors.forEach(function (nrml) {\n            avg.add(nrml);\n        });\n        avg.divideScalar(vectors.length);\n    }\n    return avg;\n};\n//# sourceMappingURL=computeVertexNormals.js.map","\"use strict\";\n/**\n * @author  Ikaros Kappler\n * @version 1.0.0\n * @date    2021-08-30\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.KEY_SLICED_MESH_LEFT = exports.KEY_SLICED_MESH_RIGHT = exports.KEY_SPLIT_TRIANGULATION_GEOMETRIES = exports.KEY_PLANE_INTERSECTION_TRIANGULATION = exports.KEY_PLANE_INTERSECTION_POINTS = exports.KEY_SPLIT_PANE_MESH = exports.KEY_RIGHT_SLICE_PLANE = exports.KEY_LEFT_SLICE_PLANE = exports.KEY_RIGHT_SLICE_GEOMETRY = exports.KEY_LEFT_SLICE_GEOMETRY = exports.SPLIT_MESH_OFFSET = exports.DEG_TO_RAD = exports.EPS = void 0;\nexports.EPS = 0.000001;\nexports.DEG_TO_RAD = Math.PI / 180.0;\n// Note: z and -z will be used for left and right split.\nexports.SPLIT_MESH_OFFSET = { x: 0, y: -100, z: -50 };\nexports.KEY_LEFT_SLICE_GEOMETRY = \"KEY_LEFT_SLICE_GEOMETRY\"; // THREE.Geometry\nexports.KEY_RIGHT_SLICE_GEOMETRY = \"KEY_RIGHT_SLICE_GEOMETRY\"; // THREE.Geometry\nexports.KEY_LEFT_SLICE_PLANE = \"KEY_LEFT_SLICE_PLANE\"; // THREE.Plane\nexports.KEY_RIGHT_SLICE_PLANE = \"KEY_RIGHT_SLICE_PLANE\"; // THREE.Plane\nexports.KEY_SPLIT_PANE_MESH = \"KEY_SPLIT_PANE_MESH\"; // THREE.Mesh\nexports.KEY_PLANE_INTERSECTION_POINTS = \"KEY_PLANE_INTERSECTION_POINTS\"; // Array<Vector3>\nexports.KEY_PLANE_INTERSECTION_TRIANGULATION = \"KEY_PLANE_INTERSECTION_TRIANGULATION\"; // THREE.Geometry\nexports.KEY_SPLIT_TRIANGULATION_GEOMETRIES = \"KEY_SPLIT_TRIANGULATION_GEOMETRIES\"; // Array<THREE.Geometry>\nexports.KEY_SLICED_MESH_RIGHT = \"KEY_SLICED_MESH_RIGHT\"; // THREE.Mesh\nexports.KEY_SLICED_MESH_LEFT = \"KEY_SLICED_MESH_LEFT\"; // THREE.Mesh\n//# sourceMappingURL=constants.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.DEFAULT_BEZIER_JSON = void 0;\n// Refactored from dildo-generator\nexports.DEFAULT_BEZIER_JSON = \"\\n  [\\n    {\\n       \\\"startPoint\\\":[\\n          -122,\\n          77.80736634304651\\n       ],\\n       \\\"endPoint\\\":[\\n          -65.59022229786551,\\n          21.46778533702511\\n       ],\\n       \\\"startControlPoint\\\":[\\n          -121.62058129515852,\\n          25.08908859418696\\n       ],\\n       \\\"endControlPoint\\\":[\\n          -79.33419353770395,\\n          48.71529293460728\\n       ]\\n    },\\n    {\\n       \\\"startPoint\\\":[\\n          -65.59022229786551,\\n          21.46778533702511\\n       ],\\n       \\\"endPoint\\\":[\\n          -65.66917273472913,\\n          -149.23537680826058\\n       ],\\n       \\\"startControlPoint\\\":[\\n          -52.448492057756646,\\n          -4.585775770903305\\n       ],\\n       \\\"endControlPoint\\\":[\\n          -86.1618869001374,\\n          -62.11613821618976\\n       ]\\n    },\\n    {\\n       \\\"startPoint\\\":[\\n          -65.66917273472913,\\n          -149.23537680826058\\n       ],\\n       \\\"endPoint\\\":[\\n          -61.86203591980055,\\n          -243.8368165606738\\n       ],\\n       \\\"startControlPoint\\\":[\\n          -53.701578771473564,\\n          -200.1123697454778\\n       ],\\n       \\\"endControlPoint\\\":[\\n          -69.80704300441666,\\n          -205.36451303641783\\n       ]\\n    },\\n    {\\n       \\\"startPoint\\\":[\\n          -61.86203591980055,\\n          -243.8368165606738\\n       ],\\n       \\\"endPoint\\\":[\\n          -21.108966092052256,\\n          -323\\n       ],\\n       \\\"startControlPoint\\\":[\\n          -54.08681426887413,\\n          -281.486963896856\\n       ],\\n       \\\"endControlPoint\\\":[\\n          -53.05779349623559,\\n          -323\\n       ]\\n    }\\n ]\\n  \";\n//# sourceMappingURL=defaults.js.map","\"use strict\";\n\n// Export the library to the global scope:\nglobalThis.ngdg = require(\"./ngdg\").ngdg;\n","\"use strict\";\n// http://detectmobilebrowsers.com/\n// @date 2021-11-02\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.isMobileDevice = void 0;\nvar isMobileDevice = function () {\n    return (function (a) {\n        return (/(android|bb\\d+|meego).+mobile|avantgo|bada\\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\\.(browser|link)|vodafone|wap|windows ce|xda|xiino/i.test(a) ||\n            /1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s\\-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|\\-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw\\-(n|u)|c55\\/|capi|ccwa|cdm\\-|cell|chtm|cldc|cmd\\-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc\\-s|devi|dica|dmob|do(c|p)o|ds(12|\\-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(\\-|_)|g1 u|g560|gene|gf\\-5|g\\-mo|go(\\.w|od)|gr(ad|un)|haie|hcit|hd\\-(m|p|t)|hei\\-|hi(pt|ta)|hp( i|ip)|hs\\-c|ht(c(\\-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i\\-(20|go|ma)|i230|iac( |\\-|\\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|kddi|keji|kgt( |\\/)|klon|kpt |kwc\\-|kyo(c|k)|le(no|xi)|lg( g|\\/(k|l|u)|50|54|\\-[a-w])|libw|lynx|m1\\-w|m3ga|m50\\/|ma(te|ui|xo)|mc(01|21|ca)|m\\-cr|me(rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(\\-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)\\-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|\\-([1-8]|c))|phil|pire|pl(ay|uc)|pn\\-2|po(ck|rt|se)|prox|psio|pt\\-g|qa\\-a|qc(07|12|21|32|60|\\-[2-7]|i\\-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h\\-|oo|p\\-)|sdk\\/|se(c(\\-|0|1)|47|mc|nd|ri)|sgh\\-|shar|sie(\\-|m)|sk\\-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h\\-|v\\-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl\\-|tdg\\-|tel(i|m)|tim\\-|t\\-mo|to(pl|sh)|ts(70|m\\-|m3|m5)|tx\\-9|up(\\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|\\-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(\\-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|yas\\-|your|zeto|zte\\-/i.test(a.substr(0, 4)));\n    })(navigator.userAgent || navigator.vendor || window.opera);\n};\nexports.isMobileDevice = isMobileDevice;\n//# sourceMappingURL=isMobileDevice.js.map","\"use strict\";\n/**\n * @author   Ikaros Kappler\n * @date     2021-07-26\n * @modified 2021-08-04 Ported to Typescript from vanilla JS.\n * @version  1.0.1\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.locateVertexInArray = void 0;\n/**\n * Find that vertex in the array that is closest to the given vertex.\n *\n * The epsilon is not optional.\n *\n * @param {Array<THREE.Vector3>} vertArray\n * @param {THREE.Vector3} vertex\n * @param {number} epsilon\n * @returns {number} The index of the found vertex or -1 if not found.\n */\nvar locateVertexInArray = function (vertArray, vertex, epsilon) {\n    var closestDist = Number.POSITIVE_INFINITY;\n    var closestIndex = -1;\n    for (var i = 0; i < vertArray.length; i++) {\n        var dist = vertArray[i].distanceTo(vertex);\n        if (closestIndex === -1 && dist < closestDist && dist < epsilon) {\n            closestIndex = i;\n            closestDist = dist;\n        }\n    }\n    return closestIndex;\n};\nexports.locateVertexInArray = locateVertexInArray;\n//# sourceMappingURL=locateVertexInArray.js.map","\"use strict\";\n/**\n * Merge one geometry (all vertices and faces) into the other.\n *\n * @require locateVertexInArray\n *\n * @author   Ikaros Kappler\n * @date     2021-07-26\n * @modified 2021-08-04 Ported to Typescript from vanilla JS.\n * @modified 2022-02-22 Replaced THREE.Geometry by ThreeGeometryHellfix.Gmetry (and so Face3).\n * @version  1.0.1\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.mergeAndMapVertices = exports.mergeGeometries = void 0;\nvar THREE = require(\"three\");\nvar locateVertexInArray_1 = require(\"./locateVertexInArray\");\nvar three_geometry_hellfix_1 = require(\"three-geometry-hellfix\");\nvar EPS = 0.000001;\n// import { EPS } from \"./constants\";\n/**\n * This function tries to merge the 'mergeGeometry' into the 'baseGeometry'.\n * It assumes that both geometries are somehow connected, so it will try to\n * local equal vertices first instead of just copying all 'mergeGeometry' vertices\n * into the other one.\n *\n * The merged vertices will be cloned.\n *\n * @param {ThreeGeometryHellfix.Gmetry} baseGeometry\n * @param {ThreeGeometryHellfix.Gmetry} mergeGeometry\n */\nvar mergeGeometries = function (baseGeometry, mergeGeometry, epsilon) {\n    if (typeof epsilon === \"undefined\") {\n        epsilon = EPS;\n    }\n    var vertexMap = (0, exports.mergeAndMapVertices)(baseGeometry, mergeGeometry, epsilon);\n    for (var f = 0; f < mergeGeometry.faces.length; f++) {\n        var face = mergeGeometry.faces[f];\n        var a = vertexMap[face.a];\n        var b = vertexMap[face.b];\n        var c = vertexMap[face.c];\n        // baseGeometry.faces.push(new THREE.Face3(a, b, c));\n        // TODO: how to use this here?\n        // Face3 is not a constructor!!! Just a type!!!\n        baseGeometry.faces.push(new three_geometry_hellfix_1.Face3(a, b, c));\n        if (mergeGeometry.faceVertexUvs.length > 0 && f < mergeGeometry.faceVertexUvs[0].length) {\n            var uvData = mergeGeometry.faceVertexUvs[0][f]; // [Vector2,Vector2,Vector2]\n            baseGeometry.faceVertexUvs[0].push([uvData[0].clone(), uvData[1].clone(), uvData[2].clone()]);\n        }\n        else {\n            baseGeometry.faceVertexUvs[0].push([new THREE.Vector2(0.0, 0.0), new THREE.Vector2(0.0, 1.0), new THREE.Vector2(1.0, 0.5)]);\n        }\n    }\n};\nexports.mergeGeometries = mergeGeometries;\n/**\n * This function merges the vertices from a given geometry into a base geometry.\n * It will ty to locate existing vertices within an epsilon range and keep those. Vertices that\n * have no close existing counterpart in the base geometry will be added.\n *\n * The function returns a mapping of new/merged vertices inside the base geometry, showing\n * which vertex (index) was mapped whereto.\n *\n * @param {THREE-Geometry} baseGeometry\n * @param {THREE-Geometry} mergeGeometry\n * @param {number} epsilon\n * @returns Array<number>\n */\nvar mergeAndMapVertices = function (baseGeometry, mergeGeometry, epsilon) {\n    var vertexMap = [];\n    for (var v = 0; v < mergeGeometry.vertices.length; v++) {\n        var mergeVert = mergeGeometry.vertices[v];\n        var indexInBase = (0, locateVertexInArray_1.locateVertexInArray)(baseGeometry.vertices, mergeVert, epsilon);\n        if (indexInBase === -1) {\n            // The current vertex cannot be found in the base geometry.\n            //  -> add to geometry and remember new index.\n            vertexMap.push(baseGeometry.vertices.length);\n            baseGeometry.vertices.push(mergeVert.clone());\n        }\n        else {\n            vertexMap.push(indexInBase);\n        }\n    }\n    return vertexMap;\n};\nexports.mergeAndMapVertices = mergeAndMapVertices;\n//# sourceMappingURL=mergeGeometries.js.map","\"use strict\";\n/**\n * This defines the globally exported wrapper library.\n *\n * See ./src/cjs/entry.js\n *\n * @author   Ikaros Kappler\n * @version  1.0.0\n * @date     2021-09-27\n * @modified 2022-01-29\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.ngdg = void 0;\nvar defaults_1 = require(\"./defaults\");\nvar ImageStore_1 = require(\"./ImageStore\");\nvar DildoGeneration_1 = require(\"./DildoGeneration\");\nvar LocalstorageIO_1 = require(\"./LocalstorageIO\");\nvar isMobileDevice_1 = require(\"./isMobileDevice\");\nvar constants_1 = require(\"./constants\");\nexports.ngdg = {\n    DEFAULT_BEZIER_JSON: defaults_1.DEFAULT_BEZIER_JSON,\n    DEG_TO_RAD: constants_1.DEG_TO_RAD,\n    SPLIT_MESH_OFFSET: constants_1.SPLIT_MESH_OFFSET,\n    KEY_SLICED_MESH_RIGHT: constants_1.KEY_SLICED_MESH_RIGHT,\n    KEY_SLICED_MESH_LEFT: constants_1.KEY_SLICED_MESH_LEFT,\n    LocalstorageIO: LocalstorageIO_1.LocalstorageIO,\n    DildoGeneration: DildoGeneration_1.DildoGeneration,\n    ImageStore: ImageStore_1.ImageStore,\n    isMobileDevice: isMobileDevice_1.isMobileDevice\n};\n//# sourceMappingURL=ngdg.js.map","\"use strict\";\n/**\n * Refactored from some older code from 2020.\n *\n * @requires WebColors\n * @requires WebColorsMalachite\n * @requires WebColorsContrast\n *\n * @author   Ikaros Kappler\n * @date     2021-07-14\n * @modified 2021-08-29 Ported to Typescript from vanilla Js.\n * @version  1.0.1\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.randomWebColor = void 0;\nvar WebColorsMalachite_1 = require(\"plotboilerplate/src/esm/utils/WebColorsMalachite\");\nvar WebColorsContrast_1 = require(\"plotboilerplate/src/esm/utils/WebColorsContrast\");\nvar WebColors_1 = require(\"plotboilerplate/src/esm/utils/WebColors\");\n/**\n * Pick a color from the WebColors array.\n *\n * All params are optional.\n *\n * @param {number=undefined} index\n * @param {\"Malachite\"|\"Mixed\"|\"WebColors\"} colorSet\n **/\nvar randomWebColor = function (index, colorSet) {\n    if (typeof index === \"undefined\") {\n        var maxLen = Math.max(typeof WebColorsMalachite_1.WebColorsMalachite !== \"undefined\" ? WebColorsMalachite_1.WebColorsMalachite.length : 0, typeof WebColorsContrast_1.WebColorsContrast !== \"undefined\" ? WebColorsContrast_1.WebColorsContrast.length : 0, typeof WebColors_1.WebColors !== \"undefined\" ? WebColors_1.WebColors.length : 0);\n        index = Math.round(Math.random() * maxLen);\n    }\n    switch (colorSet) {\n        case \"Malachite\":\n            if (typeof WebColorsMalachite_1.WebColorsMalachite !== \"undefined\") {\n                return WebColorsMalachite_1.WebColorsMalachite[index % WebColorsMalachite_1.WebColorsMalachite.length].cssRGB();\n            }\n            else {\n                console.warn(\"You decided to use the 'WebColorsMalachite' color palette but it is not installed. Falling back.\");\n            }\n        case \"Mixed\":\n            if (typeof WebColorsContrast_1.WebColorsContrast !== \"undefined\") {\n                return WebColorsContrast_1.WebColorsContrast[index % WebColorsContrast_1.WebColorsContrast.length].cssRGB();\n            }\n            else {\n                console.warn(\"You decided to use the 'WebColorsContrast' color palette but it is not installed. Falling back.\");\n            }\n        case \"WebColors\":\n        default:\n            return WebColors_1.WebColors[index % WebColors_1.WebColors.length].cssRGB();\n    }\n};\nexports.randomWebColor = randomWebColor;\n//# sourceMappingURL=randomWebColor.js.map","export const FRONT = 'front';\nexport const BACK = 'back';\nexport const ON = 'on';\nexport const FACE_KEYS = ['a', 'b', 'c'];\n//# sourceMappingURL=constants.js.map","/**\n * Ported to TypeScript from vanilla-js by Ikaros Kappler.\n *\n * @date 2021-09-28\n */\nexport const facesFromEdges = (edges) => {\n    var chains = joinEdges(edges).filter(validFace);\n    var faces = chains.map(function (chain) {\n        return chain.map(function (edge) {\n            return edge[0];\n        });\n    });\n    return faces;\n};\nconst joinEdges = (edges) => {\n    let changes = true;\n    var chains = edges.map((edge) => {\n        return [edge];\n    });\n    while (changes) {\n        changes = connectChains(chains);\n    }\n    chains = chains.filter(function (chain) {\n        return chain.length;\n    });\n    return chains;\n};\nconst connectChains = (chains) => {\n    chains.forEach(function (chainA, i) {\n        chains.forEach(function (chainB, j) {\n            var merged = mergeChains(chainA, chainB);\n            if (merged) {\n                delete chains[j];\n                return true;\n            }\n        });\n    });\n    return false;\n};\nconst mergeChains = (chainA, chainB) => {\n    if (chainA === chainB) {\n        return false;\n    }\n    if (chainStart(chainA) === chainEnd(chainB)) {\n        chainA.unshift.apply(chainA, chainB);\n        return true;\n    }\n    if (chainStart(chainA) === chainStart(chainB)) {\n        reverseChain(chainB);\n        chainA.unshift.apply(chainA, chainB);\n        return true;\n    }\n    if (chainEnd(chainA) === chainStart(chainB)) {\n        chainA.push.apply(chainA, chainB);\n        return true;\n    }\n    if (chainEnd(chainA) === chainEnd(chainB)) {\n        reverseChain(chainB);\n        chainA.push.apply(chainA, chainB);\n        return true;\n    }\n    return false;\n};\nconst chainStart = (chain) => {\n    return chain[0][0];\n};\nconst chainEnd = (chain) => {\n    return chain[chain.length - 1][1];\n};\nconst reverseChain = (chain) => {\n    chain.reverse();\n    chain.forEach(function (edge) {\n        edge.reverse();\n    });\n};\nconst validFace = (chain) => {\n    return chainStart(chain) === chainEnd(chain) ? 1 : 0;\n};\n//# sourceMappingURL=faces-from-edges.js.map","/**\n * Ported to TypeScript from vanilla-js by Ikaros Kappler.\n *\n * @date 2021-09-28\n */\nimport { facesFromEdges } from \"./faces-from-edges\";\nimport { FACE_KEYS } from \"./constants\";\nimport { Face3 } from \"three-geometry-hellfix\";\nexport class GeometryBuilder {\n    constructor(sourceGeometry, targetGeometry, slicePlane) {\n        this.sourceGeometry = sourceGeometry;\n        this.targetGeometry = targetGeometry;\n        this.slicePlane = slicePlane;\n        this.addedVertices = [];\n        this.addedIntersections = [];\n        this.newEdges = [[]];\n    }\n    ;\n    // TODO: check undfined?\n    // This is called without params in line ---67 but param used here as an index??\n    startFace(sourceFaceIndex) {\n        this.sourceFaceIndex = sourceFaceIndex;\n        this.sourceFace = this.sourceGeometry.faces[sourceFaceIndex];\n        this.sourceFaceUvs = this.sourceGeometry.faceVertexUvs[0][sourceFaceIndex];\n        this.faceIndices = [];\n        this.faceNormals = [];\n        this.faceUvs = [];\n    }\n    ;\n    endFace() {\n        var indices = this.faceIndices.map(function (index, i) {\n            return i;\n        });\n        this.addFace(indices);\n    }\n    ;\n    closeHoles() {\n        if (!this.newEdges[0].length) {\n            return;\n        }\n        facesFromEdges(this.newEdges)\n            .forEach((faceIndices) => {\n            var normal = this.faceNormal(faceIndices);\n            if (normal.dot(this.slicePlane.normal) > .5) {\n                faceIndices.reverse();\n            }\n            this.startFace();\n            this.faceIndices = faceIndices;\n            this.endFace();\n        }, this);\n    }\n    ;\n    addVertex(key) {\n        this.addUv(key);\n        this.addNormal(key);\n        const index = this.sourceFace[key];\n        let newIndex;\n        if (this.addedVertices.hasOwnProperty(index)) {\n            newIndex = this.addedVertices[index];\n        }\n        else {\n            const vertex = this.sourceGeometry.vertices[index];\n            this.targetGeometry.vertices.push(vertex);\n            newIndex = this.targetGeometry.vertices.length - 1;\n            this.addedVertices[index] = newIndex;\n        }\n        this.faceIndices.push(newIndex);\n    }\n    ;\n    addIntersection(keyA, keyB, distanceA, distanceB) {\n        const t = Math.abs(distanceA) / (Math.abs(distanceA) + Math.abs(distanceB));\n        this.addIntersectionUv(keyA, keyB, t);\n        this.addIntersectionNormal(keyA, keyB, t);\n        const indexA = this.sourceFace[keyA];\n        const indexB = this.sourceFace[keyB];\n        const id = this.intersectionId(indexA, indexB);\n        let index;\n        if (this.addedIntersections.hasOwnProperty(id)) {\n            index = this.addedIntersections[id];\n        }\n        else {\n            const vertexA = this.sourceGeometry.vertices[indexA];\n            const vertexB = this.sourceGeometry.vertices[indexB];\n            const newVertex = vertexA.clone().lerp(vertexB, t);\n            this.targetGeometry.vertices.push(newVertex);\n            index = this.targetGeometry.vertices.length - 1;\n            this.addedIntersections[id] = index;\n        }\n        this.faceIndices.push(index);\n        this.updateNewEdges(index);\n    }\n    ;\n    addUv(key) {\n        if (!this.sourceFaceUvs) {\n            return;\n        }\n        const index = this.keyIndex(key);\n        const uv = this.sourceFaceUvs[index];\n        this.faceUvs.push(uv);\n    }\n    ;\n    addIntersectionUv(keyA, keyB, t) {\n        if (!this.sourceFaceUvs) {\n            return;\n        }\n        const indexA = this.keyIndex(keyA);\n        const indexB = this.keyIndex(keyB);\n        const uvA = this.sourceFaceUvs[indexA];\n        const uvB = this.sourceFaceUvs[indexB];\n        const uv = uvA.clone().lerp(uvB, t);\n        this.faceUvs.push(uv);\n    }\n    ;\n    addNormal(key) {\n        if (!this.sourceFace.vertexNormals.length) {\n            return;\n        }\n        const index = this.keyIndex(key);\n        const normal = this.sourceFace.vertexNormals[index];\n        this.faceNormals.push(normal);\n    }\n    ;\n    addIntersectionNormal(keyA, keyB, t) {\n        if (!this.sourceFace.vertexNormals.length) {\n            return;\n        }\n        const indexA = this.keyIndex(keyA);\n        const indexB = this.keyIndex(keyB);\n        const normalA = this.sourceFace.vertexNormals[indexA];\n        const normalB = this.sourceFace.vertexNormals[indexB];\n        const normal = normalA.clone().lerp(normalB, t).normalize();\n        this.faceNormals.push(normal);\n    }\n    ;\n    addFace(indices) {\n        if (indices.length === 3) {\n            this.addFacePart(indices[0], indices[1], indices[2]);\n            return;\n        }\n        const pairs = [];\n        for (var i = 0; i < indices.length; i++) {\n            for (var j = i + 1; j < indices.length; j++) {\n                var diff = Math.abs(i - j);\n                if (diff > 1 && diff < indices.length - 1) {\n                    pairs.push([indices[i], indices[j]]);\n                }\n            }\n        }\n        pairs.sort(((pairA, pairB) => {\n            var lengthA = this.faceEdgeLength(pairA[0], pairA[1]);\n            var lengthB = this.faceEdgeLength(pairB[0], pairB[1]);\n            return lengthA - lengthB;\n        }).bind(this));\n        const a = indices.indexOf(pairs[0][0]);\n        indices = indices.slice(a).concat(indices.slice(0, a));\n        const b = indices.indexOf(pairs[0][1]);\n        const indicesA = indices.slice(0, b + 1);\n        const indicesB = indices.slice(b).concat(indices.slice(0, 1));\n        this.addFace(indicesA);\n        this.addFace(indicesB);\n    }\n    ;\n    addFacePart(a, b, c) {\n        let normals = null;\n        if (this.faceNormals.length) {\n            normals = [\n                this.faceNormals[a],\n                this.faceNormals[b],\n                this.faceNormals[c],\n            ];\n        }\n        const face = new Face3(this.faceIndices[a], this.faceIndices[b], this.faceIndices[c], normals);\n        this.targetGeometry.faces.push(face);\n        if (!this.sourceFaceUvs) {\n            return;\n        }\n        this.targetGeometry.faceVertexUvs[0].push([\n            this.faceUvs[a],\n            this.faceUvs[b],\n            this.faceUvs[c]\n        ]);\n    }\n    ;\n    faceEdgeLength(a, b) {\n        const indexA = this.faceIndices[a];\n        const indexB = this.faceIndices[b];\n        const vertexA = this.targetGeometry.vertices[indexA];\n        const vertexB = this.targetGeometry.vertices[indexB];\n        return vertexA.distanceToSquared(vertexB);\n    }\n    ;\n    intersectionId(indexA, indexB) {\n        return [indexA, indexB].sort().join(',');\n    }\n    ;\n    keyIndex(key) {\n        return FACE_KEYS.indexOf(key);\n    }\n    ;\n    updateNewEdges(index) {\n        const edgeIndex = this.newEdges.length - 1;\n        let edge = this.newEdges[edgeIndex];\n        if (edge.length < 2) {\n            edge.push(index);\n        }\n        else {\n            this.newEdges.push([index]);\n        }\n    }\n    ;\n    faceNormal(faceIndices) {\n        const vertices = faceIndices.map(((index) => {\n            return this.targetGeometry.vertices[index];\n        }).bind(this));\n        const edgeA = vertices[0].clone().sub(vertices[1]);\n        const edgeB = vertices[0].clone().sub(vertices[2]);\n        return edgeA.cross(edgeB).normalize();\n    }\n    ;\n}\n//# sourceMappingURL=GeometryBuilder.js.map","import { GeometryBuilder } from \"./GeometryBuilder\";\nimport { BACK, FACE_KEYS, FRONT, ON } from \"./constants\";\nimport { Gmetry } from \"three-geometry-hellfix\";\nexport const sliceGeometry = (geometry, plane, closeHoles) => {\n    const sliced = new Gmetry();\n    const builder = new GeometryBuilder(geometry, sliced, plane);\n    const distances = [];\n    const positions = [];\n    geometry.vertices.forEach((vertex) => {\n        const distance = findDistance(vertex, plane);\n        const position = distanceAsPosition(distance);\n        distances.push(distance);\n        positions.push(position);\n    });\n    geometry.faces.forEach(function (face, faceIndex) {\n        const facePositions = FACE_KEYS.map(function (key) {\n            return positions[face[key]];\n        });\n        if (facePositions.indexOf(FRONT) === -1 &&\n            facePositions.indexOf(BACK) !== -1) {\n            return;\n        }\n        builder.startFace(faceIndex);\n        let lastKey = FACE_KEYS[FACE_KEYS.length - 1];\n        let lastIndex = face[lastKey];\n        let lastDistance = distances[lastIndex];\n        let lastPosition = positions[lastIndex];\n        FACE_KEYS.map((key) => {\n            var index = face[key];\n            var distance = distances[index];\n            var position = positions[index];\n            if (position === FRONT) {\n                if (lastPosition === BACK) {\n                    builder.addIntersection(lastKey, key, lastDistance, distance);\n                    builder.addVertex(key);\n                }\n                else {\n                    builder.addVertex(key);\n                }\n            }\n            if (position === ON) {\n                builder.addVertex(key);\n            }\n            if (position === BACK && lastPosition === FRONT) {\n                builder.addIntersection(lastKey, key, lastDistance, distance);\n            }\n            lastKey = key;\n            lastIndex = index;\n            lastPosition = position;\n            lastDistance = distance;\n        });\n        builder.endFace();\n    });\n    if (closeHoles) {\n        builder.closeHoles();\n    }\n    return sliced;\n};\nconst distanceAsPosition = (distance) => {\n    if (distance < 0) {\n        return BACK;\n    }\n    if (distance > 0) {\n        return FRONT;\n    }\n    return ON;\n};\nconst findDistance = (vertex, plane) => {\n    return plane.distanceToPoint(vertex);\n};\n//# sourceMappingURL=slice.js.map","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n// expose the modules object (__webpack_modules__)\n__webpack_require__.m = __webpack_modules__;\n\n","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","// no baseURI\n\n// object to store loaded and loading chunks\n// undefined = chunk not loaded, null = chunk preloaded/prefetched\n// [resolve, reject, Promise] = chunk loading, 0 = chunk loaded\nvar installedChunks = {\n\t179: 0\n};\n\n// no chunk on demand loading\n\n// no prefetching\n\n// no preloaded\n\n// no HMR\n\n// no HMR manifest\n\n__webpack_require__.O.j = (chunkId) => (installedChunks[chunkId] === 0);\n\n// install a JSONP callback for chunk loading\nvar webpackJsonpCallback = (parentChunkLoadingFunction, data) => {\n\tvar [chunkIds, moreModules, runtime] = data;\n\t// add \"moreModules\" to the modules object,\n\t// then flag all \"chunkIds\" as loaded and fire callback\n\tvar moduleId, chunkId, i = 0;\n\tif(chunkIds.some((id) => (installedChunks[id] !== 0))) {\n\t\tfor(moduleId in moreModules) {\n\t\t\tif(__webpack_require__.o(moreModules, moduleId)) {\n\t\t\t\t__webpack_require__.m[moduleId] = moreModules[moduleId];\n\t\t\t}\n\t\t}\n\t\tif(runtime) var result = runtime(__webpack_require__);\n\t}\n\tif(parentChunkLoadingFunction) parentChunkLoadingFunction(data);\n\tfor(;i < chunkIds.length; i++) {\n\t\tchunkId = chunkIds[i];\n\t\tif(__webpack_require__.o(installedChunks, chunkId) && installedChunks[chunkId]) {\n\t\t\tinstalledChunks[chunkId][0]();\n\t\t}\n\t\tinstalledChunks[chunkId] = 0;\n\t}\n\treturn __webpack_require__.O(result);\n}\n\nvar chunkLoadingGlobal = self[\"webpackChunkngdg\"] = self[\"webpackChunkngdg\"] || [];\nchunkLoadingGlobal.forEach(webpackJsonpCallback.bind(null, 0));\nchunkLoadingGlobal.push = webpackJsonpCallback.bind(null, chunkLoadingGlobal.push.bind(chunkLoadingGlobal));","// startup\n// Load entry module and return exports\n// This entry module depends on other loaded chunks and execution need to be delayed\nvar __webpack_exports__ = __webpack_require__.O(undefined, [736], () => (__webpack_require__(333)))\n__webpack_exports__ = __webpack_require__.O(__webpack_exports__);\n"],"names":["deferred","Object","defineProperty","exports","value","BumpMapper","THREE","computeVertexNormals_1","GeometryGenerationHelpers_1","three_geometry_hellfix_1","applyBumpmap","dildoGeometry","bufferedGeometry","bumpmap","material","options","collectedVertexNormals","computeVertexNormals","dildoNormalGeometry","Gmetry","vertices","map","normalLine","endPoint","end","clone","GeometryGenerationHelpers","normalizeVectorXYZ","start","bumpmapStrength","dildoNormalsMesh","Points","toBufferGeometry","PointsMaterial","size","color","dildoMesh","console","log","useBumpmap","y","vertexMatrix","length","x","vertIndex","vertex","yRatio","xRatio","lerpFactor","getHeightAt","lerpTarget","lerp","Mesh","DildoGeneration","VertexNormalsHelper_1","DildoGeometry_1","DildoMaterials_1","mergeGeometries_1","PathFinder_1","randomWebColor_1","constants_1","BumpMapper_1","canvasId","this","canvas","document","getElementById","parent","parentElement","scene","Scene","camera","PerspectiveCamera","window","innerWidth","innerHeight","position","z","ambientLightA","AmbientLight","set","multiplyScalar","lightDistanceFactor","add","ambientLightB","PointLight","intensityFactor","directionalLightA","DirectionalLight","target","directionalLightB","renderer","WebGLRenderer","preserveDrawingBuffer","antialias","controls","makeOrbitControls","domElement","update","geometries","partialResults","splitResults","_self","addEventListener","resizeCanvas","animate","requestAnimationFrame","render","prototype","width","documentElement","clientWidth","body","height","clientHeight","style","setAttribute","setSize","setViewOffset","rebuild","removeCachedGeometries","clearResults","baseRadius","outline","getBounds","baseShape","mkCircularPolygon","shapeSegmentCount","baseShapeExcentricity","DildoGeometry","assign","useTextureImage","textureImagePath","doubleSingleSide","renderFaces","DoubleSide","BackSide","FrontSide","wireframe","DildoMaterials","createMainMaterial","lookAt","Vector3","spineGeometry","spineVertices","forEach","spineVert","push","addSpine","showBasicPerpendiculars","addPerpendicularPaths","_a","bumpmappedDildoMesh","showBumpmapTargets","SPLIT_MESH_OFFSET","addMesh","performSlice","__performPlaneSlice","userData","showNormals","vnHelper","VertexNormalsHelper","normalsLength","latheMesh","latheUnbufferedGeometry","leftPlane","Plane","leftSliceGeometry","makeSlice","rightPlane","rightSliceGeometry","sliceMaterial","createSliceMaterial","planeGeom","PlaneGeometry","planeMesh","MeshBasicMaterial","transparent","opacity","side","rotation","Math","PI","KEY_SPLIT_PANE_MESH","showSplitPane","planeIntersectionPoints","makeAndAddPlaneIntersection","connectedPaths","PathFinder","findAllPathsOnMesh","p","geometryVertexIndex","geometry","verticesToBufferGeometry","linesMesh_1","Line","LineBasicMaterial","randomWebColor","i","addPrecalculatedShapeOutlines","pointGeometry","linesMesh","triangulatedGeometries","triangulationGeometry","makePlaneTriangulation","closeCutAreas","mergeGeometries","EPS","showLeftSplit","uvsNeedUpdate","buffersNeedUpdate","slicedMeshLeft","KEY_SLICED_MESH_LEFT","showRightSplit","slicedMeshRight","KEY_SLICED_MESH_RIGHT","KEY_LEFT_SLICE_PLANE","KEY_LEFT_SLICE_GEOMETRY","KEY_RIGHT_SLICE_PLANE","KEY_RIGHT_SLICE_GEOMETRY","KEY_PLANE_INTERSECTION_POINTS","KEY_SPLIT_TRIANGULATION_GEOMETRIES","mesh","old","remove","dispose","generateSTL","exporter","stlBuffer","stlData","parse","onComplete","join","warn","extendStatics","__extends","d","b","setPrototypeOf","__proto__","Array","hasOwnProperty","call","TypeError","String","__","constructor","create","plotboilerplate_1","earcut_typescript_1","UVHelpers_1","cjs_1","DEG_TO_RAD","_super","_this","topIndex","bottomIndex","outerPerpLines","innerPerpLines","flatSidePolygon","leftFlatIndices","rightFlatIndices","leftFlatTriangleIndices","rightFlatTriangleIndices","flatSideBounds","hollowBottomEdgeVertIndices","hollowBottomTriagles","dildoNormals","_buildVertices","_buildFaces","_buildUVMapping","bumpmapTexture","__applyBumpmap","__buildSlice","outlineBounds","outlineVert","sliceIndex","heightT","isBending","bendAngle","arcRadius","shapeTwistAngle","outlineXPct","max","shapeVert","vert","rotateVertY","_bendVertex","__buildSpine","shapeCenter","__buildPerps","perpendicularVert","normalizePerpendiculars","halfIndices","floor","j","perpDifference","endVert","rotateVert","outerPerpVert","normalizeVectorXY","Line3","__makeFlatSideVertices","shapeRadius","Polygon","getPerpendicularPathVertices","nextIndex","__makeFlatSideFaces","polygonVertices","flatSideIndex","polygonData","flattenVert2dArray","triangleIndices","earcut","a","c","makeFace3","includeBottomVert","getInner","getPerpendicularHullLines","perpLines","_getTopVertex","topPoint","min","_getBottomVertex","axis","angle","applyAxisAngle","applyBumpMap","bumpMapTexture","outlineSegmentCount","closeTop","Boolean","closeBottom","makeHollow","baseShapeSegmentCount","faceVertexUvs","s","addFace4ByIndices","__makeBackFrontFaces","_buildHollowBottomFaces","_buildEndFaces","edgeVertices","edgeVertIndex","findClosestEdgeIndex","tmpDist","index","distance","Number","MAX_VALUE","tmpIndex","distanceTo","n","lastIndex","curIndex","faces","Face3","endVertexIndex","shapeIndex","inverseFaceDirection","makeFace4","addCylindricUV4","leftA","leftB","leftC","UVHelpers","makeFlatTriangleUVs","rightA","rightB","rightC","ratioI","ratioJ","Vector2","makeHollowBottomUVs","addPyramidalBaseUV3","bendAngleRad","hollowStrengthX","twistAngle","shapeHeight","shapeBounds","getCenter","isNaN","POSITIVE_INFINITY","NEGATIVE_INFINITY","abs","t","getPointAt","getPerpendicularAt","outlineT","topVertex","bottomVertex","xCenter","yCenter","zCenter","thisGeometry","containingPolygonIndices","triangles","polygonBounds","Bounds","computeFromVertices","Vertex","getUVRatios","vertA","vertB","vertC","textureStore","Map","MeshLambertMaterial","depthTest","visible","emissive","reflectivity","refractionRatio","loadTextureImage","MeshPhongMaterial","flatShading","vertexColors","path","texture","get","TextureLoader","load","threejs_slice_geometry_typescript_1","PlaneMeshIntersection_1","clearDuplicateVertices3_1","vertIndexA","vertIndexB","vertIndexC","vertIndexD","ratioA","ratioB","vertices2d","coordinates","radius","pointCount","excentricity","phi","cos","sin","unbufferedGeometry","plane","slicedGeometry","sliceGeometry","mergeVertices","computeFaceNormals","thisGenerator","planeGeometry","planeGeometryReal","intersectionPoints","PlaneMeshIntersection","getIntersectionPoints","uniqueIntersectionPoints","clearDuplicateVertices3","pointsMaterial","pointsMesh","showSplitShape","triangleGeometry","addRawIntersectionTriangleMesh","triangleMesh","addPrecalculatedMassiveFaces","makeAndAddMassivePlaneIntersection","addPrecalculatedHollowFaces","makeAndAddHollowPlaneIntersection","innerPoint","outerPoint","spineMesh","LineSegments","unbufferedDildoGeometry","addPerpendicularPath","materialColor","outerPerpGeometry","perpLine","outerPerpMesh","generator","connectedPath","currentPathXYData","reduce","earcutInput","trianglesGeometry","vector3","trianglesMesh","KEY_PLANE_INTERSECTION_TRIANGULATION","showSplitShapeTriangulation","base","extend","normalLength","diff","ratio","sqrt","removeAllChildNodes","rootNode","lastChild","removeChild","clamp","BufferGeometry","vertexData","Float32Array","accu","BufferAttribute","imageMap","ImageStore","getImage","image","createElement","onload","isImageLoaded","complete","naturalHeight","undefined","LocalstorageIO","onPathRestored","handlePathRestored","requestPath","bezierJSON","localStorage","getItem","setInterval","newBezierJSON","setItem","epsilon","visitedVertices","Set","unvisitedVertIndices","numVisitedVertices","pathVertices","collectedPaths","clear","pathVertIndices","mapVerticesToGeometryIndices","_pathVert","nextUnvisitedIndex","values","next","findUnvisitedPaths","combineAdjacentPaths","unvisitedIndex","adjacentVertIndex","delete","findAdjacentFace","faceCount","f","faceHasVertIndex","pathVertIndex","isVisited","has","resultPaths","unvisitedPathIndexSet","_path","currentPathIndex","currentPath","nextPath","findAdjacentPath","reverse","concat","faceIndex","face","pathVert","foundIndex","foundDist","curDist","currentVertIndex","pointsOfIntersection","mathPlane","getThreePlanePoints","localToWorld","planePointA","copy","planePointB","planePointC","setFromCoplanarPoints","lineAB","lineBC","lineCA","__setPointOfIntersection","line","intersectionPoint","intersectLine","pointOfIntersection","positionAttribute","getAttribute","fromBufferAttribute","result","containsElementFrom","fromIndex","eps","vertexNormals","collectedFaceNormals","faceNormalA","array","faceNormalB","faceNormalC","addVertexNormal","normals","averageNormal","computeAverageVector","buffer","vertexNormal","vectors","avg","nrml","divideScalar","DEFAULT_BEZIER_JSON","globalThis","ngdg","isMobileDevice","navigator","userAgent","vendor","opera","test","substr","locateVertexInArray","vertArray","closestDist","closestIndex","dist","mergeAndMapVertices","locateVertexInArray_1","baseGeometry","mergeGeometry","vertexMap","uvData","v","mergeVert","indexInBase","defaults_1","ImageStore_1","DildoGeneration_1","LocalstorageIO_1","isMobileDevice_1","WebColorsMalachite_1","WebColorsContrast_1","WebColors_1","colorSet","maxLen","WebColorsMalachite","WebColorsContrast","WebColors","round","random","cssRGB","FRONT","BACK","ON","FACE_KEYS","facesFromEdges","edges","joinEdges","filter","validFace","chain","edge","changes","chains","connectChains","chainA","chainB","mergeChains","chainStart","chainEnd","unshift","apply","reverseChain","GeometryBuilder","sourceGeometry","targetGeometry","slicePlane","addedVertices","addedIntersections","newEdges","startFace","sourceFaceIndex","sourceFace","sourceFaceUvs","faceIndices","faceNormals","faceUvs","endFace","indices","addFace","closeHoles","faceNormal","dot","normal","addVertex","key","addUv","addNormal","newIndex","addIntersection","keyA","keyB","distanceA","distanceB","addIntersectionUv","addIntersectionNormal","indexA","indexB","id","intersectionId","vertexA","vertexB","newVertex","updateNewEdges","keyIndex","uv","uvA","uvB","normalA","normalB","normalize","addFacePart","pairs","sort","pairA","pairB","faceEdgeLength","bind","indexOf","slice","indicesA","indicesB","distanceToSquared","edgeIndex","edgeA","sub","edgeB","cross","sliced","builder","distances","positions","findDistance","distanceAsPosition","facePositions","lastKey","lastDistance","lastPosition","distanceToPoint","__webpack_module_cache__","__webpack_require__","moduleId","cachedModule","module","__webpack_modules__","m","O","chunkIds","fn","priority","notFulfilled","Infinity","fulfilled","keys","every","splice","r","definition","o","enumerable","obj","prop","Symbol","toStringTag","installedChunks","chunkId","webpackJsonpCallback","parentChunkLoadingFunction","data","moreModules","runtime","some","chunkLoadingGlobal","self","__webpack_exports__"],"sourceRoot":""}