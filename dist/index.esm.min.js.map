{"version":3,"file":"index.esm.min.js","sources":["../src/esm/clearDuplicateVertices3.js","../src/esm/DildoMaterials.js","../src/esm/UVHelpers.js","../src/esm/defaults.js"],"sourcesContent":["/**\n * @author   Ikaros Kappler\n * @date     2021-07-13\n * @modified 2021-08-04 Ported to Typescript from vainlla JS.\n * @version  1.0.1\n **/\nconst EPS = 0.000001;\n/**\n * Filter the array and clear all duplicates.\n *\n * The original array is left unchanged. The vertices in the array are not cloned.\n *\n * @param {THREE.Vector3[]} vertices\n * @param {number=EPS} epsilon\n * @return {THREE.Vector3[]}\n */\nexport const clearDuplicateVertices3 = (vertices, epsilon) => {\n    if (typeof epsilon === \"undefined\") {\n        epsilon = EPS;\n    }\n    var result = [];\n    for (var i = 0; i < vertices.length; i++) {\n        if (!containsElementFrom(vertices, vertices[i], i + 1, epsilon)) {\n            result.push(vertices[i]);\n        }\n    }\n    return result;\n};\nconst isCloseTo = (vertA, vertB, eps) => {\n    return vertA.distanceTo(vertB) < eps;\n};\nconst containsElementFrom = (vertices, vertex, fromIndex, epsilon) => {\n    for (var i = fromIndex; i < vertices.length; i++) {\n        if (isCloseTo(vertices[i], vertex, epsilon)) {\n            return true;\n        }\n    }\n    return false;\n};\n//# sourceMappingURL=clearDuplicateVertices3.js.map","/**\n * A collection of materials and material making functions.\n *\n * @require THREE\n *\n * @author Ikaros Kappler\n * @date 2021-07-02\n * @modified 2021-08-04 Ported to Typescript from vanilla JS.\n * @version 1.0.1\n */\nimport * as THREE from 'three';\nexport const DildoMaterials = (() => {\n    /**\n     * Map<string,texture>\n     */\n    var textureStore = new Map();\n    const DildoMaterials = {\n        /**\n         * Create a new mesh material from the given parameters.\n         *\n         * @param {boolean} useTextureImage - Load and use the given texture (at `textureImagePath`) if set to true.\n         * @param {boolean} wireframe - Create a wireframe material if true.\n         * @param {string} textureImagePath - The texture path to use (if useTextureImage is set to true).\n         * @param {THREE.DoubleSide|THREE.FrontSide|THREE.Backside} doubleSingleSide - Wether to display one one or both face sides.\n         * @returns\n         */\n        createMainMaterial: function (useTextureImage, wireframe, textureImagePath, doubleSingleSide) {\n            return useTextureImage\n                ? new THREE.MeshLambertMaterial({\n                    color: 0xffffff,\n                    wireframe: wireframe,\n                    //   flatShading: false,\n                    depthTest: true,\n                    opacity: 1.0,\n                    // side: THREE.DoubleSide,\n                    side: doubleSingleSide,\n                    visible: true,\n                    emissive: 0x0,\n                    reflectivity: 1.0,\n                    refractionRatio: 0.89,\n                    map: loadTextureImage(textureImagePath)\n                })\n                : new THREE.MeshPhongMaterial({\n                    color: 0x3838ff,\n                    wireframe: wireframe,\n                    flatShading: false,\n                    depthTest: true,\n                    opacity: 1.0,\n                    // side: THREE.DoubleSide,\n                    side: doubleSingleSide,\n                    visible: true,\n                    emissive: 0x0,\n                    reflectivity: 1.0,\n                    refractionRatio: 0.89,\n                    map: null\n                });\n        },\n        createSliceMaterial: function (useTextureImage, wireframe, textureImagePath) {\n            if (wireframe) {\n                return new THREE.MeshBasicMaterial({ wireframe: true });\n                // return new THREE.MeshStandardMaterial({ wireframe: true });\n            }\n            else {\n                return new THREE.MeshLambertMaterial({\n                    color: useTextureImage ? 0x888888 : 0xa1848a8,\n                    wireframe: false,\n                    // flatShading: false,\n                    depthTest: true,\n                    opacity: 1.0,\n                    side: THREE.DoubleSide,\n                    // side: doubleSingleSide,\n                    visible: true,\n                    emissive: 0x0,\n                    reflectivity: 1.0,\n                    refractionRatio: 0.89,\n                    map: useTextureImage ? loadTextureImage(textureImagePath) : null,\n                    vertexColors: false\n                });\n            }\n        },\n    };\n    /**\n     * Load a texture or get it from the internal buffer if it was already loaded before.\n     *\n     * @param {string} path - The path (absolute or relative) to the texture image to load.\n     * @returns {THREE.Texture}\n     */\n    const loadTextureImage = function (path) {\n        var texture = textureStore.get(path);\n        if (!texture) {\n            var loader = new THREE.TextureLoader();\n            var texture = loader.load(path);\n            textureStore.set(path, texture);\n        }\n        return texture;\n    };\n    return DildoMaterials;\n})();\n//# sourceMappingURL=DildoMaterials.js.map","/**\n * @author   Ikaros Kappler\n * @date     2021-08-03\n * @modified 2021-08-04 Ported to Typsescript from vanilla JS.\n * @version  1.0.1\n */\nimport * as THREE from \"three\";\nexport const UVHelpers = {\n    /**\n     * Helper function to create triangular UV Mappings for a triangle.\n     *\n     * @param {THREE.Geometry} thisGeometry\n     * @param {Bounds} shapeBounds\n     * @param {number} vertIndexA - The index in the geometry's vertices array.\n     * @param {number} vertIndexB - ...\n     * @param {number} vertIndexC - ...\n     */\n    makeFlatTriangleUVs: (thisGeometry, // THREE.Geometry does not longer exist since r125 and will be replaced by BufferGeometry\n    shapeBounds, vertIndexA, vertIndexB, vertIndexC) => {\n        var vertA = thisGeometry.vertices[vertIndexA];\n        var vertB = thisGeometry.vertices[vertIndexB];\n        var vertC = thisGeometry.vertices[vertIndexC];\n        // Convert a position vertex { x, y, * } to UV coordinates { u, v }\n        var getUVRatios = (vert) => {\n            // console.log((vert.x - shapeBounds.min.x) / shapeBounds.width, (vert.y - shapeBounds.min.y) / shapeBounds.height);\n            return new THREE.Vector2((vert.x - shapeBounds.min.x) / shapeBounds.width, (vert.y - shapeBounds.min.y) / shapeBounds.height);\n        };\n        thisGeometry.faceVertexUvs[0].push([getUVRatios(vertA), getUVRatios(vertB), getUVRatios(vertC)]);\n    }\n};\n//# sourceMappingURL=UVHelpers.js.map","// Refactored from dildo-generator\nexport const DEFAULT_BEZIER_JSON = \"[ { \\\"startPoint\\\" : [-122,77.80736634304651], \\\"endPoint\\\" : [-65.59022229786551,21.46778533702511], \\\"startControlPoint\\\": [-121.62058129515852,25.08908859418696], \\\"endControlPoint\\\" : [-79.33419353770395,48.71529293460728] }, { \\\"startPoint\\\" : [-65.59022229786551,21.46778533702511], \\\"endPoint\\\" : [-65.66917273472913,-149.23537680826058], \\\"startControlPoint\\\": [-52.448492057756646,-4.585775770903305], \\\"endControlPoint\\\" : [-86.1618869001374,-62.11613821618976] }, { \\\"startPoint\\\" : [-65.66917273472913,-149.23537680826058], \\\"endPoint\\\" : [-61.86203591980055,-243.8368165606738], \\\"startControlPoint\\\": [-53.701578771473564,-200.1123697454778], \\\"endControlPoint\\\" : [-69.80704300441666,-205.36451303641783] }, { \\\"startPoint\\\" : [-61.86203591980055,-243.8368165606738], \\\"endPoint\\\" : [-21.108966092052256,-323], \\\"startControlPoint\\\": [-54.08681426887413,-281.486963896856], \\\"endControlPoint\\\" : [-53.05779349623559,-323] } ]\";\n//# sourceMappingURL=defaults.js.map"],"names":["containsElementFrom","vertices","vertex","fromIndex","epsilon","i","length","vertA","vertB","eps","distanceTo","DildoMaterials","textureStore","Map","createMainMaterial","useTextureImage","wireframe","textureImagePath","doubleSingleSide","THREE","MeshLambertMaterial","color","depthTest","opacity","side","visible","emissive","reflectivity","refractionRatio","map","loadTextureImage","MeshPhongMaterial","flatShading","createSliceMaterial","MeshBasicMaterial","DoubleSide","vertexColors","path","texture","get","TextureLoader","load","set","UVHelpers","makeFlatTriangleUVs","thisGeometry","shapeBounds","vertIndexA","vertIndexB","vertIndexC","vertC","getUVRatios","vert","Vector2","x","min","width","y","height","faceVertexUvs","push","result"],"mappings":"6XAMA,MAyBMA,EAAsB,CAACC,EAAUC,EAAQC,EAAWC,KACtD,IAAK,IAAIC,EAAIF,EAAWE,EAAIJ,EAASK,OAAQD,IACzC,GALWE,EAKGN,EAASI,GALLG,EAKSN,EALFO,EAKUL,EAJhCG,EAAMG,WAAWF,GAASC,EAKzB,OAAO,EAND,IAACF,EAAOC,EAAOC,EAS7B,OAAO,GC1BEE,EAAiB,MAI1B,IAAIC,EAAe,IAAIC,IACvB,MAAMF,EAAiB,CAUnBG,mBAAoB,SAAUC,EAAiBC,EAAWC,EAAkBC,GACxE,OAAOH,EACD,IAAII,EAAMC,oBAAoB,CAC5BC,MAAO,SACPL,UAAWA,EAEXM,WAAW,EACXC,QAAS,EAETC,KAAMN,EACNO,SAAS,EACTC,SAAU,EACVC,aAAc,EACdC,gBAAiB,IACjBC,IAAKC,EAAiBb,KAExB,IAAIE,EAAMY,kBAAkB,CAC1BV,MAAO,QACPL,UAAWA,EACXgB,aAAa,EACbV,WAAW,EACXC,QAAS,EAETC,KAAMN,EACNO,SAAS,EACTC,SAAU,EACVC,aAAc,EACdC,gBAAiB,IACjBC,IAAK,QAGjBI,oBAAqB,SAAUlB,EAAiBC,EAAWC,GACvD,OAAID,EACO,IAAIG,EAAMe,kBAAkB,CAAElB,WAAW,IAIzC,IAAIG,EAAMC,oBAAoB,CACjCC,MAAON,EAAkB,QAAW,UACpCC,WAAW,EAEXM,WAAW,EACXC,QAAS,EACTC,KAAML,EAAMgB,WAEZV,SAAS,EACTC,SAAU,EACVC,aAAc,EACdC,gBAAiB,IACjBC,IAAKd,EAAkBe,EAAiBb,GAAoB,KAC5DmB,cAAc,MAWxBN,EAAmB,SAAUO,GAE/B,KADIC,EAAU1B,EAAa2B,IAAIF,IACjB,CACV,IACIC,GADS,IAAInB,EAAMqB,eACFC,KAAKJ,GAC1BzB,EAAa8B,IAAIL,EAAMC,GAE3B,OAAOA,GAEX,OAAO3B,GArFmB,GCJjBgC,EAAY,CAUrBC,oBAAqB,CAACC,EACtBC,EAAaC,EAAYC,EAAYC,KACjC,IAAI1C,EAAQsC,EAAa5C,SAAS8C,GAC9BvC,EAAQqC,EAAa5C,SAAS+C,GAC9BE,EAAQL,EAAa5C,SAASgD,GAE9BE,EAAeC,GAER,IAAIjC,EAAMkC,SAASD,EAAKE,EAAIR,EAAYS,IAAID,GAAKR,EAAYU,OAAQJ,EAAKK,EAAIX,EAAYS,IAAIE,GAAKX,EAAYY,QAE1Hb,EAAac,cAAc,GAAGC,KAAK,CAACT,EAAY5C,GAAQ4C,EAAY3C,GAAQ2C,EAAYD,mCC1B7D,49BHeI,CAACjD,EAAUG,UACvB,IAAZA,IACPA,EAZI,MAeR,IADA,IAAIyD,EAAS,GACJxD,EAAI,EAAGA,EAAIJ,EAASK,OAAQD,IAC5BL,EAAoBC,EAAUA,EAASI,GAAIA,EAAI,EAAGD,IACnDyD,EAAOD,KAAK3D,EAASI,IAG7B,OAAOwD"}